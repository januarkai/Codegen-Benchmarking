{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/augmented_road_view.py:AugmentedRoadView:0", "source": "class CLASSTOKEN(CameraView):\n  def __init__(self, stream_type: VisionStreamType = VisionStreamType.VISION_STREAM_ROAD):\n    super().__init__(\"camerad\", stream_type)\n    self._set_placeholder_color(BORDER_COLORS[UIStatus.DISENGAGED])\n\n    self.device_camera: DeviceCameraConfig | None = None\n    self.view_from_calib = view_frame_from_device_frame.copy()\n    self.view_from_wide_calib = view_frame_from_device_frame.copy()\n\n    self._last_calib_time: float = 0\n    self._last_rect_dims = (0.0, 0.0)\n    self._last_stream_type = stream_type\n    self._cached_matrix: np.ndarray | None = None\n    self._content_rect = rl.Rectangle()\n\n    self.model_renderer = ModelRenderer()\n    self._hud_renderer = HudRenderer()\n    self.alert_renderer = AlertRenderer()\n    self.driver_state_renderer = DriverStateRenderer()\n\n    # Callbacks\n    self._click_callback: Callable | None = None\n\n  def set_callbacks(self, on_click: Callable | None = None):\n    self._click_callback = on_click\n\n  def _render(self, rect):\n    # Only render when system is started to avoid invalid data access\n    if not ui_state.started:\n      return\n\n    self._switch_stream_if_needed(ui_state.sm)\n\n    # Update calibration before rendering\n    self._update_calibration()\n\n    # Create inner content area with border padding\n    self._content_rect = rl.Rectangle(\n      rect.x + UI_BORDER_SIZE,\n      rect.y + UI_BORDER_SIZE,\n      rect.width - 2 * UI_BORDER_SIZE,\n      rect.height - 2 * UI_BORDER_SIZE,\n    )\n\n    # Draw colored border based on driving state\n    self._draw_border(rect)\n\n    # Enable scissor mode to clip all rendering within content rectangle boundaries\n    # This creates a rendering viewport that prevents graphics from drawing outside the border\n    rl.begin_scissor_mode(\n      int(self._content_rect.x),\n      int(self._content_rect.y),\n      int(self._content_rect.width),\n      int(self._content_rect.height)\n    )\n\n    # Render the base camera view\n    super()._render(rect)\n\n    # Draw all UI overlays\n    self.model_renderer.render(self._content_rect)\n    self._hud_renderer.render(self._content_rect)\n    if not self.alert_renderer.render(self._content_rect):\n      self.driver_state_renderer.render(self._content_rect)\n\n    # Custom UI extension point - add custom overlays here\n    # Use self._content_rect for positioning within camera bounds\n\n    # End clipping region\n    rl.end_scissor_mode()\n\n    # Handle click events if no HUD interaction occurred\n    if not self._hud_renderer.handle_mouse_event():\n      if self._click_callback is not None and rl.is_mouse_button_pressed(rl.MouseButton.MOUSE_BUTTON_LEFT):\n        if rl.check_collision_point_rec(rl.get_mouse_position(), self._content_rect):\n          self._click_callback()\n\n  def _handle_mouse_release(self, _):\n    pass\n\n  def _draw_border(self, rect: rl.Rectangle):\n    border_color = BORDER_COLORS.get(ui_state.status, BORDER_COLORS[UIStatus.DISENGAGED])\n    rl.draw_rectangle_lines_ex(rect, UI_BORDER_SIZE, border_color)\n\n  def _switch_stream_if_needed(self, sm):\n    if sm['selfdriveState'].experimentalMode and WIDE_CAM in self.available_streams:\n      v_ego = sm['carState'].vEgo\n      if v_ego < WIDE_CAM_MAX_SPEED:\n        target = WIDE_CAM\n      elif v_ego > ROAD_CAM_MIN_SPEED:\n        target = ROAD_CAM\n      else:\n        # Hysteresis zone - keep current stream\n        target = self.stream_type\n    else:\n      target = ROAD_CAM\n\n    if self.stream_type != target:\n      self.switch_stream(target)\n\n  def _update_calibration(self):\n    # Update device camera if not already set\n    sm = ui_state.sm\n    if not self.device_camera and sm.seen['roadCameraState'] and sm.seen['deviceState']:\n      self.device_camera = DEVICE_CAMERAS[(str(sm['deviceState'].deviceType), str(sm['roadCameraState'].sensor))]\n\n    # Check if live calibration data is available and valid\n    if not (sm.updated[\"liveCalibration\"] and sm.valid['liveCalibration']):\n      return\n\n    calib = sm['liveCalibration']\n    if len(calib.rpyCalib) != 3 or calib.calStatus != CALIBRATED:\n      return\n\n    # Update view_from_calib matrix\n    device_from_calib = rot_from_euler(calib.rpyCalib)\n    self.view_from_calib = view_frame_from_device_frame @ device_from_calib\n\n    # Update wide calibration if available\n    if hasattr(calib, 'wideFromDeviceEuler') and len(calib.wideFromDeviceEuler) == 3:\n      wide_from_device = rot_from_euler(calib.wideFromDeviceEuler)\n      self.view_from_wide_calib = view_frame_from_device_frame @ wide_from_device @ device_from_calib\n\n  def _calc_frame_matrix(self, rect: rl.Rectangle) -> np.ndarray:\n    # Check if we can use cached matrix\n    calib_time = ui_state.sm.recv_frame['liveCalibration']\n    current_dims = (self._content_rect.width, self._content_rect.height)\n    if (self._last_calib_time == calib_time and\n        self._last_rect_dims == current_dims and\n        self._last_stream_type == self.stream_type and\n        self._cached_matrix is not None):\n      return self._cached_matrix\n\n    # Get camera configuration\n    device_camera = self.device_camera or DEFAULT_DEVICE_CAMERA\n    is_wide_camera = self.stream_type == WIDE_CAM\n    intrinsic = device_camera.ecam.intrinsics if is_wide_camera else device_camera.fcam.intrinsics\n    calibration = self.view_from_wide_calib if is_wide_camera else self.view_from_calib\n    zoom = 2.0 if is_wide_camera else 1.1\n\n    # Calculate transforms for vanishing point\n    inf_point = np.array([1000.0, 0.0, 0.0])\n    calib_transform = intrinsic @ calibration\n    kep = calib_transform @ inf_point\n\n    # Calculate center points and dimensions\n    x, y = self._content_rect.x, self._content_rect.y\n    w, h = self._content_rect.width, self._content_rect.height\n    cx, cy = intrinsic[0, 2], intrinsic[1, 2]\n\n    # Calculate max allowed offsets with margins\n    margin = 5\n    max_x_offset = cx * zoom - w / 2 - margin\n    max_y_offset = cy * zoom - h / 2 - margin\n\n    # Calculate and clamp offsets to prevent out-of-bounds issues\n    try:\n      if abs(kep[2]) > 1e-6:\n        x_offset = np.clip((kep[0] / kep[2] - cx) * zoom, -max_x_offset, max_x_offset)\n        y_offset = np.clip((kep[1] / kep[2] - cy) * zoom, -max_y_offset, max_y_offset)\n      else:\n        x_offset, y_offset = 0, 0\n    except (ZeroDivisionError, OverflowError):\n      x_offset, y_offset = 0, 0\n\n    # Cache the computed transformation matrix to avoid recalculations\n    self._last_calib_time = calib_time\n    self._last_rect_dims = current_dims\n    self._last_stream_type = self.stream_type\n    self._cached_matrix = np.array([\n      [zoom * 2 * cx / w, 0, -x_offset / w * 2],\n      [0, zoom * 2 * cy / h, -y_offset / h * 2],\n      [0, 0, 1.0]\n    ])\n\n    video_transform = np.array([\n      [zoom, 0.0, (w / 2 + x - x_offset) - (cx * zoom)],\n      [0.0, zoom, (h / 2 + y - y_offset) - (cy * zoom)],\n      [0.0, 0.0, 1.0]\n    ])\n    self.model_renderer.set_transform(video_transform @ calib_transform)\n\n    return self._cached_matrix", "target": "augmented road view"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:ImmediateDisableAlert:7", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.critical, AlertSize.full,\n                     Priority.HIGHEST, VisualAlert.steerRequired,\n                     AudibleAlert.warningImmediate, 4.),", "target": "immediate disable alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:Measurement:3", "source": "class CLASSTOKEN:\n  x, y, z = (property(lambda self: self.xyz[0]), property(lambda self: self.xyz[1]), property(lambda self: self.xyz[2]))\n  x_std, y_std, z_std = (property(lambda self: self.xyz_std[0]), property(lambda self: self.xyz_std[1]), property(lambda self: self.xyz_std[2]))\n  roll, pitch, yaw = x, y, z\n  roll_std, pitch_std, yaw_std = x_std, y_std, z_std\n\n  def __init__(self, xyz: np.ndarray, xyz_std: np.ndarray):\n    self.xyz: np.ndarray = xyz\n    self.xyz_std: np.ndarray = xyz_std\n\n  @classmethod\n  def from_measurement_xyz(cls, measurement: log.LivePose.XYZMeasurement) -> 'CLASSTOKEN':\n    return cls(\n      xyz=np.array([measurement.x, measurement.y, measurement.z]),\n      xyz_std=np.array([measurement.xStd, measurement.yStd, measurement.zStd])\n    )", "target": "measurement"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:Alert:3", "source": "class CLASSTOKEN:\n  def __init__(self,\n               alert_text_1: str,\n               alert_text_2: str,\n               alert_status: log.SelfdriveState.AlertStatus,\n               alert_size: log.SelfdriveState.AlertSize,\n               priority: Priority,\n               visual_alert: car.CarControl.HUDControl.VisualAlert,\n               audible_alert: car.CarControl.HUDControl.AudibleAlert,\n               duration: float,\n               creation_delay: float = 0.):\n\n    self.alert_text_1 = alert_text_1\n    self.alert_text_2 = alert_text_2\n    self.alert_status = alert_status\n    self.alert_size = alert_size\n    self.priority = priority\n    self.visual_alert = visual_alert\n    self.audible_alert = audible_alert\n\n    self.duration = int(duration / DT_CTRL)\n\n    self.creation_delay = creation_delay\n\n    self.alert_type = \"\"\n    self.event_type: str | None = None\n\n  def __str__(self) -> str:\n    return f\"{self.alert_text_1}/{self.alert_text_2} {self.priority} {self.visual_alert} {self.audible_alert}\"\n\n  def __gt__(self, alert2) -> bool:\n    if not isinstance(alert2, CLASSTOKEN):\n      return False\n    return self.priority > alert2.priority", "target": "alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/alert_renderer.py:Alert:0", "source": "class CLASSTOKEN:\n  text1: str = \"\"\n  text2: str = \"\"\n  size: int = 0\n  status: int = 0", "target": "alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/state.py:StateMachine:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.current_alert_types = [ET.PERMANENT]\n    self.state = State.disabled\n    self.soft_disable_timer = 0\n\n  def update(self, events: Events):\n    # decrement the soft disable timer at every step, as it's reset on\n    # entrance in SOFT_DISABLING state\n    self.soft_disable_timer = max(0, self.soft_disable_timer - 1)\n\n    self.current_alert_types = [ET.PERMANENT]\n\n    # ENABLED, SOFT DISABLING, PRE ENABLING, OVERRIDING\n    if self.state != State.disabled:\n      # user and immediate disable always have priority in a non-disabled state\n      if events.contains(ET.USER_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.USER_DISABLE)\n\n      elif events.contains(ET.IMMEDIATE_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.IMMEDIATE_DISABLE)\n\n      else:\n        # ENABLED\n        if self.state == State.enabled:\n          if events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n        # SOFT DISABLING\n        elif self.state == State.softDisabling:\n          if not events.contains(ET.SOFT_DISABLE):\n            # no more soft disabling condition, so go back to ENABLED\n            self.state = State.enabled\n\n          elif self.soft_disable_timer > 0:\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif self.soft_disable_timer <= 0:\n            self.state = State.disabled\n\n        # PRE ENABLING\n        elif self.state == State.preEnabled:\n          if not events.contains(ET.PRE_ENABLE):\n            self.state = State.enabled\n          else:\n            self.current_alert_types.append(ET.PRE_ENABLE)\n\n        # OVERRIDING\n        elif self.state == State.overriding:\n          if events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n          elif not (events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL)):\n            self.state = State.enabled\n          else:\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n    # DISABLED\n    elif self.state == State.disabled:\n      if events.contains(ET.ENABLE):\n        if events.contains(ET.NO_ENTRY):\n          self.current_alert_types.append(ET.NO_ENTRY)\n\n        else:\n          if events.contains(ET.PRE_ENABLE):\n            self.state = State.preEnabled\n          elif events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n          else:\n            self.state = State.enabled\n          self.current_alert_types.append(ET.ENABLE)\n\n    # Check if openpilot is engaged and actuators are enabled\n    enabled = self.state in ENABLED_STATES\n    active = self.state in ACTIVE_STATES\n    if active:\n      self.current_alert_types.append(ET.WARNING)\n    return enabled, active", "target": "state machine"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:Pose:4", "source": "class CLASSTOKEN:\n  def __init__(self, orientation: Measurement, velocity: Measurement, acceleration: Measurement, angular_velocity: Measurement):\n    self.orientation = orientation\n    self.velocity = velocity\n    self.acceleration = acceleration\n    self.angular_velocity = angular_velocity\n\n  @classmethod\n  def from_live_pose(cls, live_pose: log.LivePose) -> 'CLASSTOKEN':\n    return CLASSTOKEN(\n      orientation=Measurement.from_measurement_xyz(live_pose.orientationNED),\n      velocity=Measurement.from_measurement_xyz(live_pose.velocityDevice),\n      acceleration=Measurement.from_measurement_xyz(live_pose.accelerationDevice),\n      angular_velocity=Measurement.from_measurement_xyz(live_pose.angularVelocityDevice)\n    )", "target": "pose"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/max_lat_accel.py:Event:0", "source": "class CLASSTOKEN(NamedTuple):\n  lateral_accel: float\n  speed: float\n  roll: float\n  timestamp: float  # relative to start of route (s)", "target": "event"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/constants.py:Plan:1", "source": "class CLASSTOKEN:\n  POSITION = slice(0, 3)\n  VELOCITY = slice(3, 6)\n  ACCELERATION = slice(6, 9)\n  T_FROM_CURRENT_EULER = slice(9, 12)\n  ORIENTATION_RATE = slice(12, 15)", "target": "plan"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/sidebar.py:MetricData:1", "source": "class CLASSTOKEN:\n  label: str\n  value: str\n  color: rl.Color\n\n  def update(self, label: str, value: str, color: rl.Color):\n    self.label = label\n    self.value = value\n    self.color = color", "target": "metric data"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_models.py:TestCarModelBase:0", "source": "class CLASSTOKEN(unittest.TestCase):\n  platform: Platform | None = None\n  test_route: CarTestRoute | None = None\n\n  can_msgs: list[tuple[int, list[CanData]]]\n  fingerprint: dict[int, dict[int, int]]\n  elm_frame: int | None\n  car_safety_mode_frame: int | None\n\n  @classmethod\n  def get_testing_data_from_logreader(cls, lr):\n    car_fw = []\n    can_msgs = []\n    cls.elm_frame = None\n    cls.car_safety_mode_frame = None\n    cls.fingerprint = gen_empty_fingerprint()\n    alpha_long = False\n    for msg in lr:\n      if msg.which() == \"can\":\n        can = can_capnp_to_list((msg.as_builder().to_bytes(),))[0]\n        can_msgs.append((can[0], [CanData(*can) for can in can[1]]))\n        if len(can_msgs) <= FRAME_FINGERPRINT:\n          for m in msg.can:\n            if m.src < 64:\n              cls.fingerprint[m.src][m.address] = len(m.dat)\n\n      elif msg.which() == \"carParams\":\n        car_fw = msg.carParams.carFw\n        if msg.carParams.openpilotLongitudinalControl:\n          alpha_long = True\n        if cls.platform is None:\n          live_fingerprint = msg.carParams.carFingerprint\n          cls.platform = MIGRATION.get(live_fingerprint, live_fingerprint)\n\n      # Log which can frame the panda safety mode left ELM327, for CAN validity checks\n      elif msg.which() == 'pandaStates':\n        for ps in msg.pandaStates:\n          if cls.elm_frame is None and ps.safetyModel != SafetyModel.elm327:\n            cls.elm_frame = len(can_msgs)\n          if cls.car_safety_mode_frame is None and ps.safetyModel not in \\\n            (SafetyModel.elm327, SafetyModel.noOutput):\n            cls.car_safety_mode_frame = len(can_msgs)\n\n      elif msg.which() == 'pandaStateDEPRECATED':\n        if cls.elm_frame is None and msg.pandaStateDEPRECATED.safetyModel != SafetyModel.elm327:\n          cls.elm_frame = len(can_msgs)\n        if cls.car_safety_mode_frame is None and msg.pandaStateDEPRECATED.safetyModel not in \\\n          (SafetyModel.elm327, SafetyModel.noOutput):\n          cls.car_safety_mode_frame = len(can_msgs)\n\n    assert len(can_msgs) > int(50 / DT_CTRL), \"no can data found\"\n    return car_fw, can_msgs, alpha_long\n\n  @classmethod\n  def get_testing_data(cls):\n    test_segs = (2, 1, 0)\n    if cls.test_route.segment is not None:\n      test_segs = (cls.test_route.segment,)\n\n    for seg in test_segs:\n      segment_range = f\"{cls.test_route.route}/{seg}\"\n\n      try:\n        sources = [internal_source] if len(INTERNAL_SEG_LIST) else [openpilotci_source, comma_api_source]\n        lr = LogReader(segment_range, sources=sources, sort_by_time=True)\n        return cls.get_testing_data_from_logreader(lr)\n      except (LogsUnavailable, AssertionError):\n        pass\n\n    raise Exception(f\"Route: {repr(cls.test_route.route)} with segments: {test_segs} not found or no CAN msgs found. Is it uploaded and public?\")\n\n\n  @classmethod\n  def setUpClass(cls):\n    if cls.__name__ == 'TestCarModel' or cls.__name__.endswith('Base'):\n      raise unittest.SkipTest\n\n    if cls.test_route is None:\n      if cls.platform in non_tested_cars:\n        print(f\"Skipping tests for {cls.platform}: missing route\")\n        raise unittest.SkipTest\n      raise Exception(f\"missing test route for {cls.platform}\")\n\n    car_fw, cls.can_msgs, alpha_long = cls.get_testing_data()\n\n    # if relay is expected to be open in the route\n    cls.openpilot_enabled = cls.car_safety_mode_frame is not None\n\n    cls.CarInterface = interfaces[cls.platform]\n    cls.CP = cls.CarInterface.get_params(cls.platform, cls.fingerprint, car_fw, alpha_long, False, docs=False)\n    assert cls.CP\n    assert cls.CP.carFingerprint == cls.platform\n\n    os.environ[\"COMMA_CACHE\"] = DEFAULT_DOWNLOAD_CACHE_ROOT\n\n  @classmethod\n  def tearDownClass(cls):\n    del cls.can_msgs\n\n  def setUp(self):\n    self.CI = self.CarInterface(self.CP.copy())\n    assert self.CI\n\n    # TODO: check safetyModel is in release panda build\n    self.safety = libsafety_py.libsafety\n\n    cfg = self.CP.safetyConfigs[-1]\n    set_status = self.safety.set_safety_hooks(cfg.safetyModel.raw, cfg.safetyParam)\n    self.assertEqual(0, set_status, f\"failed to set safetyModel {cfg}\")\n    self.safety.init_tests()\n\n  def test_car_params(self):\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check carParams for dashcamOnly\")\n\n    # make sure car params are within a valid range\n    self.assertGreater(self.CP.mass, 1)\n\n    if self.CP.steerControlType != SteerControlType.angle:\n      tuning = self.CP.lateralTuning.which()\n      if tuning == 'pid':\n        self.assertTrue(len(self.CP.lateralTuning.pid.kpV))\n      elif tuning == 'torque':\n        self.assertTrue(self.CP.lateralTuning.torque.kf > 0)\n      else:\n        raise Exception(\"unknown tuning\")\n\n  def test_car_interface(self):\n    # TODO: also check for checksum violations from can parser\n    can_invalid_cnt = 0\n    CC = structs.CarControl().as_reader()\n\n    for i, msg in enumerate(self.can_msgs):\n      CS = self.CI.update(msg)\n      self.CI.apply(CC, msg[0])\n\n      # wait max of 2s for low frequency msgs to be seen\n      if i > 250:\n        can_invalid_cnt += not CS.canValid\n\n    self.assertEqual(can_invalid_cnt, 0)\n\n  def test_radar_interface(self):\n    RI = self.CarInterface.RadarInterface(self.CP)\n    assert RI\n\n    # Since OBD port is multiplexed to bus 1 (commonly radar bus) while fingerprinting,\n    # start parsing CAN messages after we've left ELM mode and can expect CAN traffic\n    error_cnt = 0\n    for i, msg in enumerate(self.can_msgs[self.elm_frame:]):\n      rr: structs.RadarData | None = RI.update(msg)\n      if rr is not None and i > 50:\n        error_cnt += rr.errors.canError\n    self.assertEqual(error_cnt, 0)\n\n  def test_panda_safety_rx_checks(self):\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    start_ts = self.can_msgs[0][0]\n\n    failed_addrs = Counter()\n    for can in self.can_msgs:\n      # update panda timer\n      t = (can[0] - start_ts) / 1e3\n      self.safety.set_timer(int(t))\n\n      # run all msgs through the safety RX hook\n      for msg in can[1]:\n        if msg.src >= 64:\n          continue\n\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        if self.safety.safety_rx_hook(to_send) != 1:\n          failed_addrs[hex(msg.address)] += 1\n\n      # ensure all msgs defined in the addr checks are valid\n      self.safety.safety_tick_current_safety_config()\n      if t > 1e6:\n        self.assertTrue(self.safety.safety_config_valid())\n\n      # Don't check relay malfunction on disabled routes (relay closed),\n      # or before fingerprinting is done (elm327 and noOutput)\n      if self.openpilot_enabled and t / 1e4 > self.car_safety_mode_frame:\n        self.assertFalse(self.safety.get_relay_malfunction())\n      else:\n        self.safety.set_relay_malfunction(False)\n\n    self.assertFalse(len(failed_addrs), f\"panda safety RX check failed: {failed_addrs}\")\n\n    # ensure RX checks go invalid after small time with no traffic\n    self.safety.set_timer(int(t + (2*1e6)))\n    self.safety.safety_tick_current_safety_config()\n    self.assertFalse(self.safety.safety_config_valid())\n\n  def test_panda_safety_tx_cases(self, data=None):\n    \"\"\"Asserts we can tx common messages\"\"\"\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    if self.CP.notCar:\n      self.skipTest(\"Skipping test for notCar\")\n\n    def test_car_controller(car_control):\n      now_nanos = 0\n      msgs_sent = 0\n      CI = self.CarInterface(self.CP)\n      for _ in range(round(10.0 / DT_CTRL)):  # make sure we hit the slowest messages\n        CI.update([])\n        _, sendcan = CI.apply(car_control, now_nanos)\n\n        now_nanos += DT_CTRL * 1e9\n        msgs_sent += len(sendcan)\n        for addr, dat, bus in sendcan:\n          to_send = libsafety_py.make_CANPacket(addr, bus % 4, dat)\n          self.assertTrue(self.safety.safety_tx_hook(to_send), (addr, dat, bus))\n\n      # Make sure we attempted to send messages\n      self.assertGreater(msgs_sent, 50)\n\n    # Make sure we can send all messages while inactive\n    CC = structs.CarControl()\n    test_car_controller(CC.as_reader())\n\n    # Test cancel + general messages (controls_allowed=False & cruise_engaged=True)\n    self.safety.set_cruise_engaged_prev(True)\n    CC = structs.CarControl(cruiseControl=structs.CarControl.CruiseControl(cancel=True))\n    test_car_controller(CC.as_reader())\n\n    # Test resume + general messages (controls_allowed=True & cruise_engaged=True)\n    self.safety.set_controls_allowed(True)\n    CC = structs.CarControl(cruiseControl=structs.CarControl.CruiseControl(resume=True))\n    test_car_controller(CC.as_reader())\n\n  # Skip stdout/stderr capture with pytest, causes elevated memory usage\n  @pytest.mark.nocapture\n  @settings(max_examples=MAX_EXAMPLES, deadline=None,\n            phases=(Phase.reuse, Phase.generate, Phase.shrink))\n  @given(data=st.data())\n  def test_panda_safety_carstate_fuzzy(self, data):\n    \"\"\"\n      For each example, pick a random CAN message on the bus and fuzz its data,\n      checking for panda state mismatches.\n    \"\"\"\n\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    valid_addrs = [(addr, bus, size) for bus, addrs in self.fingerprint.items() for addr, size in addrs.items()]\n    address, bus, size = data.draw(st.sampled_from(valid_addrs))\n\n    msg_strategy = st.binary(min_size=size, max_size=size)\n    msgs = data.draw(st.lists(msg_strategy, min_size=20))\n\n    vehicle_speed_seen = self.CP.steerControlType == SteerControlType.angle and not self.CP.notCar\n\n    for n, dat in enumerate(msgs):\n      # due to panda updating state selectively, only edges are expected to match\n      # TODO: warm up CarState with real CAN messages to check edge of both sources\n      #  (eg. toyota's gasPressed is the inverse of a signal being set)\n      prev_panda_gas = self.safety.get_gas_pressed_prev()\n      prev_panda_brake = self.safety.get_brake_pressed_prev()\n      prev_panda_regen_braking = self.safety.get_regen_braking_prev()\n      prev_panda_steering_disengage = self.safety.get_steering_disengage_prev()\n      prev_panda_vehicle_moving = self.safety.get_vehicle_moving()\n      prev_panda_vehicle_speed_min = self.safety.get_vehicle_speed_min()\n      prev_panda_vehicle_speed_max = self.safety.get_vehicle_speed_max()\n      prev_panda_cruise_engaged = self.safety.get_cruise_engaged_prev()\n      prev_panda_acc_main_on = self.safety.get_acc_main_on()\n\n      to_send = libsafety_py.make_CANPacket(address, bus, dat)\n      self.safety.safety_rx_hook(to_send)\n\n      can = [(int(time.monotonic() * 1e9), [CanData(address=address, dat=dat, src=bus)])]\n      CS = self.CI.update(can)\n      if n < 5:  # CANParser warmup time\n        continue\n\n      if self.safety.get_gas_pressed_prev() != prev_panda_gas:\n        self.assertEqual(CS.gasPressed, self.safety.get_gas_pressed_prev())\n\n      if self.safety.get_brake_pressed_prev() != prev_panda_brake:\n        # TODO: remove this exception once this mismatch is resolved\n        brake_pressed = CS.brakePressed\n        if CS.brakePressed and not self.safety.get_brake_pressed_prev():\n          if self.CP.carFingerprint in (HONDA.HONDA_PILOT, HONDA.HONDA_RIDGELINE) and CS.brake > 0.05:\n            brake_pressed = False\n\n        self.assertEqual(brake_pressed, self.safety.get_brake_pressed_prev())\n\n      if self.safety.get_regen_braking_prev() != prev_panda_regen_braking:\n        self.assertEqual(CS.regenBraking, self.safety.get_regen_braking_prev())\n\n      if self.safety.get_steering_disengage_prev() != prev_panda_steering_disengage:\n        self.assertEqual(CS.steeringDisengage, self.safety.get_steering_disengage_prev())\n\n      if self.safety.get_vehicle_moving() != prev_panda_vehicle_moving and not self.CP.notCar:\n        self.assertEqual(not CS.standstill, self.safety.get_vehicle_moving())\n\n      # check vehicle speed if angle control car or available\n      if self.safety.get_vehicle_speed_min() > 0 or self.safety.get_vehicle_speed_max() > 0:\n        vehicle_speed_seen = True\n\n      if vehicle_speed_seen and (self.safety.get_vehicle_speed_min() != prev_panda_vehicle_speed_min or\n                                 self.safety.get_vehicle_speed_max() != prev_panda_vehicle_speed_max):\n        v_ego_raw = CS.vEgoRaw / self.CP.wheelSpeedFactor\n        self.assertFalse(v_ego_raw > (self.safety.get_vehicle_speed_max() + 1e-3) or\n                         v_ego_raw < (self.safety.get_vehicle_speed_min() - 1e-3))\n\n      if not (self.CP.brand == \"honda\" and not (self.CP.flags & HondaFlags.BOSCH)):\n        if self.safety.get_cruise_engaged_prev() != prev_panda_cruise_engaged:\n          self.assertEqual(CS.cruiseState.enabled, self.safety.get_cruise_engaged_prev())\n\n      if self.CP.brand == \"honda\":\n        if self.safety.get_acc_main_on() != prev_panda_acc_main_on:\n          self.assertEqual(CS.cruiseState.available, self.safety.get_acc_main_on())\n\n  def test_panda_safety_carstate(self):\n    \"\"\"\n      Assert that panda safety matches openpilot's carState\n    \"\"\"\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    # warm up pass, as initial states may be different\n    for can in self.can_msgs[:300]:\n      self.CI.update(can)\n      for msg in filter(lambda m: m.src < 64, can[1]):\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        self.safety.safety_rx_hook(to_send)\n\n    controls_allowed_prev = False\n    CS_prev = car.CarState.new_message()\n    checks = defaultdict(int)\n    vehicle_speed_seen = self.CP.steerControlType == SteerControlType.angle and not self.CP.notCar\n    for idx, can in enumerate(self.can_msgs):\n      CS = self.CI.update(can).as_reader()\n      for msg in filter(lambda m: m.src < 64, can[1]):\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        ret = self.safety.safety_rx_hook(to_send)\n        self.assertEqual(1, ret, f\"safety rx failed ({ret=}): {(msg.address, msg.src % 4)}\")\n\n      # Skip first frame so CS_prev is properly initialized\n      if idx == 0:\n        CS_prev = CS\n        # Button may be left pressed in warm up period\n        if not self.CP.pcmCruise:\n          self.safety.set_controls_allowed(0)\n        continue\n\n      # TODO: check rest of panda's carstate (steering, ACC main on, etc.)\n\n      checks['gasPressed'] += CS.gasPressed != self.safety.get_gas_pressed_prev()\n      checks['standstill'] += (CS.standstill == self.safety.get_vehicle_moving()) and not self.CP.notCar\n\n      # check vehicle speed if angle control car or available\n      if self.safety.get_vehicle_speed_min() > 0 or self.safety.get_vehicle_speed_max() > 0:\n        vehicle_speed_seen = True\n\n      if vehicle_speed_seen:\n        v_ego_raw = CS.vEgoRaw / self.CP.wheelSpeedFactor\n        checks['vEgoRaw'] += (v_ego_raw > (self.safety.get_vehicle_speed_max() + 1e-3) or\n                              v_ego_raw < (self.safety.get_vehicle_speed_min() - 1e-3))\n\n      # TODO: remove this exception once this mismatch is resolved\n      brake_pressed = CS.brakePressed\n      if CS.brakePressed and not self.safety.get_brake_pressed_prev():\n        if self.CP.carFingerprint in (HONDA.HONDA_PILOT, HONDA.HONDA_RIDGELINE) and CS.brake > 0.05:\n          brake_pressed = False\n      checks['brakePressed'] += brake_pressed != self.safety.get_brake_pressed_prev()\n      checks['regenBraking'] += CS.regenBraking != self.safety.get_regen_braking_prev()\n      checks['steeringDisengage'] += CS.steeringDisengage != self.safety.get_steering_disengage_prev()\n\n      if self.CP.pcmCruise:\n        # On most pcmCruise cars, openpilot's state is always tied to the PCM's cruise state.\n        # On Honda Nidec, we always engage on the rising edge of the PCM cruise state, but\n        # openpilot brakes to zero even if the min ACC speed is non-zero (i.e. the PCM disengages).\n        if self.CP.brand == \"honda\" and not (self.CP.flags & HondaFlags.BOSCH):\n          # only the rising edges are expected to match\n          if CS.cruiseState.enabled and not CS_prev.cruiseState.enabled:\n            checks['controlsAllowed'] += not self.safety.get_controls_allowed()\n        else:\n          checks['controlsAllowed'] += not CS.cruiseState.enabled and self.safety.get_controls_allowed()\n\n        # TODO: fix notCar mismatch\n        if not self.CP.notCar:\n          checks['cruiseState'] += CS.cruiseState.enabled != self.safety.get_cruise_engaged_prev()\n      else:\n        # Check for user button enable on rising edge of controls allowed\n        button_enable = CS.buttonEnable and (not CS.brakePressed or CS.standstill)\n        mismatch = button_enable != (self.safety.get_controls_allowed() and not controls_allowed_prev)\n        checks['controlsAllowed'] += mismatch\n        controls_allowed_prev = self.safety.get_controls_allowed()\n        if button_enable and not mismatch:\n          self.safety.set_controls_allowed(False)\n\n      if self.CP.brand == \"honda\":\n        checks['mainOn'] += CS.cruiseState.available != self.safety.get_acc_main_on()\n\n      CS_prev = CS\n\n    failed_checks = {k: v for k, v in checks.items() if v > 0}\n    self.assertFalse(len(failed_checks), f\"panda safety doesn't agree with openpilot: {failed_checks}\")", "target": "test car model base"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:UpdateAlert:5", "source": "class CLASSTOKEN(AbstractAlert):\n  def __init__(self):\n    super().__init__(has_reboot_btn=True)\n    self.release_notes = \"\"\n    self._wrapped_release_notes = \"\"\n    self._cached_content_height: float = 0.0\n\n  def refresh(self) -> bool:\n    update_available: bool = self.params.get_bool(\"UpdateAvailable\")\n    if update_available:\n      self.release_notes = self.params.get(\"UpdaterNewReleaseNotes\")\n      self._cached_content_height = 0\n\n    return update_available\n\n  def get_content_height(self) -> float:\n    if not self.release_notes:\n      return 100\n\n    if self._cached_content_height == 0:\n      self._wrapped_release_notes = self.release_notes\n      size = measure_text_cached(gui_app.font(FontWeight.NORMAL), self._wrapped_release_notes, AlertConstants.FONT_SIZE)\n      self._cached_content_height = max(size.y + 60, 100)\n\n    return self._cached_content_height\n\n  def _render_content(self, content_rect: rl.Rectangle):\n    if self.release_notes:\n      rl.draw_text_ex(\n        gui_app.font(FontWeight.NORMAL),\n        self._wrapped_release_notes,\n        rl.Vector2(content_rect.x + 30, content_rect.y + 30),\n        AlertConstants.FONT_SIZE,\n        0.0,\n        AlertColors.TEXT,\n      )\n    else:\n      no_notes_text = \"No release notes available.\"\n      text_width = rl.measure_text(no_notes_text, AlertConstants.FONT_SIZE)\n      text_x = content_rect.x + (content_rect.width - text_width) // 2\n      text_y = content_rect.y + 50\n      rl.draw_text(no_notes_text, int(text_x), int(text_y), AlertConstants.FONT_SIZE, AlertColors.TEXT)", "target": "update alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/tests/test_alertmanager.py:TestAlertManager:0", "source": "class CLASSTOKEN:\n\n  def test_duration(self):\n    \"\"\"\n      Enforce that an alert lasts for max(alert duration, duration the alert is added)\n    \"\"\"\n    for duration in range(1, 100):\n      alert = None\n      while not isinstance(alert, Alert):\n        event = random.choice([e for e in EVENTS.values() if len(e)])\n        alert = random.choice(list(event.values()))\n\n      alert.duration = duration\n\n      # check two cases:\n      # - alert is added to AM for <= the alert's duration\n      # - alert is added to AM for > alert's duration\n      for greater in (True, False):\n        if greater:\n          add_duration = duration + random.randint(1, 10)\n        else:\n          add_duration = random.randint(1, duration)\n        show_duration = max(duration, add_duration)\n\n        AM = AlertManager()\n        for frame in range(duration+10):\n          if frame < add_duration:\n            AM.add_many(frame, [alert, ])\n          AM.process_alerts(frame, set())\n\n          shown = AM.current_alert != EmptyAlert\n          should_show = frame <= show_duration\n          assert shown == should_show, f\"{frame=} {add_duration=} {duration=}\"\n\n      # check one case:\n      # - if alert is re-added to AM before it ends the duration is extended\n      if duration > 1:\n        AM = AlertManager()\n        show_duration = duration * 2\n        for frame in range(duration * 2 + 10):\n          if frame == 0:\n            AM.add_many(frame, [alert, ])\n\n          if frame == duration:\n            # add alert one frame before it ends\n            assert AM.current_alert == alert\n            AM.add_many(frame, [alert, ])\n          AM.process_alerts(frame, set())\n\n          shown = AM.current_alert != EmptyAlert\n          should_show = frame <= show_duration\n          assert shown == should_show, f\"{frame=} {duration=}\"", "target": "test alert manager"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/car_kf.py:States:0", "source": "class CLASSTOKEN:\n  # Vehicle model params\n  STIFFNESS = _slice(1)  # [-]\n  STEER_RATIO = _slice(1)  # [-]\n  ANGLE_OFFSET = _slice(1)  # [rad]\n  ANGLE_OFFSET_FAST = _slice(1)  # [rad]\n\n  VELOCITY = _slice(2)  # (x, y) [m/s]\n  YAW_RATE = _slice(1)  # [rad/s]\n  STEER_ANGLE = _slice(1)  # [rad]\n  ROAD_ROLL = _slice(1)  # [rad]", "target": "states"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/alertmanager.py:AlertEntry:0", "source": "class CLASSTOKEN:\n  alert: Alert | None = None\n  start_frame: int = -1\n  end_frame: int = -1\n  added_frame: int = -1\n\n  def active(self, frame: int) -> bool:\n    return frame <= self.end_frame\n\n  def just_added(self, frame: int) -> bool:\n    return self.active(frame) and frame == (self.added_frame + 1)", "target": "alert entry"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DriverPose:2", "source": "class CLASSTOKEN:\n  def __init__(self, max_trackable):\n    self.yaw = 0.\n    self.pitch = 0.\n    self.roll = 0.\n    self.yaw_std = 0.\n    self.pitch_std = 0.\n    self.roll_std = 0.\n    self.pitch_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.yaw_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.calibrated = False\n    self.low_std = True\n    self.cfactor_pitch = 1.\n    self.cfactor_yaw = 1.", "target": "driver pose"}
