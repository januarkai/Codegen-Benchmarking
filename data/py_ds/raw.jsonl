{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/check_can_parser_performance.py:CarModelTestCase:0", "source": "class CLASSTOKEN(TestCarModelBase):\n  test_route = CarTestRoute(DEMO_ROUTE, None)", "target": "car model test case"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/max_lat_accel.py:Event:0", "source": "class CLASSTOKEN(NamedTuple):\n  lateral_accel: float\n  speed: float\n  roll: float\n  timestamp: float  # relative to start of route (s)", "target": "event"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/car/vw_mqb_config.py:VOLKSWAGEN_DATA_IDENTIFIER_TYPE:0", "source": "class CLASSTOKEN(IntEnum):\n  CODING = 0x0600", "target": "volkswagen data identifier type"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/car/vw_mqb_config.py:ACCESS_TYPE_LEVEL_1:1", "source": "class CLASSTOKEN(IntEnum):\n  REQUEST_SEED = ACCESS_TYPE.REQUEST_SEED + 2\n  SEND_KEY = ACCESS_TYPE.SEND_KEY + 2", "target": "access type level 1"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/debug/car/hyundai_enable_radar_points.py:ConfigValues:0", "source": "class CLASSTOKEN(NamedTuple):\n  default_config: bytes\n  tracks_enabled: bytes", "target": "config values"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/controlsd.py:Controls:0", "source": "class CLASSTOKEN:\n  def __init__(self) -> None:\n    self.params = Params()\n    cloudlog.info(\"controlsd is waiting for CarParams\")\n    self.CP = messaging.log_from_bytes(self.params.get(\"CarParams\", block=True), car.CarParams)\n    cloudlog.info(\"controlsd got CarParams\")\n\n    self.CI = interfaces[self.CP.carFingerprint](self.CP)\n\n    self.sm = messaging.SubMaster(['liveParameters', 'liveTorqueParameters', 'modelV2', 'selfdriveState',\n                                   'liveCalibration', 'livePose', 'longitudinalPlan', 'carState', 'carOutput',\n                                   'driverMonitoringState', 'onroadEvents', 'driverAssistance'], poll='selfdriveState')\n    self.pm = messaging.PubMaster(['carControl', 'controlsState'])\n\n    self.steer_limited_by_safety = False\n    self.curvature = 0.0\n    self.desired_curvature = 0.0\n\n    self.pose_calibrator = PoseCalibrator()\n    self.calibrated_pose: Pose | None = None\n\n    self.LoC = LongControl(self.CP)\n    self.VM = VehicleModel(self.CP)\n    self.LaC: LatControl\n    if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n      self.LaC = LatControlAngle(self.CP, self.CI)\n    elif self.CP.lateralTuning.which() == 'pid':\n      self.LaC = LatControlPID(self.CP, self.CI)\n    elif self.CP.lateralTuning.which() == 'torque':\n      self.LaC = LatControlTorque(self.CP, self.CI)\n\n  def update(self):\n    self.sm.update(15)\n    if self.sm.updated[\"liveCalibration\"]:\n      self.pose_calibrator.feed_live_calib(self.sm['liveCalibration'])\n    if self.sm.updated[\"livePose\"]:\n      device_pose = Pose.from_live_pose(self.sm['livePose'])\n      self.calibrated_pose = self.pose_calibrator.build_calibrated_pose(device_pose)\n\n  def state_control(self):\n    CS = self.sm['carState']\n\n    # Update VehicleModel\n    lp = self.sm['liveParameters']\n    x = max(lp.stiffnessFactor, 0.1)\n    sr = max(lp.steerRatio, 0.1)\n    self.VM.update_params(x, sr)\n\n    steer_angle_without_offset = math.radians(CS.steeringAngleDeg - lp.angleOffsetDeg)\n    self.curvature = -self.VM.calc_curvature(steer_angle_without_offset, CS.vEgo, lp.roll)\n\n    # Update Torque Params\n    if self.CP.lateralTuning.which() == 'torque':\n      torque_params = self.sm['liveTorqueParameters']\n      if self.sm.all_checks(['liveTorqueParameters']) and torque_params.useParams:\n        self.LaC.update_live_torque_params(torque_params.latAccelFactorFiltered, torque_params.latAccelOffsetFiltered,\n                                           torque_params.frictionCoefficientFiltered)\n\n    long_plan = self.sm['longitudinalPlan']\n    model_v2 = self.sm['modelV2']\n\n    CC = car.CarControl.new_message()\n    CC.enabled = self.sm['selfdriveState'].enabled\n\n    # Check which actuators can be enabled\n    standstill = abs(CS.vEgo) <= max(self.CP.minSteerSpeed, 0.3) or CS.standstill\n    CC.latActive = self.sm['selfdriveState'].active and not CS.steerFaultTemporary and not CS.steerFaultPermanent and \\\n                   (not standstill or self.CP.steerAtStandstill)\n    CC.longActive = CC.enabled and not any(e.overrideLongitudinal for e in self.sm['onroadEvents']) and self.CP.openpilotLongitudinalControl\n\n    actuators = CC.actuators\n    actuators.longControlState = self.LoC.long_control_state\n\n    # Enable blinkers while lane changing\n    if model_v2.meta.laneChangeState != LaneChangeState.off:\n      CC.leftBlinker = model_v2.meta.laneChangeDirection == LaneChangeDirection.left\n      CC.rightBlinker = model_v2.meta.laneChangeDirection == LaneChangeDirection.right\n\n    if not CC.latActive:\n      self.LaC.reset()\n    if not CC.longActive:\n      self.LoC.reset()\n\n    # accel PID loop\n    pid_accel_limits = self.CI.get_pid_accel_limits(self.CP, CS.vEgo, CS.vCruise * CV.KPH_TO_MS)\n    actuators.accel = float(self.LoC.update(CC.longActive, CS, long_plan.aTarget, long_plan.shouldStop, pid_accel_limits))\n\n    # Steering PID loop and lateral MPC\n    # Reset desired curvature to current to avoid violating the limits on engage\n    new_desired_curvature = model_v2.action.desiredCurvature if CC.latActive else self.curvature\n    self.desired_curvature, curvature_limited = clip_curvature(CS.vEgo, self.desired_curvature, new_desired_curvature, lp.roll)\n\n    actuators.curvature = self.desired_curvature\n    steer, steeringAngleDeg, lac_log = self.LaC.update(CC.latActive, CS, self.VM, lp,\n                                                       self.steer_limited_by_safety, self.desired_curvature,\n                                                       curvature_limited)  # TODO what if not available\n    actuators.torque = float(steer)\n    actuators.steeringAngleDeg = float(steeringAngleDeg)\n    # Ensure no NaNs/Infs\n    for p in ACTUATOR_FIELDS:\n      attr = getattr(actuators, p)\n      if not isinstance(attr, Number):\n        continue\n\n      if not math.isfinite(attr):\n        cloudlog.error(f\"actuators.{p} not finite {actuators.to_dict()}\")\n        setattr(actuators, p, 0.0)\n\n    return CC, lac_log\n\n  def publish(self, CC, lac_log):\n    CS = self.sm['carState']\n\n    # Orientation and angle rates can be useful for carcontroller\n    # Only calibrated (car) frame is relevant for the carcontroller\n    CC.currentCurvature = self.curvature\n    if self.calibrated_pose is not None:\n      CC.orientationNED = self.calibrated_pose.orientation.xyz.tolist()\n      CC.angularVelocity = self.calibrated_pose.angular_velocity.xyz.tolist()\n\n    CC.cruiseControl.override = CC.enabled and not CC.longActive and self.CP.openpilotLongitudinalControl\n    CC.cruiseControl.cancel = CS.cruiseState.enabled and (not CC.enabled or not self.CP.pcmCruise)\n    CC.cruiseControl.resume = CC.enabled and CS.cruiseState.standstill and not self.sm['longitudinalPlan'].shouldStop\n\n    hudControl = CC.hudControl\n    hudControl.setSpeed = float(CS.vCruiseCluster * CV.KPH_TO_MS)\n    hudControl.speedVisible = CC.enabled\n    hudControl.lanesVisible = CC.enabled\n    hudControl.leadVisible = self.sm['longitudinalPlan'].hasLead\n    hudControl.leadDistanceBars = self.sm['selfdriveState'].personality.raw + 1\n    hudControl.visualAlert = self.sm['selfdriveState'].alertHudVisual\n\n    hudControl.rightLaneVisible = True\n    hudControl.leftLaneVisible = True\n    if self.sm.valid['driverAssistance']:\n      hudControl.leftLaneDepart = self.sm['driverAssistance'].leftLaneDeparture\n      hudControl.rightLaneDepart = self.sm['driverAssistance'].rightLaneDeparture\n\n    if self.sm['selfdriveState'].active:\n      CO = self.sm['carOutput']\n      if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n        self.steer_limited_by_safety = abs(CC.actuators.steeringAngleDeg - CO.actuatorsOutput.steeringAngleDeg) > \\\n                                              STEER_ANGLE_SATURATION_THRESHOLD\n      else:\n        self.steer_limited_by_safety = abs(CC.actuators.torque - CO.actuatorsOutput.torque) > 1e-2\n\n    # TODO: both controlsState and carControl valids should be set by\n    #       sm.all_checks(), but this creates a circular dependency\n\n    # controlsState\n    dat = messaging.new_message('controlsState')\n    dat.valid = CS.canValid\n    cs = dat.controlsState\n\n    cs.curvature = self.curvature\n    cs.longitudinalPlanMonoTime = self.sm.logMonoTime['longitudinalPlan']\n    cs.lateralPlanMonoTime = self.sm.logMonoTime['modelV2']\n    cs.desiredCurvature = self.desired_curvature\n    cs.longControlState = self.LoC.long_control_state\n    cs.upAccelCmd = float(self.LoC.pid.p)\n    cs.uiAccelCmd = float(self.LoC.pid.i)\n    cs.ufAccelCmd = float(self.LoC.pid.f)\n    cs.forceDecel = bool((self.sm['driverMonitoringState'].awarenessStatus < 0.) or\n                         (self.sm['selfdriveState'].state == State.softDisabling))\n\n    lat_tuning = self.CP.lateralTuning.which()\n    if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n      cs.lateralControlState.angleState = lac_log\n    elif lat_tuning == 'pid':\n      cs.lateralControlState.pidState = lac_log\n    elif lat_tuning == 'torque':\n      cs.lateralControlState.torqueState = lac_log\n\n    self.pm.send('controlsState', dat)\n\n    # carControl\n    cc_send = messaging.new_message('carControl')\n    cc_send.valid = CS.canValid\n    cc_send.carControl = CC\n    self.pm.send('carControl', cc_send)\n\n  def run(self):\n    rk = Ratekeeper(100, print_delay_threshold=None)\n    while True:\n      self.update()\n      CC, lac_log = self.state_control()\n      self.publish(CC, lac_log)\n      rk.monitor_time()", "target": "controls"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:KalmanParams:0", "source": "class CLASSTOKEN:\n  def __init__(self, dt: float):\n    # Lead Kalman Filter params, calculating K from A, C, Q, R requires the control library.\n    # hardcoding a lookup table to compute K for values of radar_ts between 0.01s and 0.2s\n    assert dt > .01 and dt < .2, \"Radar time step must be between .01s and 0.2s\"\n    self.A = [[1.0, dt], [0.0, 1.0]]\n    self.C = [1.0, 0.0]\n    #Q = np.matrix([[10., 0.0], [0.0, 100.]])\n    #R = 1e3\n    #K = np.matrix([[ 0.05705578], [ 0.03073241]])\n    dts = [i * 0.01 for i in range(1, 21)]\n    K0 = [0.12287673, 0.14556536, 0.16522756, 0.18281627, 0.1988689,  0.21372394,\n          0.22761098, 0.24069424, 0.253096,   0.26491023, 0.27621103, 0.28705801,\n          0.29750003, 0.30757767, 0.31732515, 0.32677158, 0.33594201, 0.34485814,\n          0.35353899, 0.36200124]\n    K1 = [0.29666309, 0.29330885, 0.29042818, 0.28787125, 0.28555364, 0.28342219,\n          0.28144091, 0.27958406, 0.27783249, 0.27617149, 0.27458948, 0.27307714,\n          0.27162685, 0.27023228, 0.26888809, 0.26758976, 0.26633338, 0.26511557,\n          0.26393339, 0.26278425]\n    self.K = [[np.interp(dt, dts, K0)], [np.interp(dt, dts, K1)]]", "target": "kalman params"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:Track:1", "source": "class CLASSTOKEN:\n  def __init__(self, identifier: int, v_lead: float, kalman_params: KalmanParams):\n    self.identifier = identifier\n    self.cnt = 0\n    self.aLeadTau = FirstOrderFilter(_LEAD_ACCEL_TAU, 0.45, DT_MDL)\n    self.K_A = kalman_params.A\n    self.K_C = kalman_params.C\n    self.K_K = kalman_params.K\n    self.kf = KF1D([[v_lead], [0.0]], self.K_A, self.K_C, self.K_K)\n\n  def update(self, d_rel: float, y_rel: float, v_rel: float, v_lead: float, measured: float):\n    # relative values, copy\n    self.dRel = d_rel   # LONG_DIST\n    self.yRel = y_rel   # -LAT_DIST\n    self.vRel = v_rel   # REL_SPEED\n    self.vLead = v_lead\n    self.measured = measured   # measured or estimate\n\n    # computed velocity and accelerations\n    if self.cnt > 0:\n      self.kf.update(self.vLead)\n\n    self.vLeadK = float(self.kf.x[SPEED][0])\n    self.aLeadK = float(self.kf.x[ACCEL][0])\n\n    # Learn if constant acceleration\n    if abs(self.aLeadK) < 0.5:\n      self.aLeadTau.x = _LEAD_ACCEL_TAU\n    else:\n      self.aLeadTau.update(0.0)\n\n    self.cnt += 1\n\n  def get_RadarState(self, model_prob: float = 0.0):\n    return {\n      \"dRel\": float(self.dRel),\n      \"yRel\": float(self.yRel),\n      \"vRel\": float(self.vRel),\n      \"vLead\": float(self.vLead),\n      \"vLeadK\": float(self.vLeadK),\n      \"aLeadK\": float(self.aLeadK),\n      \"aLeadTau\": float(self.aLeadTau.x),\n      \"status\": True,\n      \"fcw\": self.is_potential_fcw(model_prob),\n      \"modelProb\": model_prob,\n      \"radar\": True,\n      \"radarTrackId\": self.identifier,\n    }\n\n  def potential_low_speed_lead(self, v_ego: float):\n    # stop for stuff in front of you and low speed, even without model confirmation\n    # Radar points closer than 0.75, are almost always glitches on toyota radars\n    return abs(self.yRel) < 1.0 and (v_ego < V_EGO_STATIONARY) and (0.75 < self.dRel < 25)\n\n  def is_potential_fcw(self, model_prob: float):\n    return model_prob > .9\n\n  def __str__(self):\n    ret = f\"x: {self.dRel:4.1f}  y: {self.yRel:4.1f}  v: {self.vRel:4.1f}  a: {self.aLeadK:4.1f}\"\n    return ret", "target": "track"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:RadarD:2", "source": "class CLASSTOKEN:\n  def __init__(self, delay: float = 0.0):\n    self.current_time = 0.0\n\n    self.tracks: dict[int, Track] = {}\n    self.kalman_params = KalmanParams(DT_MDL)\n\n    self.v_ego = 0.0\n    self.v_ego_hist = deque([0.0], maxlen=int(round(delay / DT_MDL))+1)\n    self.last_v_ego_frame = -1\n\n    self.radar_state: capnp._DynamicStructBuilder | None = None\n    self.radar_state_valid = False\n\n    self.ready = False\n\n  def update(self, sm: messaging.SubMaster, rr: car.RadarData):\n    self.ready = sm.seen['modelV2']\n    self.current_time = 1e-9*max(sm.logMonoTime.values())\n\n    if sm.recv_frame['carState'] != self.last_v_ego_frame:\n      self.v_ego = sm['carState'].vEgo\n      self.v_ego_hist.append(self.v_ego)\n      self.last_v_ego_frame = sm.recv_frame['carState']\n\n    ar_pts = {pt.trackId: [pt.dRel, pt.yRel, pt.vRel, pt.measured] for pt in rr.points}\n\n    # *** remove missing points from meta data ***\n    for ids in list(self.tracks.keys()):\n      if ids not in ar_pts:\n        self.tracks.pop(ids, None)\n\n    # *** compute the tracks ***\n    for ids in ar_pts:\n      rpt = ar_pts[ids]\n\n      # align v_ego by a fixed time to align it with the radar measurement\n      v_lead = rpt[2] + self.v_ego_hist[0]\n\n      # create the track if it doesn't exist or it's a new track\n      if ids not in self.tracks:\n        self.tracks[ids] = Track(ids, v_lead, self.kalman_params)\n      self.tracks[ids].update(rpt[0], rpt[1], rpt[2], v_lead, rpt[3])\n\n    # *** publish radarState ***\n    self.radar_state_valid = sm.all_checks()\n    self.radar_state = log.RadarState.new_message()\n    self.radar_state.mdMonoTime = sm.logMonoTime['modelV2']\n    self.radar_state.radarErrors = rr.errors\n    self.radar_state.carStateMonoTime = sm.logMonoTime['carState']\n\n    if len(sm['modelV2'].velocity.x):\n      model_v_ego = sm['modelV2'].velocity.x[0]\n    else:\n      model_v_ego = self.v_ego\n    leads_v3 = sm['modelV2'].leadsV3\n    if len(leads_v3) > 1:\n      self.radar_state.leadOne = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[0], model_v_ego, low_speed_override=True)\n      self.radar_state.leadTwo = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[1], model_v_ego, low_speed_override=False)\n\n  def publish(self, pm: messaging.PubMaster):\n    assert self.radar_state is not None\n\n    radar_msg = messaging.new_message(\"radarState\")\n    radar_msg.valid = self.radar_state_valid\n    radar_msg.radarState = self.radar_state\n    pm.send(\"radarState\", radar_msg)", "target": "radar d"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/latcontrol_angle.py:LatControlAngle:0", "source": "class CLASSTOKEN(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.sat_check_min_speed = 5.\n    self.use_steer_limited_by_safety = CP.brand == \"tesla\"\n\n  def update(self, active, CS, VM, params, steer_limited_by_safety, desired_curvature, curvature_limited):\n    angle_log = log.ControlsState.LateralAngleState.new_message()\n\n    if not active:\n      angle_log.active = False\n      angle_steers_des = float(CS.steeringAngleDeg)\n    else:\n      angle_log.active = True\n      angle_steers_des = math.degrees(VM.get_steer_from_curvature(-desired_curvature, CS.vEgo, params.roll))\n      angle_steers_des += params.angleOffsetDeg\n\n    if self.use_steer_limited_by_safety:\n      # these cars' carcontrollers calculate max lateral accel and jerk, so we can rely on carOutput for saturation\n      angle_control_saturated = steer_limited_by_safety\n    else:\n      # for cars which use a method of limiting torque such as a torque signal (Nissan and Toyota)\n      # or relying on EPS (Ford Q3), carOutput does not capture maxing out torque  # TODO: this can be improved\n      angle_control_saturated = abs(angle_steers_des - CS.steeringAngleDeg) > STEER_ANGLE_SATURATION_THRESHOLD\n    angle_log.saturated = bool(self._check_saturation(angle_control_saturated, CS, False, curvature_limited))\n    angle_log.steeringAngleDeg = float(CS.steeringAngleDeg)\n    angle_log.steeringAngleDesiredDeg = angle_steers_des\n    return 0, float(angle_steers_des), angle_log", "target": "lat control angle"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/longitudinal_planner.py:LongitudinalPlanner:0", "source": "class CLASSTOKEN:\n  def __init__(self, CP, init_v=0.0, init_a=0.0, dt=DT_MDL):\n    self.CP = CP\n    self.mpc = LongitudinalMpc(dt=dt)\n    # TODO remove mpc modes when TR released\n    self.mpc.mode = 'acc'\n    self.fcw = False\n    self.dt = dt\n    self.allow_throttle = True\n\n    self.a_desired = init_a\n    self.v_desired_filter = FirstOrderFilter(init_v, 2.0, self.dt)\n    self.prev_accel_clip = [ACCEL_MIN, ACCEL_MAX]\n    self.output_a_target = 0.0\n    self.output_should_stop = False\n\n    self.v_desired_trajectory = np.zeros(CONTROL_N)\n    self.a_desired_trajectory = np.zeros(CONTROL_N)\n    self.j_desired_trajectory = np.zeros(CONTROL_N)\n    self.solverExecutionTime = 0.0\n\n  @staticmethod\n  def parse_model(model_msg):\n    if (len(model_msg.position.x) == ModelConstants.IDX_N and\n      len(model_msg.velocity.x) == ModelConstants.IDX_N and\n      len(model_msg.acceleration.x) == ModelConstants.IDX_N):\n      x = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.position.x)\n      v = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.velocity.x)\n      a = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.acceleration.x)\n      j = np.zeros(len(T_IDXS_MPC))\n    else:\n      x = np.zeros(len(T_IDXS_MPC))\n      v = np.zeros(len(T_IDXS_MPC))\n      a = np.zeros(len(T_IDXS_MPC))\n      j = np.zeros(len(T_IDXS_MPC))\n    if len(model_msg.meta.disengagePredictions.gasPressProbs) > 1:\n      throttle_prob = model_msg.meta.disengagePredictions.gasPressProbs[1]\n    else:\n      throttle_prob = 1.0\n    return x, v, a, j, throttle_prob\n\n  def update(self, sm):\n    mode = 'blended' if sm['selfdriveState'].experimentalMode else 'acc'\n\n    if len(sm['carControl'].orientationNED) == 3:\n      accel_coast = get_coast_accel(sm['carControl'].orientationNED[1])\n    else:\n      accel_coast = ACCEL_MAX\n\n    v_ego = sm['carState'].vEgo\n    v_cruise_kph = min(sm['carState'].vCruise, V_CRUISE_MAX)\n    v_cruise = v_cruise_kph * CV.KPH_TO_MS\n    v_cruise_initialized = sm['carState'].vCruise != V_CRUISE_UNSET\n\n    long_control_off = sm['controlsState'].longControlState == LongCtrlState.off\n    force_slow_decel = sm['controlsState'].forceDecel\n\n    # Reset current state when not engaged, or user is controlling the speed\n    reset_state = long_control_off if self.CP.openpilotLongitudinalControl else not sm['selfdriveState'].enabled\n    # PCM cruise speed may be updated a few cycles later, check if initialized\n    reset_state = reset_state or not v_cruise_initialized\n\n    # No change cost when user is controlling the speed, or when standstill\n    prev_accel_constraint = not (reset_state or sm['carState'].standstill)\n\n    if mode == 'acc':\n      accel_clip = [ACCEL_MIN, get_max_accel(v_ego)]\n      steer_angle_without_offset = sm['carState'].steeringAngleDeg - sm['liveParameters'].angleOffsetDeg\n      accel_clip = limit_accel_in_turns(v_ego, steer_angle_without_offset, accel_clip, self.CP)\n    else:\n      accel_clip = [ACCEL_MIN, ACCEL_MAX]\n\n    if reset_state:\n      self.v_desired_filter.x = v_ego\n      # Clip aEgo to cruise limits to prevent large accelerations when becoming active\n      self.a_desired = np.clip(sm['carState'].aEgo, accel_clip[0], accel_clip[1])\n\n    # Prevent divergence, smooth in current v_ego\n    self.v_desired_filter.x = max(0.0, self.v_desired_filter.update(v_ego))\n    x, v, a, j, throttle_prob = self.parse_model(sm['modelV2'])\n    # Don't clip at low speeds since throttle_prob doesn't account for creep\n    self.allow_throttle = throttle_prob > ALLOW_THROTTLE_THRESHOLD or v_ego <= MIN_ALLOW_THROTTLE_SPEED\n\n    if not self.allow_throttle:\n      clipped_accel_coast = max(accel_coast, accel_clip[0])\n      clipped_accel_coast_interp = np.interp(v_ego, [MIN_ALLOW_THROTTLE_SPEED, MIN_ALLOW_THROTTLE_SPEED*2], [accel_clip[1], clipped_accel_coast])\n      accel_clip[1] = min(accel_clip[1], clipped_accel_coast_interp)\n\n    if force_slow_decel:\n      v_cruise = 0.0\n\n    self.mpc.set_weights(prev_accel_constraint, personality=sm['selfdriveState'].personality)\n    self.mpc.set_cur_state(self.v_desired_filter.x, self.a_desired)\n    self.mpc.update(sm['radarState'], v_cruise, x, v, a, j, personality=sm['selfdriveState'].personality)\n\n    self.v_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC, self.mpc.v_solution)\n    self.a_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC, self.mpc.a_solution)\n    self.j_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC[:-1], self.mpc.j_solution)\n\n    # TODO counter is only needed because radar is glitchy, remove once radar is gone\n    self.fcw = self.mpc.crash_cnt > 2 and not sm['carState'].standstill\n    if self.fcw:\n      cloudlog.info(\"FCW triggered\")\n\n    # Interpolate 0.05 seconds and save as starting point for next iteration\n    a_prev = self.a_desired\n    self.a_desired = float(np.interp(self.dt, CONTROL_N_T_IDX, self.a_desired_trajectory))\n    self.v_desired_filter.x = self.v_desired_filter.x + self.dt * (self.a_desired + a_prev) / 2.0\n\n    action_t =  self.CP.longitudinalActuatorDelay + DT_MDL\n    output_a_target_mpc, output_should_stop_mpc = get_accel_from_plan(self.v_desired_trajectory, self.a_desired_trajectory, CONTROL_N_T_IDX,\n                                                                        action_t=action_t, vEgoStopping=self.CP.vEgoStopping)\n    output_a_target_e2e = sm['modelV2'].action.desiredAcceleration\n    output_should_stop_e2e = sm['modelV2'].action.shouldStop\n\n    if mode == 'acc':\n      output_a_target = output_a_target_mpc\n      self.output_should_stop = output_should_stop_mpc\n    else:\n      output_a_target = min(output_a_target_mpc, output_a_target_e2e)\n      self.output_should_stop = output_should_stop_e2e or output_should_stop_mpc\n\n    for idx in range(2):\n      accel_clip[idx] = np.clip(accel_clip[idx], self.prev_accel_clip[idx] - 0.05, self.prev_accel_clip[idx] + 0.05)\n    self.output_a_target = np.clip(output_a_target, accel_clip[0], accel_clip[1])\n    self.prev_accel_clip = accel_clip\n\n  def publish(self, sm, pm):\n    plan_send = messaging.new_message('longitudinalPlan')\n\n    plan_send.valid = sm.all_checks(service_list=['carState', 'controlsState', 'selfdriveState', 'radarState'])\n\n    longitudinalPlan = plan_send.longitudinalPlan\n    longitudinalPlan.modelMonoTime = sm.logMonoTime['modelV2']\n    longitudinalPlan.processingDelay = (plan_send.logMonoTime / 1e9) - sm.logMonoTime['modelV2']\n    longitudinalPlan.solverExecutionTime = self.mpc.solve_time\n\n    longitudinalPlan.speeds = self.v_desired_trajectory.tolist()\n    longitudinalPlan.accels = self.a_desired_trajectory.tolist()\n    longitudinalPlan.jerks = self.j_desired_trajectory.tolist()\n\n    longitudinalPlan.hasLead = sm['radarState'].leadOne.status\n    longitudinalPlan.longitudinalPlanSource = self.mpc.source\n    longitudinalPlan.fcw = self.fcw\n\n    longitudinalPlan.aTarget = float(self.output_a_target)\n    longitudinalPlan.shouldStop = bool(self.output_should_stop)\n    longitudinalPlan.allowBrake = True\n    longitudinalPlan.allowThrottle = bool(self.allow_throttle)\n\n    pm.send('longitudinalPlan', plan_send)", "target": "longitudinal planner"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/ldw.py:LaneDepartureWarning:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.left = False\n    self.right = False\n    self.last_blinker_frame = 0\n\n  def update(self, frame, modelV2, CS, CC):\n    if CS.leftBlinker or CS.rightBlinker:\n      self.last_blinker_frame = frame\n\n    recent_blinker = (frame - self.last_blinker_frame) * DT_CTRL < 5.0  # 5s blinker cooldown\n    ldw_allowed = CS.vEgo > LDW_MIN_SPEED and not recent_blinker and not CC.latActive\n\n    desire_prediction = modelV2.meta.desirePrediction\n    if len(desire_prediction) and ldw_allowed:\n      right_lane_visible = modelV2.laneLineProbs[2] > 0.5\n      left_lane_visible = modelV2.laneLineProbs[1] > 0.5\n      l_lane_change_prob = desire_prediction[log.Desire.laneChangeLeft]\n      r_lane_change_prob = desire_prediction[log.Desire.laneChangeRight]\n\n      lane_lines = modelV2.laneLines\n      l_lane_close = left_lane_visible and (lane_lines[1].y[0] > -(1.08 + CAMERA_OFFSET))\n      r_lane_close = right_lane_visible and (lane_lines[2].y[0] < (1.08 - CAMERA_OFFSET))\n\n      self.left = bool(l_lane_change_prob > LANE_DEPARTURE_THRESHOLD and l_lane_close)\n      self.right = bool(r_lane_change_prob > LANE_DEPARTURE_THRESHOLD and r_lane_close)\n    else:\n      self.left, self.right = False, False\n\n  @property\n  def warning(self) -> bool:\n    return bool(self.left or self.right)", "target": "lane departure warning"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/latcontrol_pid.py:LatControlPID:0", "source": "class CLASSTOKEN(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.pid = PIDController((CP.lateralTuning.pid.kpBP, CP.lateralTuning.pid.kpV),\n                             (CP.lateralTuning.pid.kiBP, CP.lateralTuning.pid.kiV),\n                             k_f=CP.lateralTuning.pid.kf, pos_limit=self.steer_max, neg_limit=-self.steer_max)\n    self.get_steer_feedforward = CI.get_steer_feedforward_function()\n\n  def update(self, active, CS, VM, params, steer_limited_by_safety, desired_curvature, curvature_limited):\n    pid_log = log.ControlsState.LateralPIDState.new_message()\n    pid_log.steeringAngleDeg = float(CS.steeringAngleDeg)\n    pid_log.steeringRateDeg = float(CS.steeringRateDeg)\n\n    angle_steers_des_no_offset = math.degrees(VM.get_steer_from_curvature(-desired_curvature, CS.vEgo, params.roll))\n    angle_steers_des = angle_steers_des_no_offset + params.angleOffsetDeg\n    error = angle_steers_des - CS.steeringAngleDeg\n\n    pid_log.steeringAngleDesiredDeg = angle_steers_des\n    pid_log.angleError = error\n    if not active:\n      output_torque = 0.0\n      pid_log.active = False\n\n    else:\n      # offset does not contribute to resistive torque\n      ff = self.get_steer_feedforward(angle_steers_des_no_offset, CS.vEgo)\n      freeze_integrator = steer_limited_by_safety or CS.steeringPressed or CS.vEgo < 5\n\n      output_torque = self.pid.update(error,\n                                feedforward=ff,\n                                speed=CS.vEgo,\n                                freeze_integrator=freeze_integrator)\n\n      pid_log.active = True\n      pid_log.p = float(self.pid.p)\n      pid_log.i = float(self.pid.i)\n      pid_log.f = float(self.pid.f)\n      pid_log.output = float(output_torque)\n      pid_log.saturated = bool(self._check_saturation(self.steer_max - abs(output_torque) < 1e-3, CS, steer_limited_by_safety, curvature_limited))\n\n    return output_torque, angle_steers_des, pid_log", "target": "lat control pid"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/longcontrol.py:LongControl:0", "source": "class CLASSTOKEN:\n  def __init__(self, CP):\n    self.CP = CP\n    self.long_control_state = LongCtrlState.off\n    self.pid = PIDController((CP.longitudinalTuning.kpBP, CP.longitudinalTuning.kpV),\n                             (CP.longitudinalTuning.kiBP, CP.longitudinalTuning.kiV),\n                             k_f=CP.longitudinalTuning.kf, rate=1 / DT_CTRL)\n    self.last_output_accel = 0.0\n\n  def reset(self):\n    self.pid.reset()\n\n  def update(self, active, CS, a_target, should_stop, accel_limits):\n    \"\"\"Update longitudinal control. This updates the state machine and runs a PID loop\"\"\"\n    self.pid.neg_limit = accel_limits[0]\n    self.pid.pos_limit = accel_limits[1]\n\n    self.long_control_state = long_control_state_trans(self.CP, active, self.long_control_state, CS.vEgo,\n                                                       should_stop, CS.brakePressed,\n                                                       CS.cruiseState.standstill)\n    if self.long_control_state == LongCtrlState.off:\n      self.reset()\n      output_accel = 0.\n\n    elif self.long_control_state == LongCtrlState.stopping:\n      output_accel = self.last_output_accel\n      if output_accel > self.CP.stopAccel:\n        output_accel = min(output_accel, 0.0)\n        output_accel -= self.CP.stoppingDecelRate * DT_CTRL\n      self.reset()\n\n    elif self.long_control_state == LongCtrlState.starting:\n      output_accel = self.CP.startAccel\n      self.reset()\n\n    else:  # LongCtrlState.pid\n      error = a_target - CS.aEgo\n      output_accel = self.pid.update(error, speed=CS.vEgo,\n                                     feedforward=a_target)\n\n    self.last_output_accel = np.clip(output_accel, accel_limits[0], accel_limits[1])\n    return self.last_output_accel", "target": "long control"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/latcontrol.py:LatControl:0", "source": "class CLASSTOKEN(ABC):\n  def __init__(self, CP, CI):\n    self.sat_count_rate = 1.0 * DT_CTRL\n    self.sat_limit = CP.steerLimitTimer\n    self.sat_count = 0.\n    self.sat_check_min_speed = 10.\n\n    # we define the steer torque scale as [-1.0...1.0]\n    self.steer_max = 1.0\n\n  @abstractmethod\n  def update(self, active, CS, VM, params, steer_limited_by_safety, desired_curvature, calibrated_pose, curvature_limited):\n    pass\n\n  def reset(self):\n    self.sat_count = 0.\n\n  def _check_saturation(self, saturated, CS, steer_limited_by_safety, curvature_limited):\n    # Saturated only if control output is not being limited by car torque/angle rate limits\n    if (saturated or curvature_limited) and CS.vEgo > self.sat_check_min_speed and not steer_limited_by_safety and not CS.steeringPressed:\n      self.sat_count += self.sat_count_rate\n    else:\n      self.sat_count -= self.sat_count_rate\n    self.sat_count = np.clip(self.sat_count, 0.0, self.sat_limit)\n    return self.sat_count > (self.sat_limit - 1e-3)", "target": "lat control"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/latcontrol_torque.py:LatControlTorque:0", "source": "class CLASSTOKEN(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.torque_params = CP.lateralTuning.torque.as_builder()\n    self.torque_from_lateral_accel = CI.torque_from_lateral_accel()\n    self.lateral_accel_from_torque = CI.lateral_accel_from_torque()\n    self.pid = PIDController(self.torque_params.kp, self.torque_params.ki,\n                             k_f=self.torque_params.kf)\n    self.update_limits()\n    self.steering_angle_deadzone_deg = self.torque_params.steeringAngleDeadzoneDeg\n\n  def update_live_torque_params(self, latAccelFactor, latAccelOffset, friction):\n    self.torque_params.latAccelFactor = latAccelFactor\n    self.torque_params.latAccelOffset = latAccelOffset\n    self.torque_params.friction = friction\n    self.update_limits()\n\n  def update_limits(self):\n    self.pid.set_limits(self.lateral_accel_from_torque(self.steer_max, self.torque_params),\n                        self.lateral_accel_from_torque(-self.steer_max, self.torque_params))\n\n  def update(self, active, CS, VM, params, steer_limited_by_safety, desired_curvature, curvature_limited):\n    pid_log = log.ControlsState.LateralTorqueState.new_message()\n    if not active:\n      output_torque = 0.0\n      pid_log.active = False\n    else:\n      actual_curvature = -VM.calc_curvature(math.radians(CS.steeringAngleDeg - params.angleOffsetDeg), CS.vEgo, params.roll)\n      roll_compensation = params.roll * ACCELERATION_DUE_TO_GRAVITY\n      curvature_deadzone = abs(VM.calc_curvature(math.radians(self.steering_angle_deadzone_deg), CS.vEgo, 0.0))\n\n      desired_lateral_accel = desired_curvature * CS.vEgo ** 2\n      actual_lateral_accel = actual_curvature * CS.vEgo ** 2\n      lateral_accel_deadzone = curvature_deadzone * CS.vEgo ** 2\n\n      low_speed_factor = np.interp(CS.vEgo, LOW_SPEED_X, LOW_SPEED_Y)**2\n      setpoint = desired_lateral_accel + low_speed_factor * desired_curvature\n      measurement = actual_lateral_accel + low_speed_factor * actual_curvature\n      gravity_adjusted_lateral_accel = desired_lateral_accel - roll_compensation\n\n      # do error correction in lateral acceleration space, convert at end to handle non-linear torque responses correctly\n      pid_log.error = float(setpoint - measurement)\n      ff = gravity_adjusted_lateral_accel\n      # latAccelOffset corrects roll compensation bias from device roll misalignment relative to car roll\n      ff -= self.torque_params.latAccelOffset\n      ff += get_friction(desired_lateral_accel - actual_lateral_accel, lateral_accel_deadzone, FRICTION_THRESHOLD, self.torque_params)\n\n      freeze_integrator = steer_limited_by_safety or CS.steeringPressed or CS.vEgo < 5\n      output_lataccel = self.pid.update(pid_log.error,\n                                      feedforward=ff,\n                                      speed=CS.vEgo,\n                                      freeze_integrator=freeze_integrator)\n      output_torque = self.torque_from_lateral_accel(output_lataccel, self.torque_params)\n\n      pid_log.active = True\n      pid_log.p = float(self.pid.p)\n      pid_log.i = float(self.pid.i)\n      pid_log.d = float(self.pid.d)\n      pid_log.f = float(self.pid.f)\n      pid_log.output = float(-output_torque)  # TODO: log lat accel?\n      pid_log.actualLateralAccel = float(actual_lateral_accel)\n      pid_log.desiredLateralAccel = float(desired_lateral_accel)\n      pid_log.saturated = bool(self._check_saturation(self.steer_max - abs(output_torque) < 1e-3, CS, steer_limited_by_safety, curvature_limited))\n\n    # TODO left is positive in this convention\n    return -output_torque, 0.0, pid_log", "target": "lat control torque"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/desire_helper.py:DesireHelper:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.lane_change_state = LaneChangeState.off\n    self.lane_change_direction = LaneChangeDirection.none\n    self.lane_change_timer = 0.0\n    self.lane_change_ll_prob = 1.0\n    self.keep_pulse_timer = 0.0\n    self.prev_one_blinker = False\n    self.desire = log.Desire.none\n\n  @staticmethod\n  def get_lane_change_direction(CS):\n    return LaneChangeDirection.left if CS.leftBlinker else LaneChangeDirection.right\n\n  def update(self, carstate, lateral_active, lane_change_prob):\n    v_ego = carstate.vEgo\n    one_blinker = carstate.leftBlinker != carstate.rightBlinker\n    below_lane_change_speed = v_ego < LANE_CHANGE_SPEED_MIN\n\n    if not lateral_active or self.lane_change_timer > LANE_CHANGE_TIME_MAX:\n      self.lane_change_state = LaneChangeState.off\n      self.lane_change_direction = LaneChangeDirection.none\n    else:\n      # LaneChangeState.off\n      if self.lane_change_state == LaneChangeState.off and one_blinker and not self.prev_one_blinker and not below_lane_change_speed:\n        self.lane_change_state = LaneChangeState.preLaneChange\n        self.lane_change_ll_prob = 1.0\n        # Initialize lane change direction to prevent UI alert flicker\n        self.lane_change_direction = self.get_lane_change_direction(carstate)\n\n      # LaneChangeState.preLaneChange\n      elif self.lane_change_state == LaneChangeState.preLaneChange:\n        # Update lane change direction\n        self.lane_change_direction = self.get_lane_change_direction(carstate)\n\n        torque_applied = carstate.steeringPressed and \\\n                         ((carstate.steeringTorque > 0 and self.lane_change_direction == LaneChangeDirection.left) or\n                          (carstate.steeringTorque < 0 and self.lane_change_direction == LaneChangeDirection.right))\n\n        blindspot_detected = ((carstate.leftBlindspot and self.lane_change_direction == LaneChangeDirection.left) or\n                              (carstate.rightBlindspot and self.lane_change_direction == LaneChangeDirection.right))\n\n        if not one_blinker or below_lane_change_speed:\n          self.lane_change_state = LaneChangeState.off\n          self.lane_change_direction = LaneChangeDirection.none\n        elif torque_applied and not blindspot_detected:\n          self.lane_change_state = LaneChangeState.laneChangeStarting\n\n      # LaneChangeState.laneChangeStarting\n      elif self.lane_change_state == LaneChangeState.laneChangeStarting:\n        # fade out over .5s\n        self.lane_change_ll_prob = max(self.lane_change_ll_prob - 2 * DT_MDL, 0.0)\n\n        # 98% certainty\n        if lane_change_prob < 0.02 and self.lane_change_ll_prob < 0.01:\n          self.lane_change_state = LaneChangeState.laneChangeFinishing\n\n      # LaneChangeState.laneChangeFinishing\n      elif self.lane_change_state == LaneChangeState.laneChangeFinishing:\n        # fade in laneline over 1s\n        self.lane_change_ll_prob = min(self.lane_change_ll_prob + DT_MDL, 1.0)\n\n        if self.lane_change_ll_prob > 0.99:\n          self.lane_change_direction = LaneChangeDirection.none\n          if one_blinker:\n            self.lane_change_state = LaneChangeState.preLaneChange\n          else:\n            self.lane_change_state = LaneChangeState.off\n\n    if self.lane_change_state in (LaneChangeState.off, LaneChangeState.preLaneChange):\n      self.lane_change_timer = 0.0\n    else:\n      self.lane_change_timer += DT_MDL\n\n    self.prev_one_blinker = one_blinker\n\n    self.desire = DESIRES[self.lane_change_direction][self.lane_change_state]\n\n    # Send keep pulse once per second during LaneChangeStart.preLaneChange\n    if self.lane_change_state in (LaneChangeState.off, LaneChangeState.laneChangeStarting):\n      self.keep_pulse_timer = 0.0\n    elif self.lane_change_state == LaneChangeState.preLaneChange:\n      self.keep_pulse_timer += DT_MDL\n      if self.keep_pulse_timer > 1.0:\n        self.keep_pulse_timer = 0.0\n      elif self.desire in (log.Desire.keepLeft, log.Desire.keepRight):\n        self.desire = log.Desire.none", "target": "desire helper"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/longitudinal_mpc_lib/long_mpc.py:LongitudinalMpc:0", "source": "class CLASSTOKEN:\n  def __init__(self, mode='acc', dt=DT_MDL):\n    self.mode = mode\n    self.dt = dt\n    self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.reset()\n    self.source = SOURCES[2]\n\n  def reset(self):\n    # self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.solver.reset()\n    # self.solver.options_set('print_level', 2)\n    self.v_solution = np.zeros(N+1)\n    self.a_solution = np.zeros(N+1)\n    self.prev_a = np.array(self.a_solution)\n    self.j_solution = np.zeros(N)\n    self.yref = np.zeros((N+1, COST_DIM))\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n    self.x_sol = np.zeros((N+1, X_DIM))\n    self.u_sol = np.zeros((N,1))\n    self.params = np.zeros((N+1, PARAM_DIM))\n    for i in range(N+1):\n      self.solver.set(i, 'x', np.zeros(X_DIM))\n    self.last_cloudlog_t = 0\n    self.status = False\n    self.crash_cnt = 0.0\n    self.solution_status = 0\n    # timers\n    self.solve_time = 0.0\n    self.time_qp_solution = 0.0\n    self.time_linearization = 0.0\n    self.time_integrator = 0.0\n    self.x0 = np.zeros(X_DIM)\n    self.set_weights()\n\n  def set_cost_weights(self, cost_weights, constraint_cost_weights):\n    W = np.asfortranarray(np.diag(cost_weights))\n    for i in range(N):\n      # TODO don't hardcode A_CHANGE_COST idx\n      # reduce the cost on (a-a_prev) later in the horizon.\n      W[4,4] = cost_weights[4] * np.interp(T_IDXS[i], [0.0, 1.0, 2.0], [1.0, 1.0, 0.0])\n      self.solver.cost_set(i, 'W', W)\n    # Setting the slice without the copy make the array not contiguous,\n    # causing issues with the C interface.\n    self.solver.cost_set(N, 'W', np.copy(W[:COST_E_DIM, :COST_E_DIM]))\n\n    # Set L2 slack cost on lower bound constraints\n    Zl = np.array(constraint_cost_weights)\n    for i in range(N):\n      self.solver.cost_set(i, 'Zl', Zl)\n\n  def set_weights(self, prev_accel_constraint=True, personality=log.LongitudinalPersonality.standard):\n    jerk_factor = get_jerk_factor(personality)\n    if self.mode == 'acc':\n      a_change_cost = A_CHANGE_COST if prev_accel_constraint else 0\n      cost_weights = [X_EGO_OBSTACLE_COST, X_EGO_COST, V_EGO_COST, A_EGO_COST, jerk_factor * a_change_cost, jerk_factor * J_EGO_COST]\n      constraint_cost_weights = [LIMIT_COST, LIMIT_COST, LIMIT_COST, DANGER_ZONE_COST]\n    elif self.mode == 'blended':\n      a_change_cost = 40.0 if prev_accel_constraint else 0\n      cost_weights = [0., 0.1, 0.2, 5.0, a_change_cost, 1.0]\n      constraint_cost_weights = [LIMIT_COST, LIMIT_COST, LIMIT_COST, DANGER_ZONE_COST]\n    else:\n      raise NotImplementedError(f'Planner mode {self.mode} not recognized in planner cost set')\n    self.set_cost_weights(cost_weights, constraint_cost_weights)\n\n  def set_cur_state(self, v, a):\n    v_prev = self.x0[1]\n    self.x0[1] = v\n    self.x0[2] = a\n    if abs(v_prev - v) > 2.:  # probably only helps if v < v_prev\n      for i in range(N+1):\n        self.solver.set(i, 'x', self.x0)\n\n  @staticmethod\n  def extrapolate_lead(x_lead, v_lead, a_lead, a_lead_tau):\n    a_lead_traj = a_lead * np.exp(-a_lead_tau * (T_IDXS**2)/2.)\n    v_lead_traj = np.clip(v_lead + np.cumsum(T_DIFFS * a_lead_traj), 0.0, 1e8)\n    x_lead_traj = x_lead + np.cumsum(T_DIFFS * v_lead_traj)\n    lead_xv = np.column_stack((x_lead_traj, v_lead_traj))\n    return lead_xv\n\n  def process_lead(self, lead):\n    v_ego = self.x0[1]\n    if lead is not None and lead.status:\n      x_lead = lead.dRel\n      v_lead = lead.vLead\n      a_lead = lead.aLeadK\n      a_lead_tau = lead.aLeadTau\n    else:\n      # Fake a fast lead car, so mpc can keep running in the same mode\n      x_lead = 50.0\n      v_lead = v_ego + 10.0\n      a_lead = 0.0\n      a_lead_tau = _LEAD_ACCEL_TAU\n\n    # MPC will not converge if immediate crash is expected\n    # Clip lead distance to what is still possible to brake for\n    min_x_lead = ((v_ego + v_lead)/2) * (v_ego - v_lead) / (-ACCEL_MIN * 2)\n    x_lead = np.clip(x_lead, min_x_lead, 1e8)\n    v_lead = np.clip(v_lead, 0.0, 1e8)\n    a_lead = np.clip(a_lead, -10., 5.)\n    lead_xv = self.extrapolate_lead(x_lead, v_lead, a_lead, a_lead_tau)\n    return lead_xv\n\n  def update(self, radarstate, v_cruise, x, v, a, j, personality=log.LongitudinalPersonality.standard):\n    t_follow = get_T_FOLLOW(personality)\n    v_ego = self.x0[1]\n    self.status = radarstate.leadOne.status or radarstate.leadTwo.status\n\n    lead_xv_0 = self.process_lead(radarstate.leadOne)\n    lead_xv_1 = self.process_lead(radarstate.leadTwo)\n\n    # To estimate a safe distance from a moving lead, we calculate how much stopping\n    # distance that lead needs as a minimum. We can add that to the current distance\n    # and then treat that as a stopped car/obstacle at this new distance.\n    lead_0_obstacle = lead_xv_0[:,0] + get_stopped_equivalence_factor(lead_xv_0[:,1])\n    lead_1_obstacle = lead_xv_1[:,0] + get_stopped_equivalence_factor(lead_xv_1[:,1])\n\n    self.params[:,0] = ACCEL_MIN\n    self.params[:,1] = ACCEL_MAX\n\n    # Update in ACC mode or ACC/e2e blend\n    if self.mode == 'acc':\n      self.params[:,5] = LEAD_DANGER_FACTOR\n\n      # Fake an obstacle for cruise, this ensures smooth acceleration to set speed\n      # when the leads are no factor.\n      v_lower = v_ego + (T_IDXS * CRUISE_MIN_ACCEL * 1.05)\n      # TODO does this make sense when max_a is negative?\n      v_upper = v_ego + (T_IDXS * CRUISE_MAX_ACCEL * 1.05)\n      v_cruise_clipped = np.clip(v_cruise * np.ones(N+1),\n                                 v_lower,\n                                 v_upper)\n      cruise_obstacle = np.cumsum(T_DIFFS * v_cruise_clipped) + get_safe_obstacle_distance(v_cruise_clipped, t_follow)\n      x_obstacles = np.column_stack([lead_0_obstacle, lead_1_obstacle, cruise_obstacle])\n      self.source = SOURCES[np.argmin(x_obstacles[0])]\n\n      # These are not used in ACC mode\n      x[:], v[:], a[:], j[:] = 0.0, 0.0, 0.0, 0.0\n\n    elif self.mode == 'blended':\n      self.params[:,5] = 1.0\n\n      x_obstacles = np.column_stack([lead_0_obstacle,\n                                     lead_1_obstacle])\n      cruise_target = T_IDXS * np.clip(v_cruise, v_ego - 2.0, 1e3) + x[0]\n      xforward = ((v[1:] + v[:-1]) / 2) * (T_IDXS[1:] - T_IDXS[:-1])\n      x = np.cumsum(np.insert(xforward, 0, x[0]))\n\n      x_and_cruise = np.column_stack([x, cruise_target])\n      x = np.min(x_and_cruise, axis=1)\n\n      self.source = 'e2e' if x_and_cruise[1,0] < x_and_cruise[1,1] else 'cruise'\n\n    else:\n      raise NotImplementedError(f'Planner mode {self.mode} not recognized in planner update')\n\n    self.yref[:,1] = x\n    self.yref[:,2] = v\n    self.yref[:,3] = a\n    self.yref[:,5] = j\n    for i in range(N):\n      self.solver.set(i, \"yref\", self.yref[i])\n    self.solver.set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    self.params[:,2] = np.min(x_obstacles, axis=1)\n    self.params[:,3] = np.copy(self.prev_a)\n    self.params[:,4] = t_follow\n\n    self.run()\n    if (np.any(lead_xv_0[FCW_IDXS,0] - self.x_sol[FCW_IDXS,0] < CRASH_DISTANCE) and\n            radarstate.leadOne.modelProb > 0.9):\n      self.crash_cnt += 1\n    else:\n      self.crash_cnt = 0\n\n    # Check if it got within lead comfort range\n    # TODO This should be done cleaner\n    if self.mode == 'blended':\n      if any((lead_0_obstacle - get_safe_obstacle_distance(self.x_sol[:,1], t_follow))- self.x_sol[:,0] < 0.0):\n        self.source = 'lead0'\n      if any((lead_1_obstacle - get_safe_obstacle_distance(self.x_sol[:,1], t_follow))- self.x_sol[:,0] < 0.0) and \\\n         (lead_1_obstacle[0] - lead_0_obstacle[0]):\n        self.source = 'lead1'\n\n  def run(self):\n    # t0 = time.monotonic()\n    # reset = 0\n    for i in range(N+1):\n      self.solver.set(i, 'p', self.params[i])\n    self.solver.constraints_set(0, \"lbx\", self.x0)\n    self.solver.constraints_set(0, \"ubx\", self.x0)\n\n    self.solution_status = self.solver.solve()\n    self.solve_time = float(self.solver.get_stats('time_tot')[0])\n    self.time_qp_solution = float(self.solver.get_stats('time_qp')[0])\n    self.time_linearization = float(self.solver.get_stats('time_lin')[0])\n    self.time_integrator = float(self.solver.get_stats('time_sim')[0])\n\n    # qp_iter = self.solver.get_stats('statistics')[-1][-1] # SQP_RTI specific\n    # print(f\"long_mpc timings: tot {self.solve_time:.2e}, qp {self.time_qp_solution:.2e}, lin {self.time_linearization:.2e}, \\\n    # integrator {self.time_integrator:.2e}, qp_iter {qp_iter}\")\n    # res = self.solver.get_residuals()\n    # print(f\"long_mpc residuals: {res[0]:.2e}, {res[1]:.2e}, {res[2]:.2e}, {res[3]:.2e}\")\n    # self.solver.print_statistics()\n\n    for i in range(N+1):\n      self.x_sol[i] = self.solver.get(i, 'x')\n    for i in range(N):\n      self.u_sol[i] = self.solver.get(i, 'u')\n\n    self.v_solution = self.x_sol[:,1]\n    self.a_solution = self.x_sol[:,2]\n    self.j_solution = self.u_sol[:,0]\n\n    self.prev_a = np.interp(T_IDXS + self.dt, T_IDXS, self.a_solution)\n\n    t = time.monotonic()\n    if self.solution_status != 0:\n      if t > self.last_cloudlog_t + 5.0:\n        self.last_cloudlog_t = t\n        cloudlog.warning(f\"Long mpc reset, solution_status: {self.solution_status}\")\n      self.reset()", "target": "longitudinal mpc"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/lib/lateral_mpc_lib/lat_mpc.py:LateralMpc:0", "source": "class CLASSTOKEN:\n  def __init__(self, x0=None):\n    if x0 is None:\n      x0 = np.zeros(X_DIM)\n    self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.reset(x0)\n\n  def reset(self, x0=None):\n    if x0 is None:\n      x0 = np.zeros(X_DIM)\n    self.x_sol = np.zeros((N+1, X_DIM))\n    self.u_sol = np.zeros((N, 1))\n    self.yref = np.zeros((N+1, COST_DIM))\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    # Somehow needed for stable init\n    for i in range(N+1):\n      self.solver.set(i, 'x', np.zeros(X_DIM))\n      self.solver.set(i, 'p', np.zeros(P_DIM))\n    self.solver.constraints_set(0, \"lbx\", x0)\n    self.solver.constraints_set(0, \"ubx\", x0)\n    self.solver.solve()\n    self.solution_status = 0\n    self.solve_time = 0.0\n    self.cost = 0\n\n  def set_weights(self, path_weight, heading_weight,\n                  lat_accel_weight, lat_jerk_weight,\n                  steering_rate_weight):\n    W = np.asfortranarray(np.diag([path_weight, heading_weight,\n                                   lat_accel_weight, lat_jerk_weight,\n                                   steering_rate_weight]))\n    for i in range(N):\n      self.solver.cost_set(i, 'W', W)\n    self.solver.cost_set(N, 'W', W[:COST_E_DIM,:COST_E_DIM])\n\n  def run(self, x0, p, y_pts, heading_pts, yaw_rate_pts):\n    x0_cp = np.copy(x0)\n    p_cp = np.copy(p)\n    self.solver.constraints_set(0, \"lbx\", x0_cp)\n    self.solver.constraints_set(0, \"ubx\", x0_cp)\n    self.yref[:,0] = y_pts\n    v_ego = p_cp[0, 0]\n    # rotation_radius = p_cp[1]\n    self.yref[:,1] = heading_pts * (v_ego + SPEED_OFFSET)\n    self.yref[:,2] = yaw_rate_pts * (v_ego + SPEED_OFFSET)\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n      self.solver.set(i, \"p\", p_cp[i])\n    self.solver.set(N, \"p\", p_cp[N])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    t = time.monotonic()\n    self.solution_status = self.solver.solve()\n    self.solve_time = time.monotonic() - t\n\n    for i in range(N+1):\n      self.x_sol[i] = self.solver.get(i, 'x')\n    for i in range(N):\n      self.u_sol[i] = self.solver.get(i, 'u')\n    self.cost = self.solver.get_cost()", "target": "lateral mpc"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_latcontrol.py:TestLatControl:0", "source": "class CLASSTOKEN:\n\n  @parameterized.expand([(HONDA.HONDA_CIVIC, LatControlPID), (TOYOTA.TOYOTA_RAV4, LatControlTorque),\n                         (NISSAN.NISSAN_LEAF, LatControlAngle), (GM.CHEVROLET_BOLT_EUV, LatControlTorque)])\n  def test_saturation(self, car_name, controller):\n    CarInterface = interfaces[car_name]\n    CP = CarInterface.get_non_essential_params(car_name)\n    CI = CarInterface(CP)\n    VM = VehicleModel(CP)\n\n    controller = controller(CP.as_reader(), CI)\n\n    CS = car.CarState.new_message()\n    CS.vEgo = 30\n    CS.steeringPressed = False\n\n    params = log.LiveParametersData.new_message()\n\n    # Saturate for curvature limited and controller limited\n    for _ in range(1000):\n      _, _, lac_log = controller.update(True, CS, VM, params, False, 0, True)\n    assert lac_log.saturated\n\n    for _ in range(1000):\n      _, _, lac_log = controller.update(True, CS, VM, params, False, 0, False)\n    assert not lac_log.saturated\n\n    for _ in range(1000):\n      _, _, lac_log = controller.update(True, CS, VM, params, False, 1, False)\n    assert lac_log.saturated", "target": "test lat control"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_lateral_mpc.py:TestLateralMpc:0", "source": "class CLASSTOKEN:\n\n  def _assert_null(self, sol, curvature=1e-6):\n    for i in range(len(sol)):\n      assert sol[0,i,1] == pytest.approx(0, abs=curvature)\n      assert sol[0,i,2] == pytest.approx(0, abs=curvature)\n      assert sol[0,i,3] == pytest.approx(0, abs=curvature)\n\n  def _assert_simmetry(self, sol, curvature=1e-6):\n    for i in range(len(sol)):\n      assert sol[0,i,1] == pytest.approx(-sol[1,i,1], abs=curvature)\n      assert sol[0,i,2] == pytest.approx(-sol[1,i,2], abs=curvature)\n      assert sol[0,i,3] == pytest.approx(-sol[1,i,3], abs=curvature)\n      assert sol[0,i,0] == pytest.approx(sol[1,i,0], abs=curvature)\n\n  def test_straight(self):\n    sol = run_mpc()\n    self._assert_null(np.array([sol]))\n\n  def test_y_symmetry(self):\n    sol = []\n    for y_init in [-0.5, 0.5]:\n      sol.append(run_mpc(y_init=y_init))\n    self._assert_simmetry(np.array(sol))\n\n  def test_poly_symmetry(self):\n    sol = []\n    for poly_shift in [-1., 1.]:\n      sol.append(run_mpc(poly_shift=poly_shift))\n    self._assert_simmetry(np.array(sol))\n\n  def test_curvature_symmetry(self):\n    sol = []\n    for curvature_init in [-0.1, 0.1]:\n      sol.append(run_mpc(curvature_init=curvature_init))\n    self._assert_simmetry(np.array(sol))\n\n  def test_psi_symmetry(self):\n    sol = []\n    for psi_init in [-0.1, 0.1]:\n      sol.append(run_mpc(psi_init=psi_init))\n    self._assert_simmetry(np.array(sol))\n\n  def test_no_overshoot(self):\n    y_init = 1.\n    sol = run_mpc(y_init=y_init)\n    for y in list(sol[:,1]):\n      assert y_init >= abs(y)\n\n  def test_switch_convergence(self):\n    lat_mpc = LateralMpc()\n    sol = run_mpc(lat_mpc=lat_mpc, poly_shift=3.0, v_ref=7.0)\n    right_psi_deg = np.degrees(sol[:,2])\n    sol = run_mpc(lat_mpc=lat_mpc, poly_shift=-3.0, v_ref=7.0)\n    left_psi_deg = np.degrees(sol[:,2])\n    np.testing.assert_almost_equal(right_psi_deg, -left_psi_deg, decimal=3)", "target": "test lateral mpc"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_leads.py:TestLeads:0", "source": "class CLASSTOKEN:\n  def test_radar_fault(self):\n    # if there's no radar-related can traffic, radard should either not respond or respond with an error\n    # this is tightly coupled with underlying car radar_interface implementation, but it's a good sanity check\n    def single_iter_pkg():\n      # single iter package, with meaningless cans and empty carState/modelV2\n      msgs = []\n      for _ in range(500):\n        can = messaging.new_message(\"can\", 1)\n        cs = messaging.new_message(\"carState\")\n        cp = messaging.new_message(\"carParams\")\n        msgs.append(can.as_reader())\n        msgs.append(cs.as_reader())\n        msgs.append(cp.as_reader())\n      model = messaging.new_message(\"modelV2\")\n      msgs.append(model.as_reader())\n\n      return msgs\n\n    msgs = [m for _ in range(3) for m in single_iter_pkg()]\n    out = replay_process_with_name(\"card\", msgs, fingerprint=TOYOTA.TOYOTA_COROLLA_TSS2)\n    states = [m for m in out if m.which() == \"liveTracks\"]\n    failures = [not state.valid for state in states]\n\n    assert len(states) == 0 or all(failures)", "target": "test leads"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_longcontrol.py:TestLongControlStateTransition:0", "source": "class CLASSTOKEN:\n\n  def test_stay_stopped(self):\n    CP = car.CarParams.new_message()\n    active = True\n    current_state = LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=True, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=False, brake_pressed=True, cruise_standstill=False)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=False, brake_pressed=False, cruise_standstill=True)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=1.0,\n                             should_stop=False, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.pid\n    active = False\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=1.0,\n                             should_stop=False, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.off", "target": "test long control state transition"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_following_distance.py:TestFollowingDistance:0", "source": "class CLASSTOKEN:\n  def test_following_distance(self):\n    v_lead = float(self.speed)\n    simulation_steady_state = run_following_distance_simulation(v_lead, e2e=self.e2e, personality=self.personality)\n    correct_steady_state = desired_follow_distance(v_lead, v_lead, get_T_FOLLOW(self.personality))\n    err_ratio = 0.2 if self.e2e else 0.1\n    assert simulation_steady_state == pytest.approx(correct_steady_state, abs=err_ratio * correct_steady_state + .5)", "target": "test following distance"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/pandad/tests/test_pandad_spi.py:TestBoarddSpi:0", "source": "class CLASSTOKEN:\n  @classmethod\n  def setup_class(cls):\n    os.environ['STARTED'] = '1'\n    os.environ['SPI_ERR_PROB'] = '0.001'\n    if not JUNGLE_SPAM:\n      os.environ['BOARDD_LOOPBACK'] = '1'\n\n  @with_processes(['pandad'])\n  def test_spi_corruption(self, subtests):\n    setup_pandad(1)\n\n    sendcan = messaging.pub_sock('sendcan')\n    socks = {s: messaging.sub_sock(s, conflate=False, timeout=100) for s in ('can', 'pandaStates', 'peripheralState')}\n    time.sleep(2)\n    for s in socks.values():\n      messaging.drain_sock_raw(s)\n\n    total_recv_count = 0\n    total_sent_count = 0\n    sent_msgs = {bus: list() for bus in range(3)}\n\n    st = time.monotonic()\n    ts = {s: list() for s in socks.keys()}\n    for _ in range(int(os.getenv(\"TEST_TIME\", \"20\"))):\n      # send some CAN messages\n      if not JUNGLE_SPAM:\n        sent = send_random_can_messages(sendcan, random.randrange(2, 20))\n        for k, v in sent.items():\n          sent_msgs[k].extend(list(v))\n          total_sent_count += len(v)\n\n      for service, sock in socks.items():\n        for m in messaging.drain_sock(sock):\n          ts[service].append(m.logMonoTime)\n\n          # sanity check for corruption\n          assert m.valid or (service == \"can\")\n          if service == \"can\":\n            for msg in m.can:\n              if JUNGLE_SPAM:\n                # PandaJungle.set_generated_can(True)\n                i = msg.address - 0x200\n                assert msg.address >= 0x200\n                assert msg.src == (i%3)\n                assert msg.dat == b\"\\xff\"*(i%8)\n                total_recv_count += 1\n                continue\n\n              if msg.src > 4:\n                continue\n              key = (msg.address, msg.dat)\n              assert key in sent_msgs[msg.src], f\"got unexpected msg: {msg.src=} {msg.address=} {msg.dat=}\"\n              # TODO: enable this\n              #sent_msgs[msg.src].remove(key)\n              total_recv_count += 1\n          elif service == \"pandaStates\":\n            assert len(m.pandaStates) == 1\n            ps = m.pandaStates[0]\n            assert ps.uptime < 1000\n            assert ps.pandaType == \"tres\"\n            assert ps.ignitionLine\n            assert not ps.ignitionCan\n            assert 4000 < ps.voltage < 14000\n          elif service == \"peripheralState\":\n            ps = m.peripheralState\n            assert ps.pandaType == \"tres\"\n            assert 4000 < ps.voltage < 14000\n            assert 50 < ps.current < 1000\n            assert ps.fanSpeedRpm < 10000\n\n      time.sleep(0.5)\n    et = time.monotonic() - st\n\n    print(\"\\n======== timing report ========\")\n    for service, times in ts.items():\n      dts = np.diff(times)/1e6\n      print(service.ljust(17), f\"{np.mean(dts):7.2f} {np.min(dts):7.2f} {np.max(dts):7.2f}\")\n      with subtests.test(msg=\"timing check\", service=service):\n        edt = 1e3 / SERVICE_LIST[service].frequency\n        assert edt*0.9 < np.mean(dts) < edt*1.1\n        assert np.max(dts) < edt*8\n        assert np.min(dts) < edt\n        assert len(dts) >= ((et-0.5)*SERVICE_LIST[service].frequency*0.8)\n\n    with subtests.test(msg=\"CAN traffic\"):\n      print(f\"Sent {total_sent_count} CAN messages, got {total_recv_count} back. {total_recv_count/(total_sent_count+1e-4):.2%} received\")\n      assert total_recv_count > 20", "target": "test boardd spi"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/pandad/tests/test_pandad.py:TestPandad:0", "source": "class CLASSTOKEN:\n\n  def setup_method(self):\n    # ensure panda is up\n    if len(Panda.list()) == 0:\n      self._run_test(60)\n\n  def teardown_method(self):\n    managed_processes['pandad'].stop()\n\n  def _run_test(self, timeout=30) -> float:\n    st = time.monotonic()\n    sm = messaging.SubMaster(['pandaStates'])\n\n    managed_processes['pandad'].start()\n    while (time.monotonic() - st) < timeout:\n      sm.update(100)\n      if len(sm['pandaStates']) and sm['pandaStates'][0].pandaType != log.PandaState.PandaType.unknown:\n        break\n    dt = time.monotonic() - st\n    managed_processes['pandad'].stop()\n\n    if len(sm['pandaStates']) == 0 or sm['pandaStates'][0].pandaType == log.PandaState.PandaType.unknown:\n      raise Exception(\"pandad failed to start\")\n\n    return dt\n\n  def _go_to_dfu(self):\n    HARDWARE.recover_internal_panda()\n    assert Panda.wait_for_dfu(None, 10)\n\n  def _assert_no_panda(self):\n    assert not Panda.wait_for_dfu(None, 3)\n    assert not Panda.wait_for_panda(None, 3)\n\n  def _flash_bootstub(self, fn):\n    self._go_to_dfu()\n    pd = PandaDFU(None)\n    if fn is None:\n      fn = os.path.join(HERE, pd.get_mcu_type().config.bootstub_fn)\n    with open(fn, \"rb\") as f:\n      pd.program_bootstub(f.read())\n    pd.reset()\n    HARDWARE.reset_internal_panda()\n\n  def test_in_dfu(self):\n    HARDWARE.recover_internal_panda()\n    self._run_test(60)\n\n  def test_in_bootstub(self):\n    with Panda() as p:\n      p.reset(enter_bootstub=True)\n      assert p.bootstub\n    self._run_test()\n\n  def test_internal_panda_reset(self):\n    gpio_init(GPIO.STM_RST_N, True)\n    gpio_set(GPIO.STM_RST_N, 1)\n    time.sleep(0.5)\n    assert all(not Panda(s).is_internal() for s in Panda.list())\n    self._run_test()\n\n    assert any(Panda(s).is_internal() for s in Panda.list())\n\n  def test_best_case_startup_time(self):\n    # run once so we're up to date\n    self._run_test(60)\n\n    ts = []\n    for _ in range(10):\n      # should be nearly instant this time\n      dt = self._run_test(5)\n      ts.append(dt)\n\n    # 5s for USB (due to enumeration)\n    # - 0.2s pandad -> pandad\n    # - plus some buffer\n    print(\"startup times\", ts, sum(ts) / len(ts))\n    assert 0.1 < (sum(ts)/len(ts)) < 0.7\n\n  def test_old_spi_protocol(self):\n    # flash firmware with old SPI protocol\n    self._flash_bootstub(os.path.join(HERE, \"bootstub.panda_h7_spiv0.bin\"))\n    self._run_test(45)\n\n  def test_release_to_devel_bootstub(self):\n    self._flash_bootstub(None)\n    self._run_test(45)\n\n  def test_recover_from_bad_bootstub(self):\n    self._go_to_dfu()\n    with PandaDFU(None) as pd:\n      pd.program_bootstub(b\"\\x00\"*1024)\n      pd.reset()\n    HARDWARE.reset_internal_panda()\n    self._assert_no_panda()\n\n    self._run_test(60)", "target": "test pandad"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/pandad/tests/test_pandad_loopback.py:TestBoarddLoopback:0", "source": "class CLASSTOKEN:\n  @classmethod\n  def setup_class(cls):\n    os.environ['STARTED'] = '1'\n    os.environ['BOARDD_LOOPBACK'] = '1'\n\n  @with_processes(['pandad'])\n  def test_loopback(self):\n    num_pandas = 2 if TICI and \"SINGLE_PANDA\" not in os.environ else 1\n    setup_pandad(num_pandas)\n\n    sendcan = messaging.pub_sock('sendcan')\n    can = messaging.sub_sock('can', conflate=False, timeout=100)\n    sm = messaging.SubMaster(['pandaStates'])\n    time.sleep(1)\n\n    n = 200\n    for i in range(n):\n      print(f\"pandad loopback {i}/{n}\")\n\n      sent_msgs = send_random_can_messages(sendcan, random.randrange(20, 100), num_pandas)\n\n      sent_loopback = copy.deepcopy(sent_msgs)\n      sent_loopback.update({k+128: copy.deepcopy(v) for k, v in sent_msgs.items()})\n      sent_total = {k: len(v) for k, v in sent_loopback.items()}\n      for _ in range(100 * 5):\n        sm.update(0)\n        recvd = messaging.drain_sock(can, wait_for_one=True)\n        for msg in recvd:\n          for m in msg.can:\n            key = (m.address, m.dat)\n            assert key in sent_loopback[m.src], f\"got unexpected msg: {m.src=} {m.address=} {m.dat=}\"\n            sent_loopback[m.src].discard(key)\n\n        if all(len(v) == 0 for v in sent_loopback.values()):\n          break\n\n      # if a set isn't empty, messages got dropped\n      pprint(sent_msgs)\n      pprint(sent_loopback)\n      print({k: len(x) for k, x in sent_loopback.items()})\n      print(sum([len(x) for x in sent_loopback.values()]))\n      pprint(sm['pandaStates'])  # may drop messages due to RX buffer overflow\n      for bus in sent_loopback.keys():\n        assert not len(sent_loopback[bus]), f\"loop {i}: bus {bus} missing {len(sent_loopback[bus])} out of {sent_total[bus]} messages\"", "target": "test boardd loopback"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/paramsd.py:VehicleParamsLearner:0", "source": "class CLASSTOKEN:\n  def __init__(self, CP: car.CarParams, steer_ratio: float, stiffness_factor: float, angle_offset: float, P_initial: np.ndarray | None = None):\n    self.kf = CarKalman(GENERATED_DIR)\n\n    self.x_initial = CarKalman.initial_x.copy()\n    self.x_initial[States.STEER_RATIO] = steer_ratio\n    self.x_initial[States.STIFFNESS] = stiffness_factor\n    self.x_initial[States.ANGLE_OFFSET] = angle_offset\n    self.P_initial = P_initial if P_initial is not None else CarKalman.P_initial\n\n    self.kf.set_globals(\n      mass=CP.mass,\n      rotational_inertia=CP.rotationalInertia,\n      center_to_front=CP.centerToFront,\n      center_to_rear=CP.wheelbase - CP.centerToFront,\n      stiffness_front=CP.tireStiffnessFront,\n      stiffness_rear=CP.tireStiffnessRear\n    )\n\n    self.min_sr, self.max_sr = 0.5 * CP.steerRatio, 2.0 * CP.steerRatio\n\n    self.calibrator = PoseCalibrator()\n\n    self.observed_speed = 0.0\n    self.observed_yaw_rate = 0.0\n    self.observed_roll = 0.0\n\n    self.avg_offset_valid = True\n    self.total_offset_valid = True\n    self.roll_valid = True\n\n    self.reset(None)\n\n  def reset(self, t: float | None):\n    self.kf.init_state(self.x_initial, covs=self.P_initial, filter_time=t)\n\n    self.angle_offset, self.roll, self.active = np.degrees(self.x_initial[States.ANGLE_OFFSET].item()), 0.0, False\n    self.avg_angle_offset = self.angle_offset\n\n  def handle_log(self, t: float, which: str, msg: capnp._DynamicStructReader):\n    if which == 'livePose':\n      device_pose = Pose.from_live_pose(msg)\n      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n\n      yaw_rate, yaw_rate_std = calibrated_pose.angular_velocity.z, calibrated_pose.angular_velocity.z_std\n      yaw_rate_valid = msg.angularVelocityDevice.valid\n      yaw_rate_valid = yaw_rate_valid and 0 < yaw_rate_std < 10  # rad/s\n      yaw_rate_valid = yaw_rate_valid and abs(yaw_rate) < 1  # rad/s\n      if not yaw_rate_valid:\n        # This is done to bound the yaw rate estimate when localizer values are invalid or calibrating\n        yaw_rate, yaw_rate_std = 0.0, np.radians(10.0)\n      self.observed_yaw_rate = yaw_rate\n\n      localizer_roll, localizer_roll_std = device_pose.orientation.x, device_pose.orientation.x_std\n      localizer_roll_std = np.radians(1) if np.isnan(localizer_roll_std) else localizer_roll_std\n      roll_valid = (localizer_roll_std < ROLL_STD_MAX) and (ROLL_MIN < localizer_roll < ROLL_MAX) and msg.sensorsOK\n      if roll_valid:\n        roll = localizer_roll\n        # Experimentally found multiplier of 2 to be best trade-off between stability and accuracy or similar?\n        roll_std = 2 * localizer_roll_std\n      else:\n        # This is done to bound the road roll estimate when localizer values are invalid\n        roll = 0.0\n        roll_std = np.radians(10.0)\n      self.observed_roll = np.clip(roll, self.observed_roll - ROLL_MAX_DELTA, self.observed_roll + ROLL_MAX_DELTA)\n\n      if self.active:\n        if msg.posenetOK:\n          self.kf.predict_and_observe(t,\n                                      ObservationKind.ROAD_FRAME_YAW_RATE,\n                                      np.array([[-self.observed_yaw_rate]]),\n                                      np.array([np.atleast_2d(yaw_rate_std**2)]))\n\n          self.kf.predict_and_observe(t,\n                                      ObservationKind.ROAD_ROLL,\n                                      np.array([[self.observed_roll]]),\n                                      np.array([np.atleast_2d(roll_std**2)]))\n        self.kf.predict_and_observe(t, ObservationKind.ANGLE_OFFSET_FAST, np.array([[0]]))\n\n        # We observe the current stiffness and steer ratio (with a high observation noise) to bound\n        # the respective estimate STD. Otherwise the STDs keep increasing, causing rapid changes in the\n        # states in longer routes (especially straight stretches).\n        stiffness = float(self.kf.x[States.STIFFNESS].item())\n        steer_ratio = float(self.kf.x[States.STEER_RATIO].item())\n        self.kf.predict_and_observe(t, ObservationKind.STIFFNESS, np.array([[stiffness]]))\n        self.kf.predict_and_observe(t, ObservationKind.STEER_RATIO, np.array([[steer_ratio]]))\n\n    elif which == 'liveCalibration':\n      self.calibrator.feed_live_calib(msg)\n\n    elif which == 'carState':\n      steering_angle = msg.steeringAngleDeg\n\n      in_linear_region = abs(steering_angle) < 45\n      self.observed_speed = msg.vEgo\n      self.active = self.observed_speed > MIN_ACTIVE_SPEED and in_linear_region\n\n      if self.active:\n        self.kf.predict_and_observe(t, ObservationKind.STEER_ANGLE, np.array([[np.radians(steering_angle)]]))\n        self.kf.predict_and_observe(t, ObservationKind.ROAD_FRAME_X_SPEED, np.array([[self.observed_speed]]))\n\n    if not self.active:\n      # Reset time when stopped so uncertainty doesn't grow\n      self.kf.filter.set_filter_time(t)  # type: ignore\n      self.kf.filter.reset_rewind()      # type: ignore\n\n  def get_msg(self, valid: bool, debug: bool = False) -> capnp._DynamicStructBuilder:\n    x = self.kf.x\n    P = np.sqrt(self.kf.P.diagonal())\n    if not np.all(np.isfinite(x)):\n      cloudlog.error(\"NaN in liveParameters estimate. Resetting to default values\")\n      self.reset(self.kf.t)\n      x = self.kf.x\n\n    self.avg_angle_offset = np.clip(np.degrees(x[States.ANGLE_OFFSET].item()),\n                                self.avg_angle_offset - MAX_ANGLE_OFFSET_DELTA, self.avg_angle_offset + MAX_ANGLE_OFFSET_DELTA)\n    self.angle_offset = np.clip(np.degrees(x[States.ANGLE_OFFSET].item() + x[States.ANGLE_OFFSET_FAST].item()),\n                        self.angle_offset - MAX_ANGLE_OFFSET_DELTA, self.angle_offset + MAX_ANGLE_OFFSET_DELTA)\n    self.roll = np.clip(float(x[States.ROAD_ROLL].item()), self.roll - ROLL_MAX_DELTA, self.roll + ROLL_MAX_DELTA)\n    roll_std = float(P[States.ROAD_ROLL].item())\n    if self.active and self.observed_speed > LOW_ACTIVE_SPEED:\n      # Account for the opposite signs of the yaw rates\n      # At low speeds, bumping into a curb can cause the yaw rate to be very high\n      sensors_valid = bool(abs(self.observed_speed * (x[States.YAW_RATE].item() + self.observed_yaw_rate)) < LATERAL_ACC_SENSOR_THRESHOLD)\n    else:\n      sensors_valid = True\n    self.avg_offset_valid = check_valid_with_hysteresis(self.avg_offset_valid, self.avg_angle_offset, OFFSET_MAX, OFFSET_LOWERED_MAX)\n    self.total_offset_valid = check_valid_with_hysteresis(self.total_offset_valid, self.angle_offset, OFFSET_MAX, OFFSET_LOWERED_MAX)\n    self.roll_valid = check_valid_with_hysteresis(self.roll_valid, self.roll, ROLL_MAX, ROLL_LOWERED_MAX)\n\n    msg = messaging.new_message('liveParameters')\n\n    msg.valid = valid\n\n    liveParameters = msg.liveParameters\n    liveParameters.posenetValid = True\n    liveParameters.sensorValid = sensors_valid\n    liveParameters.steerRatio = float(x[States.STEER_RATIO].item())\n    liveParameters.stiffnessFactor = float(x[States.STIFFNESS].item())\n    liveParameters.roll = float(self.roll)\n    liveParameters.angleOffsetAverageDeg = float(self.avg_angle_offset)\n    liveParameters.angleOffsetDeg = float(self.angle_offset)\n    liveParameters.steerRatioValid = self.min_sr <= liveParameters.steerRatio <= self.max_sr\n    liveParameters.stiffnessFactorValid = 0.2 <= liveParameters.stiffnessFactor <= 5.0\n    liveParameters.angleOffsetAverageValid = bool(self.avg_offset_valid)\n    liveParameters.angleOffsetValid = bool(self.total_offset_valid)\n    liveParameters.valid = all((\n      liveParameters.angleOffsetAverageValid,\n      liveParameters.angleOffsetValid ,\n      self.roll_valid,\n      roll_std < ROLL_STD_MAX,\n      liveParameters.stiffnessFactorValid,\n      liveParameters.steerRatioValid,\n    ))\n    liveParameters.steerRatioStd = float(P[States.STEER_RATIO].item())\n    liveParameters.stiffnessFactorStd = float(P[States.STIFFNESS].item())\n    liveParameters.angleOffsetAverageStd = float(P[States.ANGLE_OFFSET].item())\n    liveParameters.angleOffsetFastStd = float(P[States.ANGLE_OFFSET_FAST].item())\n    if debug:\n      liveParameters.debugFilterState = log.LiveParametersData.FilterState.new_message()\n      liveParameters.debugFilterState.value = x.tolist()\n      liveParameters.debugFilterState.std = P.tolist()\n\n    return msg", "target": "vehicle params learner"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/lagd.py:Points:0", "source": "class CLASSTOKEN:\n  def __init__(self, num_points: int):\n    self.times = deque[float]([0.0] * num_points, maxlen=num_points)\n    self.okay = deque[bool]([False] * num_points, maxlen=num_points)\n    self.desired = deque[float]([0.0] * num_points, maxlen=num_points)\n    self.actual = deque[float]([0.0] * num_points, maxlen=num_points)\n\n  @property\n  def num_points(self):\n    return len(self.desired)\n\n  @property\n  def num_okay(self):\n    return np.count_nonzero(self.okay)\n\n  def update(self, t: float, desired: float, actual: float, okay: bool):\n    self.times.append(t)\n    self.okay.append(okay)\n    self.desired.append(desired)\n    self.actual.append(actual)\n\n  def get(self) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)", "target": "points"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/lagd.py:BlockAverage:1", "source": "class CLASSTOKEN:\n  def __init__(self, num_blocks: int, block_size: int, valid_blocks: int, initial_value: float):\n    self.num_blocks = num_blocks\n    self.block_size = block_size\n    self.block_idx = valid_blocks % num_blocks\n    self.idx = 0\n\n    self.values = np.tile(initial_value, (num_blocks, 1))\n    self.valid_blocks = valid_blocks\n\n  def update(self, value: float):\n    self.values[self.block_idx] = (self.idx * self.values[self.block_idx] + value) / (self.idx + 1)\n    self.idx = (self.idx + 1) % self.block_size\n    if self.idx == 0:\n      self.block_idx = (self.block_idx + 1) % self.num_blocks\n      self.valid_blocks = min(self.valid_blocks + 1, self.num_blocks)\n\n  def get(self) -> tuple[float, float, float, float]:\n    valid_block_idx = [i for i in range(self.valid_blocks) if i != self.block_idx]\n    valid_and_current_idx = valid_block_idx + ([self.block_idx] if self.idx > 0 else [])\n\n    if len(valid_block_idx) > 0:\n      valid_mean = float(np.mean(self.values[valid_block_idx], axis=0).item())\n      valid_std = float(np.std(self.values[valid_block_idx], axis=0).item())\n    else:\n      valid_mean, valid_std = float('nan'), float('nan')\n\n    if len(valid_and_current_idx) > 0:\n      current_mean = float(np.mean(self.values[valid_and_current_idx], axis=0).item())\n      current_std = float(np.std(self.values[valid_and_current_idx], axis=0).item())\n    else:\n      current_mean, current_std = float('nan'), float('nan')\n\n    return valid_mean, valid_std, current_mean, current_std", "target": "block average"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/lagd.py:LateralLagEstimator:2", "source": "class CLASSTOKEN:\n  inputs = {\"carControl\", \"carState\", \"controlsState\", \"liveCalibration\", \"livePose\"}\n\n  def __init__(self, CP: car.CarParams, dt: float,\n               block_count: int = BLOCK_NUM, min_valid_block_count: int = BLOCK_NUM_NEEDED, block_size: int = BLOCK_SIZE,\n               window_sec: float = MOVING_WINDOW_SEC, okay_window_sec: float = MIN_OKAY_WINDOW_SEC, min_recovery_buffer_sec: float = MIN_RECOVERY_BUFFER_SEC,\n               min_vego: float = MIN_VEGO, min_yr: float = MIN_ABS_YAW_RATE, min_ncc: float = MIN_NCC,\n               max_lat_accel: float = MAX_LAT_ACCEL, max_lat_accel_diff: float = MAX_LAT_ACCEL_DIFF, min_confidence: float = MIN_CONFIDENCE):\n    self.dt = dt\n    self.window_sec = window_sec\n    self.okay_window_sec = okay_window_sec\n    self.min_recovery_buffer_sec = min_recovery_buffer_sec\n    self.initial_lag = CP.steerActuatorDelay + 0.2\n    self.block_size = block_size\n    self.block_count = block_count\n    self.min_valid_block_count = min_valid_block_count\n    self.min_vego = min_vego\n    self.min_yr = min_yr\n    self.min_ncc = min_ncc\n    self.min_confidence = min_confidence\n    self.max_lat_accel = max_lat_accel\n    self.max_lat_accel_diff = max_lat_accel_diff\n\n    self.t = 0.0\n    self.lat_active = False\n    self.steering_pressed = False\n    self.steering_saturated = False\n    self.desired_curvature = 0.0\n    self.v_ego = 0.0\n    self.yaw_rate = 0.0\n    self.yaw_rate_std = 0.0\n    self.pose_valid = False\n\n    self.last_lat_inactive_t = 0.0\n    self.last_steering_pressed_t = 0.0\n    self.last_steering_saturated_t = 0.0\n    self.last_pose_invalid_t = 0.0\n    self.last_estimate_t = 0.0\n\n    self.calibrator = PoseCalibrator()\n\n    self.reset(self.initial_lag, 0)\n\n  def reset(self, initial_lag: float, valid_blocks: int):\n    window_len = int(self.window_sec / self.dt)\n    self.points = Points(window_len)\n    self.block_avg = BlockAverage(self.block_count, self.block_size, valid_blocks, initial_lag)\n\n  def get_msg(self, valid: bool, debug: bool = False) -> capnp._DynamicStructBuilder:\n    msg = messaging.new_message('liveDelay')\n\n    msg.valid = valid\n\n    liveDelay = msg.liveDelay\n\n    valid_mean_lag, valid_std, current_mean_lag, current_std = self.block_avg.get()\n    if self.block_avg.valid_blocks >= self.min_valid_block_count and not np.isnan(valid_mean_lag) and not np.isnan(valid_std):\n      if valid_std > MAX_LAG_STD:\n        liveDelay.status = log.LiveDelayData.Status.invalid\n      else:\n        liveDelay.status = log.LiveDelayData.Status.estimated\n    else:\n      liveDelay.status = log.LiveDelayData.Status.unestimated\n\n    if liveDelay.status == log.LiveDelayData.Status.estimated:\n      liveDelay.lateralDelay = valid_mean_lag\n    else:\n      liveDelay.lateralDelay = self.initial_lag\n\n    if not np.isnan(current_mean_lag) and not np.isnan(current_std):\n      liveDelay.lateralDelayEstimate = current_mean_lag\n      liveDelay.lateralDelayEstimateStd = current_std\n    else:\n      liveDelay.lateralDelayEstimate = self.initial_lag\n      liveDelay.lateralDelayEstimateStd = 0.0\n\n    liveDelay.validBlocks = self.block_avg.valid_blocks\n    liveDelay.calPerc = min(100 * (self.block_avg.valid_blocks * self.block_size + self.block_avg.idx) //\n                            (self.min_valid_block_count * self.block_size), 100)\n    if debug:\n      liveDelay.points = self.block_avg.values.flatten().tolist()\n\n    return msg\n\n  def handle_log(self, t: float, which: str, msg: capnp._DynamicStructReader):\n    if which == \"carControl\":\n      self.lat_active = msg.latActive\n    elif which == \"carState\":\n      self.steering_pressed = msg.steeringPressed\n      self.v_ego = msg.vEgo\n    elif which == \"controlsState\":\n      self.steering_saturated = getattr(msg.lateralControlState, msg.lateralControlState.which()).saturated\n      self.desired_curvature = msg.desiredCurvature\n    elif which == \"liveCalibration\":\n      self.calibrator.feed_live_calib(msg)\n    elif which == \"livePose\":\n      device_pose = Pose.from_live_pose(msg)\n      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n      self.yaw_rate = calibrated_pose.angular_velocity.yaw\n      self.yaw_rate_std = calibrated_pose.angular_velocity.yaw_std\n      self.pose_valid = msg.angularVelocityDevice.valid and msg.posenetOK and msg.inputsOK\n    self.t = t\n\n  def points_enough(self):\n    return self.points.num_points >= int(self.okay_window_sec / self.dt)\n\n  def points_valid(self):\n    return self.points.num_okay >= int(self.okay_window_sec / self.dt)\n\n  def update_points(self):\n    la_desired = self.desired_curvature * self.v_ego * self.v_ego\n    la_actual_pose = self.yaw_rate * self.v_ego\n\n    fast = self.v_ego > self.min_vego\n    turning = np.abs(self.yaw_rate) >= self.min_yr\n    sensors_valid = self.pose_valid and np.abs(self.yaw_rate) < MAX_YAW_RATE_SANITY_CHECK and self.yaw_rate_std < MAX_YAW_RATE_SANITY_CHECK\n    la_valid = np.abs(la_actual_pose) <= self.max_lat_accel and np.abs(la_desired - la_actual_pose) <= self.max_lat_accel_diff\n    calib_valid = self.calibrator.calib_valid\n\n    if not self.lat_active:\n      self.last_lat_inactive_t = self.t\n    if self.steering_pressed:\n      self.last_steering_pressed_t = self.t\n    if self.steering_saturated:\n      self.last_steering_saturated_t = self.t\n    if not sensors_valid or not la_valid:\n      self.last_pose_invalid_t = self.t\n\n    has_recovered = all( # wait for recovery after !lat_active, steering_pressed, steering_saturated, !sensors/la_valid\n      self.t - last_t >= self.min_recovery_buffer_sec\n      for last_t in [self.last_lat_inactive_t, self.last_steering_pressed_t, self.last_steering_saturated_t, self.last_pose_invalid_t]\n    )\n    okay = self.lat_active and not self.steering_pressed and not self.steering_saturated and \\\n           fast and turning and has_recovered and calib_valid and sensors_valid and la_valid\n\n    self.points.update(self.t, la_desired, la_actual_pose, okay)\n\n  def update_estimate(self):\n    if not self.points_enough():\n      return\n\n    times, desired, actual, okay = self.points.get()\n    # check if there are any new valid data points since the last update\n    is_valid = self.points_valid()\n    if self.last_estimate_t != 0 and times[0] <= self.last_estimate_t:\n      new_values_start_idx = next(-i for i, t in enumerate(reversed(times)) if t <= self.last_estimate_t)\n      is_valid = is_valid and not (new_values_start_idx == 0 or not np.any(okay[new_values_start_idx:]))\n\n    delay, corr, confidence = self.actuator_delay(desired, actual, okay, self.dt, MAX_LAG)\n    if corr < self.min_ncc or confidence < self.min_confidence or not is_valid:\n      return\n\n    self.block_avg.update(delay)\n    self.last_estimate_t = self.t\n\n  @staticmethod\n  def actuator_delay(expected_sig: np.ndarray, actual_sig: np.ndarray, mask: np.ndarray, dt: float, max_lag: float) -> tuple[float, float, float]:\n    assert len(expected_sig) == len(actual_sig)\n    max_lag_samples = int(max_lag / dt)\n    padded_size = fft_next_good_size(len(expected_sig) + max_lag_samples)\n\n    ncc = masked_normalized_cross_correlation(expected_sig, actual_sig, mask, padded_size)\n\n    # only consider lags from 0 to max_lag\n    roi = np.s_[len(expected_sig) - 1: len(expected_sig) - 1 + max_lag_samples]\n    extended_roi = np.s_[roi.start - CORR_BORDER_OFFSET: roi.stop + CORR_BORDER_OFFSET]\n    roi_ncc = ncc[roi]\n    extended_roi_ncc = ncc[extended_roi]\n\n    max_corr_index = np.argmax(roi_ncc)\n    corr = roi_ncc[max_corr_index]\n    lag = parabolic_peak_interp(roi_ncc, max_corr_index) * dt\n\n    # to estimate lag confidence, gather all high-correlation candidates and see how spread they are\n    # if e.g. 0.8 and 0.4 are both viable, this is an ambiguous case\n    ncc_thresh = (roi_ncc.max() - roi_ncc.min()) * LAG_CANDIDATE_CORR_THRESHOLD + roi_ncc.min()\n    good_lag_candidate_mask = extended_roi_ncc >= ncc_thresh\n    good_lag_candidate_edges = np.diff(good_lag_candidate_mask.astype(int), prepend=0, append=0)\n    starts, ends = np.where(good_lag_candidate_edges == 1)[0], np.where(good_lag_candidate_edges == -1)[0] - 1\n    run_idx = np.searchsorted(starts, max_corr_index + CORR_BORDER_OFFSET, side='right') - 1\n    width = ends[run_idx] - starts[run_idx] + 1\n    confidence = np.clip(1 - width * dt, 0, 1)\n\n    return lag, corr, confidence", "target": "lateral lag estimator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/torqued.py:TorqueBuckets:0", "source": "class CLASSTOKEN(PointBuckets):\n  def add_point(self, x, y):\n    for bound_min, bound_max in self.x_bounds:\n      if (x >= bound_min) and (x < bound_max):\n        self.buckets[(bound_min, bound_max)].append([x, 1.0, y])\n        break", "target": "torque buckets"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/torqued.py:TorqueEstimator:1", "source": "class CLASSTOKEN(ParameterEstimator):\n  def __init__(self, CP, decimated=False, track_all_points=False):\n    self.hist_len = int(HISTORY / DT_MDL)\n    self.lag = 0.0\n    self.track_all_points = track_all_points  # for offline analysis, without max lateral accel or max steer torque filters\n    if decimated:\n      self.min_bucket_points = MIN_BUCKET_POINTS / 10\n      self.min_points_total = MIN_POINTS_TOTAL_QLOG\n      self.fit_points = FIT_POINTS_TOTAL_QLOG\n      self.factor_sanity = FACTOR_SANITY_QLOG\n      self.friction_sanity = FRICTION_SANITY_QLOG\n\n    else:\n      self.min_bucket_points = MIN_BUCKET_POINTS\n      self.min_points_total = MIN_POINTS_TOTAL\n      self.fit_points = FIT_POINTS_TOTAL\n      self.factor_sanity = FACTOR_SANITY\n      self.friction_sanity = FRICTION_SANITY\n\n    self.offline_friction = 0.0\n    self.offline_latAccelFactor = 0.0\n    self.resets = 0.0\n    self.use_params = CP.brand in ALLOWED_CARS and CP.lateralTuning.which() == 'torque'\n\n    if CP.lateralTuning.which() == 'torque':\n      self.offline_friction = CP.lateralTuning.torque.friction\n      self.offline_latAccelFactor = CP.lateralTuning.torque.latAccelFactor\n\n    self.calibrator = PoseCalibrator()\n\n    self.reset()\n\n    initial_params = {\n      'latAccelFactor': self.offline_latAccelFactor,\n      'latAccelOffset': 0.0,\n      'frictionCoefficient': self.offline_friction,\n      'points': []\n    }\n    self.decay = MIN_FILTER_DECAY\n    self.min_lataccel_factor = (1.0 - self.factor_sanity) * self.offline_latAccelFactor\n    self.max_lataccel_factor = (1.0 + self.factor_sanity) * self.offline_latAccelFactor\n    self.min_friction = (1.0 - self.friction_sanity) * self.offline_friction\n    self.max_friction = (1.0 + self.friction_sanity) * self.offline_friction\n\n    # try to restore cached params\n    params = Params()\n    params_cache = params.get(\"CarParamsPrevRoute\")\n    torque_cache = params.get(\"LiveTorqueParameters\")\n    if params_cache is not None and torque_cache is not None:\n      try:\n        with log.Event.from_bytes(torque_cache) as log_evt:\n          cache_ltp = log_evt.liveTorqueParameters\n        with car.CarParams.from_bytes(params_cache) as msg:\n          cache_CP = msg\n        if self.get_restore_key(cache_CP, cache_ltp.version) == self.get_restore_key(CP, VERSION):\n          if cache_ltp.liveValid:\n            initial_params = {\n              'latAccelFactor': cache_ltp.latAccelFactorFiltered,\n              'latAccelOffset': cache_ltp.latAccelOffsetFiltered,\n              'frictionCoefficient': cache_ltp.frictionCoefficientFiltered\n            }\n          initial_params['points'] = cache_ltp.points\n          self.decay = cache_ltp.decay\n          self.filtered_points.load_points(initial_params['points'])\n          cloudlog.info(\"restored torque params from cache\")\n      except Exception:\n        cloudlog.exception(\"failed to restore cached torque params\")\n        params.remove(\"LiveTorqueParameters\")\n\n    self.filtered_params = {}\n    for param in initial_params:\n      self.filtered_params[param] = FirstOrderFilter(initial_params[param], self.decay, DT_MDL)\n\n  @staticmethod\n  def get_restore_key(CP, version):\n    a, b = None, None\n    if CP.lateralTuning.which() == 'torque':\n      a = CP.lateralTuning.torque.friction\n      b = CP.lateralTuning.torque.latAccelFactor\n    return (CP.carFingerprint, CP.lateralTuning.which(), a, b, version)\n\n  def reset(self):\n    self.resets += 1.0\n    self.decay = MIN_FILTER_DECAY\n    self.raw_points = defaultdict(lambda: deque(maxlen=self.hist_len))\n    self.filtered_points = TorqueBuckets(x_bounds=STEER_BUCKET_BOUNDS,\n                                         min_points=self.min_bucket_points,\n                                         min_points_total=self.min_points_total,\n                                         points_per_bucket=POINTS_PER_BUCKET,\n                                         rowsize=3)\n    self.all_torque_points = []\n\n  def estimate_params(self):\n    points = self.filtered_points.get_points(self.fit_points)\n    # total least square solution as both x and y are noisy observations\n    # this is empirically the slope of the hysteresis parallelogram as opposed to the line through the diagonals\n    try:\n      _, _, v = np.linalg.svd(points, full_matrices=False)\n      slope, offset = -v.T[0:2, 2] / v.T[2, 2]\n      _, spread = np.matmul(points[:, [0, 2]], slope2rot(slope)).T\n      friction_coeff = np.std(spread) * FRICTION_FACTOR\n    except np.linalg.LinAlgError as e:\n      cloudlog.exception(f\"Error computing live torque params: {e}\")\n      slope = offset = friction_coeff = np.nan\n    return slope, offset, friction_coeff\n\n  def update_params(self, params):\n    self.decay = min(self.decay + DT_MDL, MAX_FILTER_DECAY)\n    for param, value in params.items():\n      self.filtered_params[param].update(value)\n      self.filtered_params[param].update_alpha(self.decay)\n\n  def handle_log(self, t, which, msg):\n    if which == \"carControl\":\n      self.raw_points[\"carControl_t\"].append(t + self.lag)\n      self.raw_points[\"lat_active\"].append(msg.latActive)\n    elif which == \"carOutput\":\n      self.raw_points[\"carOutput_t\"].append(t + self.lag)\n      self.raw_points[\"steer_torque\"].append(-msg.actuatorsOutput.torque)\n    elif which == \"carState\":\n      self.raw_points[\"carState_t\"].append(t + self.lag)\n      # TODO: check if high aEgo affects resulting lateral accel\n      self.raw_points[\"vego\"].append(msg.vEgo)\n      self.raw_points[\"steer_override\"].append(msg.steeringPressed)\n    elif which == \"liveCalibration\":\n      self.calibrator.feed_live_calib(msg)\n    elif which == \"liveDelay\":\n      self.lag = msg.lateralDelay\n    # calculate lateral accel from past steering torque\n    elif which == \"livePose\":\n      if len(self.raw_points['steer_torque']) == self.hist_len:\n        device_pose = Pose.from_live_pose(msg)\n        calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n        angular_velocity_calibrated = calibrated_pose.angular_velocity\n\n        yaw_rate = angular_velocity_calibrated.yaw\n        roll = device_pose.orientation.roll\n        # check lat active up to now (without lag compensation)\n        lat_active = np.interp(np.arange(t - MIN_ENGAGE_BUFFER, t + self.lag, DT_MDL),\n                               self.raw_points['carControl_t'], self.raw_points['lat_active']).astype(bool)\n        steer_override = np.interp(np.arange(t - MIN_ENGAGE_BUFFER, t + self.lag, DT_MDL),\n                                   self.raw_points['carState_t'], self.raw_points['steer_override']).astype(bool)\n        vego = np.interp(t, self.raw_points['carState_t'], self.raw_points['vego'])\n        steer = np.interp(t, self.raw_points['carOutput_t'], self.raw_points['steer_torque']).item()\n        lateral_acc = (vego * yaw_rate) - (np.sin(roll) * ACCELERATION_DUE_TO_GRAVITY).item()\n        if all(lat_active) and not any(steer_override) and (vego > MIN_VEL) and (abs(steer) > STEER_MIN_THRESHOLD):\n          if abs(lateral_acc) <= LAT_ACC_THRESHOLD:\n            self.filtered_points.add_point(steer, lateral_acc)\n\n          if self.track_all_points:\n            self.all_torque_points.append([steer, lateral_acc])\n\n  def get_msg(self, valid=True, with_points=False):\n    msg = messaging.new_message('liveTorqueParameters')\n    msg.valid = valid\n    liveTorqueParameters = msg.liveTorqueParameters\n    liveTorqueParameters.version = VERSION\n    liveTorqueParameters.useParams = self.use_params\n\n    # Calculate raw estimates when possible, only update filters when enough points are gathered\n    if self.filtered_points.is_calculable():\n      latAccelFactor, latAccelOffset, frictionCoeff = self.estimate_params()\n      liveTorqueParameters.latAccelFactorRaw = float(latAccelFactor)\n      liveTorqueParameters.latAccelOffsetRaw = float(latAccelOffset)\n      liveTorqueParameters.frictionCoefficientRaw = float(frictionCoeff)\n\n      if self.filtered_points.is_valid():\n        if any(val is None or np.isnan(val) for val in [latAccelFactor, latAccelOffset, frictionCoeff]):\n          cloudlog.exception(\"Live torque parameters are invalid.\")\n          liveTorqueParameters.liveValid = False\n          self.reset()\n        else:\n          liveTorqueParameters.liveValid = True\n          latAccelFactor = np.clip(latAccelFactor, self.min_lataccel_factor, self.max_lataccel_factor)\n          frictionCoeff = np.clip(frictionCoeff, self.min_friction, self.max_friction)\n          self.update_params({'latAccelFactor': latAccelFactor, 'latAccelOffset': latAccelOffset, 'frictionCoefficient': frictionCoeff})\n\n    if with_points:\n      liveTorqueParameters.points = self.filtered_points.get_points()[:, [0, 2]].tolist()\n\n    liveTorqueParameters.latAccelFactorFiltered = float(self.filtered_params['latAccelFactor'].x)\n    liveTorqueParameters.latAccelOffsetFiltered = float(self.filtered_params['latAccelOffset'].x)\n    liveTorqueParameters.frictionCoefficientFiltered = float(self.filtered_params['frictionCoefficient'].x)\n    liveTorqueParameters.totalBucketPoints = len(self.filtered_points)\n    liveTorqueParameters.calPerc = self.filtered_points.get_valid_percent()\n    liveTorqueParameters.decay = self.decay\n    liveTorqueParameters.maxResets = self.resets\n    return msg", "target": "torque estimator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/calibrationd.py:Calibrator:0", "source": "class CLASSTOKEN:\n  def __init__(self, param_put: bool = False):\n    self.param_put = param_put\n\n    self.not_car = False\n\n    # Read saved calibration\n    self.params = Params()\n    calibration_params = self.params.get(\"CalibrationParams\")\n    rpy_init = RPY_INIT\n    wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT\n    height = HEIGHT_INIT\n    valid_blocks = 0\n    self.cal_status = log.LiveCalibrationData.Status.uncalibrated\n\n    if param_put and calibration_params:\n      try:\n        with log.Event.from_bytes(calibration_params) as msg:\n          rpy_init = np.array(msg.liveCalibration.rpyCalib)\n          valid_blocks = msg.liveCalibration.validBlocks\n          wide_from_device_euler = np.array(msg.liveCalibration.wideFromDeviceEuler)\n          height = np.array(msg.liveCalibration.height)\n      except Exception:\n        cloudlog.exception(\"Error reading cached CalibrationParams\")\n\n    self.reset(rpy_init, valid_blocks, wide_from_device_euler, height)\n    self.update_status()\n\n  def reset(self, rpy_init: np.ndarray = RPY_INIT,\n                  valid_blocks: int = 0,\n                  wide_from_device_euler_init: np.ndarray = WIDE_FROM_DEVICE_EULER_INIT,\n                  height_init: np.ndarray = HEIGHT_INIT,\n                  smooth_from: np.ndarray = None) -> None:\n    if not np.isfinite(rpy_init).all():\n      self.rpy = RPY_INIT.copy()\n    else:\n      self.rpy = rpy_init.copy()\n\n    if not np.isfinite(height_init).all() or len(height_init) != 1:\n      self.height = HEIGHT_INIT.copy()\n    else:\n      self.height = height_init.copy()\n\n    if not np.isfinite(wide_from_device_euler_init).all() or len(wide_from_device_euler_init) != 3:\n      self.wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT.copy()\n    else:\n      self.wide_from_device_euler = wide_from_device_euler_init.copy()\n\n    if not np.isfinite(valid_blocks) or valid_blocks < 0:\n      self.valid_blocks = 0\n    else:\n      self.valid_blocks = valid_blocks\n\n    self.rpys = np.tile(self.rpy, (INPUTS_WANTED, 1))\n    self.wide_from_device_eulers = np.tile(self.wide_from_device_euler, (INPUTS_WANTED, 1))\n    self.heights = np.tile(self.height, (INPUTS_WANTED, 1))\n\n    self.idx = 0\n    self.block_idx = 0\n    self.v_ego = 0.0\n\n    if smooth_from is None:\n      self.old_rpy = RPY_INIT\n      self.old_rpy_weight = 0.0\n    else:\n      self.old_rpy = smooth_from\n      self.old_rpy_weight = 1.0\n\n  def get_valid_idxs(self) -> list[int]:\n    # exclude current block_idx from validity window\n    before_current = list(range(self.block_idx))\n    after_current = list(range(min(self.valid_blocks, self.block_idx + 1), self.valid_blocks))\n    return before_current + after_current\n\n  def update_status(self) -> None:\n    valid_idxs = self.get_valid_idxs()\n    if valid_idxs:\n      self.wide_from_device_euler = np.mean(self.wide_from_device_eulers[valid_idxs], axis=0)\n      self.height = np.mean(self.heights[valid_idxs], axis=0)\n      rpys = self.rpys[valid_idxs]\n      self.rpy = np.mean(rpys, axis=0)\n      max_rpy_calib = np.array(np.max(rpys, axis=0))\n      min_rpy_calib = np.array(np.min(rpys, axis=0))\n      self.calib_spread = np.abs(max_rpy_calib - min_rpy_calib)\n    else:\n      self.calib_spread = np.zeros(3)\n\n    if self.valid_blocks < INPUTS_NEEDED:\n      if self.cal_status == log.LiveCalibrationData.Status.recalibrating:\n        self.cal_status = log.LiveCalibrationData.Status.recalibrating\n      else:\n        self.cal_status = log.LiveCalibrationData.Status.uncalibrated\n    elif is_calibration_valid(self.rpy):\n      self.cal_status = log.LiveCalibrationData.Status.calibrated\n    else:\n      self.cal_status = log.LiveCalibrationData.Status.invalid\n\n    # If spread is too high, assume mounting was changed and reset to last block.\n    # Make the transition smooth. Abrupt transitions are not good for feedback loop through supercombo model.\n    # TODO: add height spread check with smooth transition too\n    spread_too_high = self.calib_spread[1] > MAX_ALLOWED_PITCH_SPREAD or self.calib_spread[2] > MAX_ALLOWED_YAW_SPREAD\n    if spread_too_high and self.cal_status == log.LiveCalibrationData.Status.calibrated:\n      self.reset(self.rpys[self.block_idx - 1], valid_blocks=1, smooth_from=self.rpy)\n      self.cal_status = log.LiveCalibrationData.Status.recalibrating\n\n    write_this_cycle = (self.idx == 0) and (self.block_idx % (INPUTS_WANTED//5) == 5)\n    if self.param_put and write_this_cycle:\n      self.params.put_nonblocking(\"CalibrationParams\", self.get_msg(True).to_bytes())\n\n  def handle_v_ego(self, v_ego: float) -> None:\n    self.v_ego = v_ego\n\n  def get_smooth_rpy(self) -> np.ndarray:\n    if self.old_rpy_weight > 0:\n      return self.old_rpy_weight * self.old_rpy + (1.0 - self.old_rpy_weight) * self.rpy\n    else:\n      return self.rpy\n\n  def handle_cam_odom(self, trans: list[float],\n                            rot: list[float],\n                            wide_from_device_euler: list[float],\n                            trans_std: list[float],\n                            road_transform_trans: list[float],\n                            road_transform_trans_std: list[float]) -> np.ndarray | None:\n    self.old_rpy_weight = max(0.0, self.old_rpy_weight - 1/SMOOTH_CYCLES)\n\n    straight_and_fast = ((self.v_ego > MIN_SPEED_FILTER) and (trans[0] > MIN_SPEED_FILTER) and (abs(rot[2]) < MAX_YAW_RATE_FILTER))\n    angle_std_threshold = MAX_VEL_ANGLE_STD\n    height_std_threshold = MAX_HEIGHT_STD\n    rpy_certain = np.arctan2(trans_std[1], trans[0]) < angle_std_threshold\n    if len(road_transform_trans_std) == 3:\n      height_certain = road_transform_trans_std[2] < height_std_threshold\n    else:\n      height_certain = True\n\n    certain_if_calib = (rpy_certain and height_certain) or (self.valid_blocks < INPUTS_NEEDED)\n    if not (straight_and_fast and certain_if_calib):\n      return None\n\n    observed_rpy = np.array([0,\n                             -np.arctan2(trans[2], trans[0]),\n                             np.arctan2(trans[1], trans[0])])\n    new_rpy = euler_from_rot(rot_from_euler(self.get_smooth_rpy()).dot(rot_from_euler(observed_rpy)))\n    new_rpy = sanity_clip(new_rpy)\n\n    if len(wide_from_device_euler) == 3:\n      new_wide_from_device_euler = np.array(wide_from_device_euler)\n    else:\n      new_wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT\n\n    if (len(road_transform_trans) == 3):\n      new_height = np.array([road_transform_trans[2]])\n    else:\n      new_height = HEIGHT_INIT\n\n    self.rpys[self.block_idx] = moving_avg_with_linear_decay(self.rpys[self.block_idx], new_rpy, self.idx, float(BLOCK_SIZE))\n    self.wide_from_device_eulers[self.block_idx] = moving_avg_with_linear_decay(self.wide_from_device_eulers[self.block_idx],\n                                                                                new_wide_from_device_euler, self.idx, float(BLOCK_SIZE))\n    self.heights[self.block_idx] = moving_avg_with_linear_decay(self.heights[self.block_idx], new_height, self.idx, float(BLOCK_SIZE))\n\n    self.idx = (self.idx + 1) % BLOCK_SIZE\n    if self.idx == 0:\n      self.block_idx += 1\n      self.valid_blocks = max(self.block_idx, self.valid_blocks)\n      self.block_idx = self.block_idx % INPUTS_WANTED\n\n    self.update_status()\n\n    return new_rpy\n\n  def get_msg(self, valid: bool) -> capnp.lib.capnp._DynamicStructBuilder:\n    smooth_rpy = self.get_smooth_rpy()\n\n    msg = messaging.new_message('liveCalibration')\n    msg.valid = valid\n\n    liveCalibration = msg.liveCalibration\n    liveCalibration.validBlocks = self.valid_blocks\n    liveCalibration.calStatus = self.cal_status\n    liveCalibration.calPerc = min(100 * (self.valid_blocks * BLOCK_SIZE + self.idx) // (INPUTS_NEEDED * BLOCK_SIZE), 100)\n    liveCalibration.rpyCalib = smooth_rpy.tolist()\n    liveCalibration.rpyCalibSpread = self.calib_spread.tolist()\n    liveCalibration.wideFromDeviceEuler = self.wide_from_device_euler.tolist()\n    liveCalibration.height = self.height.tolist()\n\n    if self.not_car:\n      liveCalibration.validBlocks = INPUTS_NEEDED\n      liveCalibration.calStatus = log.LiveCalibrationData.Status.calibrated\n      liveCalibration.calPerc = 100.\n      liveCalibration.rpyCalib = [0, 0, 0]\n      liveCalibration.rpyCalibSpread = self.calib_spread.tolist()\n\n    return msg\n\n  def send_data(self, pm: messaging.PubMaster, valid: bool) -> None:\n    pm.send('liveCalibration', self.get_msg(valid))", "target": "calibrator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/locationd.py:HandleLogResult:0", "source": "class CLASSTOKEN(Enum):\n  SUCCESS = 0\n  TIMING_INVALID = 1\n  INPUT_INVALID = 2\n  SENSOR_SOURCE_INVALID = 3", "target": "handle log result"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/locationd.py:LocationEstimator:1", "source": "class CLASSTOKEN:\n  def __init__(self, debug: bool):\n    self.kf = PoseKalman(GENERATED_DIR, MAX_FILTER_REWIND_TIME)\n\n    self.debug = debug\n\n    self.posenet_stds = np.array([POSENET_STD_INITIAL_VALUE] * (POSENET_STD_HIST_HALF * 2))\n    self.car_speed = 0.0\n    self.camodo_yawrate_distribution = np.array([0.0, 10.0])  # mean, std\n    self.device_from_calib = np.eye(3)\n\n    obs_kinds = [ObservationKind.PHONE_ACCEL, ObservationKind.PHONE_GYRO, ObservationKind.CAMERA_ODO_ROTATION, ObservationKind.CAMERA_ODO_TRANSLATION]\n    self.observations = {kind: np.zeros(3, dtype=np.float32) for kind in obs_kinds}\n    self.observation_errors = {kind: np.zeros(3, dtype=np.float32) for kind in obs_kinds}\n\n  def reset(self, t: float, x_initial: np.ndarray = PoseKalman.initial_x, P_initial: np.ndarray = PoseKalman.initial_P):\n    self.kf.init_state(x_initial, covs=P_initial, filter_time=t)\n\n  def _validate_sensor_source(self, source: log.SensorEventData.SensorSource):\n    # some segments have two IMUs, ignore the second one\n    return source != log.SensorEventData.SensorSource.bmx055\n\n  def _validate_sensor_time(self, sensor_time: float, t: float):\n    # ignore empty readings\n    if sensor_time == 0:\n      return False\n\n    # sensor time and log time should be close\n    sensor_time_invalid = abs(sensor_time - t) > MAX_SENSOR_TIME_DIFF\n    if sensor_time_invalid:\n      cloudlog.warning(\"Sensor reading ignored, sensor timestamp more than 100ms off from log time\")\n    return not sensor_time_invalid\n\n  def _validate_timestamp(self, t: float):\n    kf_t = self.kf.t\n    invalid = not np.isnan(kf_t) and (kf_t - t) > MAX_FILTER_REWIND_TIME\n    if invalid:\n      cloudlog.warning(\"Observation timestamp is older than the max rewind threshold of the filter\")\n    return not invalid\n\n  def _finite_check(self, t: float, new_x: np.ndarray, new_P: np.ndarray):\n    all_finite = np.isfinite(new_x).all() and np.isfinite(new_P).all()\n    if not all_finite:\n      cloudlog.error(\"Non-finite values detected, kalman reset\")\n      self.reset(t)\n\n  def handle_log(self, t: float, which: str, msg: capnp._DynamicStructReader) -> HandleLogResult:\n    new_x, new_P = None, None\n    if which == \"accelerometer\" and msg.which() == \"acceleration\":\n      sensor_time = msg.timestamp * 1e-9\n\n      if not self._validate_sensor_time(sensor_time, t) or not self._validate_timestamp(sensor_time):\n        return HandleLogResult.TIMING_INVALID\n\n      if not self._validate_sensor_source(msg.source):\n        return HandleLogResult.SENSOR_SOURCE_INVALID\n\n      v = msg.acceleration.v\n      meas = np.array([-v[2], -v[1], -v[0]])\n      if np.linalg.norm(meas) >= ACCEL_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      acc_res = self.kf.predict_and_observe(sensor_time, ObservationKind.PHONE_ACCEL, meas)\n      if acc_res is not None:\n        _, new_x, _, new_P, _, _, (acc_err,), _, _ = acc_res\n        self.observation_errors[ObservationKind.PHONE_ACCEL] = np.array(acc_err)\n        self.observations[ObservationKind.PHONE_ACCEL] = meas\n\n    elif which == \"gyroscope\" and msg.which() == \"gyroUncalibrated\":\n      sensor_time = msg.timestamp * 1e-9\n\n      if not self._validate_sensor_time(sensor_time, t) or not self._validate_timestamp(sensor_time):\n        return HandleLogResult.TIMING_INVALID\n\n      if not self._validate_sensor_source(msg.source):\n        return HandleLogResult.SENSOR_SOURCE_INVALID\n\n      v = msg.gyroUncalibrated.v\n      meas = np.array([-v[2], -v[1], -v[0]])\n\n      gyro_bias = self.kf.x[States.GYRO_BIAS]\n      gyro_camodo_yawrate_err = np.abs((meas[2] - gyro_bias[2]) - self.camodo_yawrate_distribution[0])\n      gyro_camodo_yawrate_err_threshold = YAWRATE_CROSS_ERR_CHECK_FACTOR * self.camodo_yawrate_distribution[1]\n      gyro_valid = gyro_camodo_yawrate_err < gyro_camodo_yawrate_err_threshold\n\n      if np.linalg.norm(meas) >= ROTATION_SANITY_CHECK or not gyro_valid:\n        return HandleLogResult.INPUT_INVALID\n\n      gyro_res = self.kf.predict_and_observe(sensor_time, ObservationKind.PHONE_GYRO, meas)\n      if gyro_res is not None:\n        _, new_x, _, new_P, _, _, (gyro_err,), _, _ = gyro_res\n        self.observation_errors[ObservationKind.PHONE_GYRO] = np.array(gyro_err)\n        self.observations[ObservationKind.PHONE_GYRO] = meas\n\n    elif which == \"carState\":\n      self.car_speed = abs(msg.vEgo)\n\n    elif which == \"liveCalibration\":\n      # Note that we use this message during calibration\n      if len(msg.rpyCalib) > 0:\n        calib = np.array(msg.rpyCalib)\n        if calib.min() < -CALIB_RPY_SANITY_CHECK or calib.max() > CALIB_RPY_SANITY_CHECK:\n          return HandleLogResult.INPUT_INVALID\n\n        self.device_from_calib = rot_from_euler(calib)\n\n    elif which == \"cameraOdometry\":\n      if not self._validate_timestamp(t):\n        return HandleLogResult.TIMING_INVALID\n\n      rot_device = np.matmul(self.device_from_calib, np.array(msg.rot))\n      trans_device = np.matmul(self.device_from_calib, np.array(msg.trans))\n\n      if np.linalg.norm(rot_device) > ROTATION_SANITY_CHECK or np.linalg.norm(trans_device) > TRANS_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      rot_calib_std = np.array(msg.rotStd)\n      trans_calib_std = np.array(msg.transStd)\n\n      if rot_calib_std.min() <= MIN_STD_SANITY_CHECK or trans_calib_std.min() <= MIN_STD_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      if np.linalg.norm(rot_calib_std) > 10 * ROTATION_SANITY_CHECK or np.linalg.norm(trans_calib_std) > 10 * TRANS_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      self.posenet_stds = np.roll(self.posenet_stds, -1)\n      self.posenet_stds[-1] = trans_calib_std[0]\n\n      # Multiply by N to avoid to high certainty in kalman filter because of temporally correlated noise\n      rot_calib_std *= 10\n      trans_calib_std *= 2\n\n      rot_device_std = rotate_std(self.device_from_calib, rot_calib_std)\n      trans_device_std = rotate_std(self.device_from_calib, trans_calib_std)\n      rot_device_noise = rot_device_std ** 2\n      trans_device_noise = trans_device_std ** 2\n\n      cam_odo_rot_res = self.kf.predict_and_observe(t, ObservationKind.CAMERA_ODO_ROTATION, rot_device, np.array([np.diag(rot_device_noise)]))\n      cam_odo_trans_res = self.kf.predict_and_observe(t, ObservationKind.CAMERA_ODO_TRANSLATION, trans_device, np.array([np.diag(trans_device_noise)]))\n      self.camodo_yawrate_distribution =  np.array([rot_device[2], rot_device_std[2]])\n      if cam_odo_rot_res is not None:\n        _, new_x, _, new_P, _, _, (cam_odo_rot_err,), _, _ = cam_odo_rot_res\n        self.observation_errors[ObservationKind.CAMERA_ODO_ROTATION] = np.array(cam_odo_rot_err)\n        self.observations[ObservationKind.CAMERA_ODO_ROTATION] = rot_device\n      if cam_odo_trans_res is not None:\n        _, new_x, _, new_P, _, _, (cam_odo_trans_err,), _, _ = cam_odo_trans_res\n        self.observation_errors[ObservationKind.CAMERA_ODO_TRANSLATION] = np.array(cam_odo_trans_err)\n        self.observations[ObservationKind.CAMERA_ODO_TRANSLATION] = trans_device\n\n    if new_x is not None and new_P is not None:\n      self._finite_check(t, new_x, new_P)\n    return HandleLogResult.SUCCESS\n\n  def get_msg(self, sensors_valid: bool, inputs_valid: bool, filter_valid: bool):\n    state, cov = self.kf.x, self.kf.P\n    std = np.sqrt(np.diag(cov))\n\n    orientation_ned, orientation_ned_std = state[States.NED_ORIENTATION], std[States.NED_ORIENTATION]\n    velocity_device, velocity_device_std = state[States.DEVICE_VELOCITY], std[States.DEVICE_VELOCITY]\n    angular_velocity_device, angular_velocity_device_std = state[States.ANGULAR_VELOCITY], std[States.ANGULAR_VELOCITY]\n    acceleration_device, acceleration_device_std = state[States.ACCELERATION], std[States.ACCELERATION]\n\n    msg = messaging.new_message(\"livePose\")\n    msg.valid = filter_valid\n\n    livePose = msg.livePose\n    init_xyz_measurement(livePose.orientationNED, orientation_ned, orientation_ned_std, filter_valid)\n    init_xyz_measurement(livePose.velocityDevice, velocity_device, velocity_device_std, filter_valid)\n    init_xyz_measurement(livePose.angularVelocityDevice, angular_velocity_device, angular_velocity_device_std, filter_valid)\n    init_xyz_measurement(livePose.accelerationDevice, acceleration_device, acceleration_device_std, filter_valid)\n    if self.debug:\n      livePose.debugFilterState.value = state.tolist()\n      livePose.debugFilterState.std = std.tolist()\n      livePose.debugFilterState.valid = filter_valid\n      livePose.debugFilterState.observations = [\n        {'kind': k, 'value': self.observations[k].tolist(), 'error': self.observation_errors[k].tolist()}\n        for k in self.observations.keys()\n      ]\n\n    old_mean = np.mean(self.posenet_stds[:POSENET_STD_HIST_HALF])\n    new_mean = np.mean(self.posenet_stds[POSENET_STD_HIST_HALF:])\n    std_spike = (new_mean / old_mean) > 4.0 and new_mean > 7.0\n\n    livePose.inputsOK = inputs_valid\n    livePose.posenetOK = not std_spike or self.car_speed <= 5.0\n    livePose.sensorsOK = sensors_valid\n\n    return msg", "target": "location estimator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:NPQueue:0", "source": "class CLASSTOKEN:\n  def __init__(self, maxlen: int, rowsize: int) -> None:\n    self.maxlen = maxlen\n    self.arr = np.empty((0, rowsize))\n\n  def __len__(self) -> int:\n    return len(self.arr)\n\n  def append(self, pt: list[float]) -> None:\n    if len(self.arr) < self.maxlen:\n      self.arr = np.append(self.arr, [pt], axis=0)\n    else:\n      self.arr[:-1] = self.arr[1:]\n      self.arr[-1] = pt", "target": "np queue"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:PointBuckets:1", "source": "class CLASSTOKEN:\n  def __init__(self, x_bounds: list[tuple[float, float]], min_points: list[float], min_points_total: int, points_per_bucket: int, rowsize: int) -> None:\n    self.x_bounds = x_bounds\n    self.buckets = {bounds: NPQueue(maxlen=points_per_bucket, rowsize=rowsize) for bounds in x_bounds}\n    self.buckets_min_points = dict(zip(x_bounds, min_points, strict=True))\n    self.min_points_total = min_points_total\n\n  def __len__(self) -> int:\n    return sum([len(v) for v in self.buckets.values()])\n\n  def is_valid(self) -> bool:\n    individual_buckets_valid = all(len(v) >= min_pts for v, min_pts in zip(self.buckets.values(), self.buckets_min_points.values(), strict=True))\n    total_points_valid = self.__len__() >= self.min_points_total\n    return individual_buckets_valid and total_points_valid\n\n  def get_valid_percent(self) -> int:\n    total_points_perc = min(self.__len__() / self.min_points_total * 100, 100)\n    individual_buckets_perc = min(min(len(v) / min_pts * 100 for v, min_pts in\n                                      zip(self.buckets.values(), self.buckets_min_points.values(), strict=True)), 100)\n    return int((total_points_perc + individual_buckets_perc) / 2)\n\n  def is_calculable(self) -> bool:\n    return all(len(v) > 0 for v in self.buckets.values())\n\n  def add_point(self, x: float, y: float) -> None:\n    raise NotImplementedError\n\n  def get_points(self, num_points: int = None) -> Any:\n    points = np.vstack([x.arr for x in self.buckets.values()])\n    if num_points is None:\n      return points\n    return points[np.random.choice(np.arange(len(points)), min(len(points), num_points), replace=False)]\n\n  def load_points(self, points: list[list[float]]) -> None:\n    for point in points:\n      self.add_point(*point)", "target": "point buckets"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:ParameterEstimator:2", "source": "class CLASSTOKEN:\n  \"\"\" Base class for parameter estimators \"\"\"\n  def reset(self) -> None:\n    raise NotImplementedError\n\n  def handle_log(self, t: int, which: str, msg: log.Event) -> None:\n    raise NotImplementedError\n\n  def get_msg(self, valid: bool, with_points: bool) -> log.Event:\n    raise NotImplementedError", "target": "parameter estimator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:Measurement:3", "source": "class CLASSTOKEN:\n  x, y, z = (property(lambda self: self.xyz[0]), property(lambda self: self.xyz[1]), property(lambda self: self.xyz[2]))\n  x_std, y_std, z_std = (property(lambda self: self.xyz_std[0]), property(lambda self: self.xyz_std[1]), property(lambda self: self.xyz_std[2]))\n  roll, pitch, yaw = x, y, z\n  roll_std, pitch_std, yaw_std = x_std, y_std, z_std\n\n  def __init__(self, xyz: np.ndarray, xyz_std: np.ndarray):\n    self.xyz: np.ndarray = xyz\n    self.xyz_std: np.ndarray = xyz_std\n\n  @classmethod\n  def from_measurement_xyz(cls, measurement: log.LivePose.XYZMeasurement) -> 'CLASSTOKEN':\n    return cls(\n      xyz=np.array([measurement.x, measurement.y, measurement.z]),\n      xyz_std=np.array([measurement.xStd, measurement.yStd, measurement.zStd])\n    )", "target": "measurement"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:Pose:4", "source": "class CLASSTOKEN:\n  def __init__(self, orientation: Measurement, velocity: Measurement, acceleration: Measurement, angular_velocity: Measurement):\n    self.orientation = orientation\n    self.velocity = velocity\n    self.acceleration = acceleration\n    self.angular_velocity = angular_velocity\n\n  @classmethod\n  def from_live_pose(cls, live_pose: log.LivePose) -> 'CLASSTOKEN':\n    return CLASSTOKEN(\n      orientation=Measurement.from_measurement_xyz(live_pose.orientationNED),\n      velocity=Measurement.from_measurement_xyz(live_pose.velocityDevice),\n      acceleration=Measurement.from_measurement_xyz(live_pose.accelerationDevice),\n      angular_velocity=Measurement.from_measurement_xyz(live_pose.angularVelocityDevice)\n    )", "target": "pose"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/helpers.py:PoseCalibrator:5", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.calib_valid = False\n    self.calib_from_device = np.eye(3)\n\n  def _transform_calib_from_device(self, meas: Measurement):\n    new_xyz = self.calib_from_device @ meas.xyz\n    new_xyz_std = rotate_std(self.calib_from_device, meas.xyz_std)\n    return Measurement(new_xyz, new_xyz_std)\n\n  def _ned_from_calib(self, orientation: Measurement):\n    ned_from_device = rot_from_euler(orientation.xyz)\n    ned_from_calib = ned_from_device @ self.calib_from_device.T\n    ned_from_calib_euler_meas = Measurement(euler_from_rot(ned_from_calib), np.full(3, np.nan))\n    return ned_from_calib_euler_meas\n\n  def build_calibrated_pose(self, pose: Pose) -> Pose:\n    ned_from_calib_euler = self._ned_from_calib(pose.orientation)\n    angular_velocity_calib = self._transform_calib_from_device(pose.angular_velocity)\n    acceleration_calib = self._transform_calib_from_device(pose.acceleration)\n    velocity_calib = self._transform_calib_from_device(pose.angular_velocity)\n\n    return Pose(ned_from_calib_euler, velocity_calib, acceleration_calib, angular_velocity_calib)\n\n  def feed_live_calib(self, live_calib: log.LiveCalibrationData):\n    calib_rpy = np.array(live_calib.rpyCalib)\n    device_from_calib = rot_from_euler(calib_rpy)\n    self.calib_from_device = device_from_calib.T\n    self.calib_valid = live_calib.calStatus == log.LiveCalibrationData.Status.calibrated", "target": "pose calibrator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/test/test_calibrationd.py:TestCalibrationd:0", "source": "class CLASSTOKEN:\n\n  def test_read_saved_params(self):\n    msg = messaging.new_message('liveCalibration')\n    msg.liveCalibration.validBlocks = random.randint(1, 10)\n    msg.liveCalibration.rpyCalib = [random.random() for _ in range(3)]\n    msg.liveCalibration.height = [random.random() for _ in range(1)]\n    Params().put(\"CalibrationParams\", msg.to_bytes())\n    c = Calibrator(param_put=True)\n\n    np.testing.assert_allclose(msg.liveCalibration.rpyCalib, c.rpy)\n    np.testing.assert_allclose(msg.liveCalibration.height, c.height)\n    assert msg.liveCalibration.validBlocks == c.valid_blocks\n\n\n  def test_calibration_basics(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED)\n    assert c.valid_blocks == INPUTS_WANTED\n    np.testing.assert_allclose(c.rpy, np.zeros(3))\n    np.testing.assert_allclose(c.height, HEIGHT_INIT)\n    c.reset()\n\n\n  def test_calibration_low_speed_reject(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED, cam_odo_speed=MIN_SPEED_FILTER - 1)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED, carstate_speed=MIN_SPEED_FILTER - 1)\n    assert c.valid_blocks == 0\n    np.testing.assert_allclose(c.rpy, np.zeros(3))\n    np.testing.assert_allclose(c.height, HEIGHT_INIT)\n\n\n  def test_calibration_yaw_rate_reject(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED, cam_odo_yr=MAX_YAW_RATE_FILTER)\n    assert c.valid_blocks == 0\n    np.testing.assert_allclose(c.rpy, np.zeros(3))\n    np.testing.assert_allclose(c.height, HEIGHT_INIT)\n\n\n  def test_calibration_speed_std_reject(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED, cam_odo_speed_std=1e3)\n    assert c.valid_blocks == INPUTS_NEEDED\n    np.testing.assert_allclose(c.rpy, np.zeros(3))\n\n\n  def test_calibration_speed_std_height_reject(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_WANTED, cam_odo_height_std=1e3)\n    assert c.valid_blocks == INPUTS_NEEDED\n    np.testing.assert_allclose(c.rpy, np.zeros(3))\n\n\n  def test_calibration_auto_reset(self):\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_NEEDED)\n    assert c.valid_blocks == INPUTS_NEEDED\n    np.testing.assert_allclose(c.rpy, [0.0, 0.0, 0.0], atol=1e-3)\n    process_messages(c, [0.0, MAX_ALLOWED_PITCH_SPREAD*0.9, MAX_ALLOWED_YAW_SPREAD*0.9], BLOCK_SIZE + 10)\n    assert c.valid_blocks == INPUTS_NEEDED + 1\n    assert c.cal_status == log.LiveCalibrationData.Status.calibrated\n\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_NEEDED)\n    assert c.valid_blocks == INPUTS_NEEDED\n    np.testing.assert_allclose(c.rpy, [0.0, 0.0, 0.0])\n    process_messages(c, [0.0, MAX_ALLOWED_PITCH_SPREAD*1.1, 0.0], BLOCK_SIZE + 10)\n    assert c.valid_blocks == 1\n    assert c.cal_status == log.LiveCalibrationData.Status.recalibrating\n    np.testing.assert_allclose(c.rpy, [0.0, MAX_ALLOWED_PITCH_SPREAD*1.1, 0.0], atol=1e-2)\n\n    c = Calibrator(param_put=False)\n    process_messages(c, [0.0, 0.0, 0.0], BLOCK_SIZE * INPUTS_NEEDED)\n    assert c.valid_blocks == INPUTS_NEEDED\n    np.testing.assert_allclose(c.rpy, [0.0, 0.0, 0.0])\n    process_messages(c, [0.0, 0.0, MAX_ALLOWED_YAW_SPREAD*1.1], BLOCK_SIZE + 10)\n    assert c.valid_blocks == 1\n    assert c.cal_status == log.LiveCalibrationData.Status.recalibrating\n    np.testing.assert_allclose(c.rpy, [0.0, 0.0, MAX_ALLOWED_YAW_SPREAD*1.1], atol=1e-2)", "target": "test calibrationd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/test/test_lagd.py:TestLagd:0", "source": "class CLASSTOKEN:\n  def test_read_saved_params(self):\n    params = Params()\n\n    lr = migrate(LogReader(TEST_ROUTE), [migrate_carParams])\n    CP = next(m for m in lr if m.which() == \"carParams\").carParams\n\n    msg = messaging.new_message('liveDelay')\n    msg.liveDelay.lateralDelayEstimate = random.random()\n    msg.liveDelay.validBlocks = random.randint(1, 10)\n    params.put(\"LiveDelay\", msg.to_bytes())\n    params.put(\"CarParamsPrevRoute\", CP.as_builder().to_bytes())\n\n    saved_lag_params = retrieve_initial_lag(params, CP)\n    assert saved_lag_params is not None\n\n    lag, valid_blocks = saved_lag_params\n    assert lag == msg.liveDelay.lateralDelayEstimate\n    assert valid_blocks == msg.liveDelay.validBlocks\n\n  def test_ncc(self):\n    lag_frames = random.randint(1, 19)\n\n    desired_sig = np.sin(np.arange(0.0, 10.0, 0.1))\n    actual_sig = np.sin(np.arange(0.0, 10.0, 0.1) - lag_frames * 0.1)\n    mask = np.ones(len(desired_sig), dtype=bool)\n\n    corr = masked_normalized_cross_correlation(desired_sig, actual_sig, mask, 200)[len(desired_sig) - 1:len(desired_sig) + 20]\n    assert np.argmax(corr) == lag_frames\n\n    # add some noise\n    desired_sig += np.random.normal(0, 0.05, len(desired_sig))\n    actual_sig += np.random.normal(0, 0.05, len(actual_sig))\n    corr = masked_normalized_cross_correlation(desired_sig, actual_sig, mask, 200)[len(desired_sig) - 1:len(desired_sig) + 20]\n    assert np.argmax(corr)  in range(lag_frames - MAX_ERR_FRAMES, lag_frames + MAX_ERR_FRAMES + 1)\n\n    # mask out 40% of the values, and make them noise\n    mask = np.random.choice([True, False], size=len(desired_sig), p=[0.6, 0.4])\n    desired_sig[~mask] = np.random.normal(0, 1, size=np.sum(~mask))\n    actual_sig[~mask] = np.random.normal(0, 1, size=np.sum(~mask))\n    corr = masked_normalized_cross_correlation(desired_sig, actual_sig, mask, 200)[len(desired_sig) - 1:len(desired_sig) + 20]\n    assert np.argmax(corr) in range(lag_frames - MAX_ERR_FRAMES, lag_frames + MAX_ERR_FRAMES + 1)\n\n  def test_empty_estimator(self):\n    mocked_CP = car.CarParams(steerActuatorDelay=0.8)\n    estimator = LateralLagEstimator(mocked_CP, DT)\n    msg = estimator.get_msg(True)\n    assert msg.liveDelay.status == 'unestimated'\n    assert np.allclose(msg.liveDelay.lateralDelay, estimator.initial_lag)\n    assert np.allclose(msg.liveDelay.lateralDelayEstimate, estimator.initial_lag)\n    assert msg.liveDelay.validBlocks == 0\n    assert msg.liveDelay.calPerc == 0\n\n  def test_estimator_basics(self, subtests):\n    for lag_frames in range(5):\n      with subtests.test(msg=f\"lag_frames={lag_frames}\"):\n        mocked_CP = car.CarParams(steerActuatorDelay=0.8)\n        estimator = LateralLagEstimator(mocked_CP, DT, min_recovery_buffer_sec=0.0, min_yr=0.0)\n        process_messages(estimator, lag_frames, int(MIN_OKAY_WINDOW_SEC / DT) + BLOCK_NUM_NEEDED * BLOCK_SIZE)\n        msg = estimator.get_msg(True)\n        assert msg.liveDelay.status == 'estimated'\n        assert np.allclose(msg.liveDelay.lateralDelay, lag_frames * DT, atol=0.01)\n        assert np.allclose(msg.liveDelay.lateralDelayEstimate, lag_frames * DT, atol=0.01)\n        assert np.allclose(msg.liveDelay.lateralDelayEstimateStd, 0.0, atol=0.01)\n        assert msg.liveDelay.validBlocks == BLOCK_NUM_NEEDED\n        assert msg.liveDelay.calPerc == 100\n\n  def test_estimator_masking(self):\n    mocked_CP, lag_frames = car.CarParams(steerActuatorDelay=0.8), random.randint(1, 19)\n    estimator = LateralLagEstimator(mocked_CP, DT, min_recovery_buffer_sec=0.0, min_yr=0.0, min_valid_block_count=1)\n    process_messages(estimator, lag_frames, (int(MIN_OKAY_WINDOW_SEC / DT) + BLOCK_SIZE) * 2, rejection_threshold=0.4)\n    msg = estimator.get_msg(True)\n    assert np.allclose(msg.liveDelay.lateralDelayEstimate, lag_frames * DT, atol=0.01)\n    assert np.allclose(msg.liveDelay.lateralDelayEstimateStd, 0.0, atol=0.01)\n    assert msg.liveDelay.calPerc == 100\n\n  @pytest.mark.skipif(PC, reason=\"only on device\")\n  @pytest.mark.timeout(60)\n  def test_estimator_performance(self):\n    mocked_CP = car.CarParams(steerActuatorDelay=0.8)\n    estimator = LateralLagEstimator(mocked_CP, DT)\n\n    ds = []\n    for _ in range(1000):\n      st = time.perf_counter()\n      estimator.update_points()\n      estimator.update_estimate()\n      d = time.perf_counter() - st\n      ds.append(d)\n\n    assert np.mean(ds) < DT", "target": "test lagd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/test/test_paramsd.py:TestParamsd:0", "source": "class CLASSTOKEN:\n  def test_read_saved_params(self):\n    params = Params()\n\n    lr = migrate(LogReader(TEST_ROUTE), [migrate_carParams])\n    CP = next(m for m in lr if m.which() == \"carParams\").carParams\n\n    msg = get_random_live_parameters(CP)\n    params.put(\"LiveParametersV2\", msg.to_bytes())\n    params.put(\"CarParamsPrevRoute\", CP.as_builder().to_bytes())\n\n    migrate_cached_vehicle_params_if_needed(params) # this is not tested here but should not mess anything up or throw an error\n    sr, sf, offset, p_init = retrieve_initial_vehicle_params(params, CP, replay=True, debug=True)\n    np.testing.assert_allclose(sr, msg.liveParameters.steerRatio)\n    np.testing.assert_allclose(sf, msg.liveParameters.stiffnessFactor)\n    np.testing.assert_allclose(offset, msg.liveParameters.angleOffsetAverageDeg)\n    np.testing.assert_equal(p_init.shape, CarKalman.P_initial.shape)\n    np.testing.assert_allclose(np.diagonal(p_init), msg.liveParameters.debugFilterState.std)\n\n  # TODO Remove this test after the support for old format is removed\n  def test_read_saved_params_old_format(self):\n    params = Params()\n\n    lr = migrate(LogReader(TEST_ROUTE), [migrate_carParams])\n    CP = next(m for m in lr if m.which() == \"carParams\").carParams\n\n    msg = get_random_live_parameters(CP)\n    params.put(\"LiveParameters\", msg.liveParameters.to_dict())\n    params.put(\"CarParamsPrevRoute\", CP.as_builder().to_bytes())\n    params.remove(\"LiveParametersV2\")\n\n    migrate_cached_vehicle_params_if_needed(params)\n    sr, sf, offset, _ = retrieve_initial_vehicle_params(params, CP, replay=True, debug=True)\n    np.testing.assert_allclose(sr, msg.liveParameters.steerRatio)\n    np.testing.assert_allclose(sf, msg.liveParameters.stiffnessFactor)\n    np.testing.assert_allclose(offset, msg.liveParameters.angleOffsetAverageDeg)\n    assert params.get(\"LiveParametersV2\") is not None\n\n  def test_read_saved_params_corrupted_old_format(self):\n    params = Params()\n    params.put(\"LiveParameters\", {})\n    params.remove(\"LiveParametersV2\")\n\n    migrate_cached_vehicle_params_if_needed(params)\n    assert params.get(\"LiveParameters\") is None\n    assert params.get(\"LiveParametersV2\") is None", "target": "test paramsd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/test/test_locationd_scenarios.py:Scenario:0", "source": "class CLASSTOKEN(Enum):\n  BASE = 'base'\n  GYRO_OFF = 'gyro_off'\n  GYRO_SPIKE_MIDWAY = 'gyro_spike_midway'\n  GYRO_CONSISTENT_SPIKES = 'gyro_consistent_spikes'\n  ACCEL_OFF = 'accel_off'\n  ACCEL_SPIKE_MIDWAY = 'accel_spike_midway'\n  ACCEL_CONSISTENT_SPIKES = 'accel_consistent_spikes'\n  SENSOR_TIMING_SPIKE_MIDWAY = 'timing_spikes'\n  SENSOR_TIMING_CONSISTENT_SPIKES = 'timing_consistent_spikes'", "target": "scenario"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/test/test_locationd_scenarios.py:TestLocationdScenarios:1", "source": "class CLASSTOKEN:\n  \"\"\"\n  Test locationd with different scenarios. In all these scenarios, we expect the following:\n    - locationd kalman filter should never go unstable (we care mostly about yaw_rate, roll, gpsOK, inputsOK, sensorsOK)\n    - faulty values should be ignored, with appropriate flags set\n  \"\"\"\n\n  @classmethod\n  def setup_class(cls):\n    cls.logs = migrate_all(LogReader(TEST_ROUTE))\n\n  def test_base(self):\n    \"\"\"\n    Test: unchanged log\n    Expected Result:\n      - yaw_rate: unchanged\n      - roll: unchanged\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.BASE, self.logs)\n    assert np.allclose(orig_data['yaw_rate'], replayed_data['yaw_rate'], atol=np.radians(0.35))\n    assert np.allclose(orig_data['roll'], replayed_data['roll'], atol=np.radians(0.55))\n\n  def test_gyro_off(self):\n    \"\"\"\n    Test: no gyroscope message for the entire segment\n    Expected Result:\n      - yaw_rate: 0\n      - roll: 0\n      - sensorsOK: False\n    \"\"\"\n    _, replayed_data = run_scenarios(Scenario.GYRO_OFF, self.logs)\n    assert np.allclose(replayed_data['yaw_rate'], 0.0)\n    assert np.allclose(replayed_data['roll'], 0.0)\n    assert np.all(replayed_data['sensors_flag'] == 0.0)\n\n  def test_gyro_spike(self):\n    \"\"\"\n    Test: a gyroscope spike in the middle of the segment\n    Expected Result:\n      - yaw_rate: unchanged\n      - roll: unchanged\n      - inputsOK: False for some time after the spike, True for the rest\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.GYRO_SPIKE_MIDWAY, self.logs)\n    assert np.allclose(orig_data['yaw_rate'], replayed_data['yaw_rate'], atol=np.radians(0.35))\n    assert np.allclose(orig_data['roll'], replayed_data['roll'], atol=np.radians(0.55))\n    assert np.all(replayed_data['inputs_flag'] == orig_data['inputs_flag'])\n    assert np.all(replayed_data['sensors_flag'] == orig_data['sensors_flag'])\n\n  def test_consistent_gyro_spikes(self):\n    \"\"\"\n    Test: consistent timing spikes for N gyroscope messages in the middle of the segment\n    Expected Result: inputsOK becomes False after N of bad measurements\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.GYRO_CONSISTENT_SPIKES, self.logs)\n    assert np.diff(replayed_data['inputs_flag'])[501] == -1.0\n    assert np.diff(replayed_data['inputs_flag'])[708] == 1.0\n\n  def test_accel_off(self):\n    \"\"\"\n    Test: no accelerometer message for the entire segment\n    Expected Result:\n      - yaw_rate: 0\n      - roll: 0\n      - sensorsOK: False\n    \"\"\"\n    _, replayed_data = run_scenarios(Scenario.ACCEL_OFF, self.logs)\n    assert np.allclose(replayed_data['yaw_rate'], 0.0)\n    assert np.allclose(replayed_data['roll'], 0.0)\n    assert np.all(replayed_data['sensors_flag'] == 0.0)\n\n  def test_accel_spike(self):\n    \"\"\"\n    ToDo:\n    Test: an accelerometer spike in the middle of the segment\n    Expected Result: Right now, the kalman filter is not robust to small spikes like it is to gyroscope spikes.\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.ACCEL_SPIKE_MIDWAY, self.logs)\n    assert np.allclose(orig_data['yaw_rate'], replayed_data['yaw_rate'], atol=np.radians(0.35))\n    assert np.allclose(orig_data['roll'], replayed_data['roll'], atol=np.radians(0.55))\n\n  def test_single_timing_spike(self):\n    \"\"\"\n    Test: timing of 150ms off for the single accelerometer message in the middle of the segment\n    Expected Result: the message is ignored, and inputsOK is False for that time\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.SENSOR_TIMING_SPIKE_MIDWAY, self.logs)\n    assert np.all(replayed_data['inputs_flag'] == orig_data['inputs_flag'])\n    assert np.all(replayed_data['sensors_flag'] == orig_data['sensors_flag'])\n\n  def test_consistent_timing_spikes(self):\n    \"\"\"\n    Test: consistent timing spikes for N accelerometer messages in the middle of the segment\n    Expected Result: inputsOK becomes False after N of bad measurements\n    \"\"\"\n    orig_data, replayed_data = run_scenarios(Scenario.SENSOR_TIMING_CONSISTENT_SPIKES, self.logs)\n    assert np.diff(replayed_data['inputs_flag'])[501] == -1.0\n    assert np.diff(replayed_data['inputs_flag'])[707] == 1.0", "target": "test locationd scenarios"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/pose_kf.py:States:0", "source": "class CLASSTOKEN:\n  NED_ORIENTATION = slice(0, 3)  # roll, pitch, yaw in rad\n  DEVICE_VELOCITY = slice(3, 6)  # ned velocity in m/s\n  ANGULAR_VELOCITY = slice(6, 9)  # roll, pitch and yaw rates in rad/s\n  GYRO_BIAS = slice(9, 12)  # roll, pitch and yaw gyroscope biases in rad/s\n  ACCELERATION = slice(12, 15)  # acceleration in device frame in m/s**2\n  ACCEL_BIAS = slice(15, 18)  # Acceletometer bias in m/s**2", "target": "states"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/pose_kf.py:PoseKalman:1", "source": "class CLASSTOKEN(KalmanFilter):\n  name = \"pose\"\n\n  # state\n  initial_x = np.array([0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0])\n  # state covariance\n  initial_P = np.diag([0.01**2, 0.01**2, 0.01**2,\n                       10**2, 10**2, 10**2,\n                       1**2, 1**2, 1**2,\n                       1**2, 1**2, 1**2,\n                       100**2, 100**2, 100**2,\n                       0.01**2, 0.01**2, 0.01**2])\n\n  # process noise\n  Q = np.diag([0.001**2, 0.001**2, 0.001**2,\n               0.01**2, 0.01**2, 0.01**2,\n               0.1**2, 0.1**2, 0.1**2,\n               (0.005 / 100)**2, (0.005 / 100)**2, (0.005 / 100)**2,\n               3**2, 3**2, 3**2,\n               0.005**2, 0.005**2, 0.005**2])\n\n  obs_noise = {ObservationKind.PHONE_GYRO: np.diag([0.025**2, 0.025**2, 0.025**2]),\n               ObservationKind.PHONE_ACCEL: np.diag([.5**2, .5**2, .5**2]),\n               ObservationKind.CAMERA_ODO_TRANSLATION: np.diag([0.5**2, 0.5**2, 0.5**2]),\n               ObservationKind.CAMERA_ODO_ROTATION: np.diag([0.05**2, 0.05**2, 0.05**2])}\n\n  @staticmethod\n  def generate_code(generated_dir):\n    name = CLASSTOKEN.name\n    dim_state = CLASSTOKEN.initial_x.shape[0]\n    dim_state_err = CLASSTOKEN.initial_P.shape[0]\n\n    state_sym = sp.MatrixSymbol('state', dim_state, 1)\n    state = sp.Matrix(state_sym)\n    roll, pitch, yaw = state[States.NED_ORIENTATION, :]\n    velocity = state[States.DEVICE_VELOCITY, :]\n    angular_velocity = state[States.ANGULAR_VELOCITY, :]\n    vroll, vpitch, vyaw = angular_velocity\n    gyro_bias = state[States.GYRO_BIAS, :]\n    acceleration = state[States.ACCELERATION, :]\n    acc_bias = state[States.ACCEL_BIAS, :]\n\n    dt = sp.Symbol('dt')\n\n    ned_from_device = euler_rotate(roll, pitch, yaw)\n    device_from_ned = ned_from_device.T\n\n    state_dot = sp.Matrix(np.zeros((dim_state, 1)))\n    state_dot[States.DEVICE_VELOCITY, :] = acceleration\n\n    f_sym = state + dt * state_dot\n    device_from_device_t1 = euler_rotate(dt*vroll, dt*vpitch, dt*vyaw)\n    ned_from_device_t1 = ned_from_device * device_from_device_t1\n    f_sym[States.NED_ORIENTATION, :] = rot_to_euler(ned_from_device_t1)\n\n    centripetal_acceleration = angular_velocity.cross(velocity)\n    gravity = sp.Matrix([0, 0, -EARTH_G])\n    h_gyro_sym = angular_velocity + gyro_bias\n    h_acc_sym = device_from_ned * gravity + acceleration + centripetal_acceleration + acc_bias\n    h_phone_rot_sym = angular_velocity\n    h_relative_motion_sym = velocity\n    obs_eqs = [\n      [h_gyro_sym, ObservationKind.PHONE_GYRO, None],\n      [h_acc_sym, ObservationKind.PHONE_ACCEL, None],\n      [h_relative_motion_sym, ObservationKind.CAMERA_ODO_TRANSLATION, None],\n      [h_phone_rot_sym, ObservationKind.CAMERA_ODO_ROTATION, None],\n    ]\n    gen_code(generated_dir, name, f_sym, dt, state_sym, obs_eqs, dim_state, dim_state_err)\n\n  def __init__(self, generated_dir, max_rewind_age):\n    dim_state, dim_state_err = CLASSTOKEN.initial_x.shape[0], CLASSTOKEN.initial_P.shape[0]\n    self.filter = EKF_sym_pyx(generated_dir, self.name, CLASSTOKEN.Q, CLASSTOKEN.initial_x, CLASSTOKEN.initial_P,\n                              dim_state, dim_state_err, max_rewind_age=max_rewind_age)", "target": "pose kalman"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/constants.py:ObservationKind:0", "source": "class CLASSTOKEN:\n  UNKNOWN = 0\n  NO_OBSERVATION = 1\n  GPS_NED = 2\n  ODOMETRIC_SPEED = 3\n  PHONE_GYRO = 4\n  GPS_VEL = 5\n  PSEUDORANGE_GPS = 6\n  PSEUDORANGE_RATE_GPS = 7\n  SPEED = 8\n  NO_ROT = 9\n  PHONE_ACCEL = 10\n  ORB_POINT = 11\n  ECEF_POS = 12\n  CAMERA_ODO_TRANSLATION = 13\n  CAMERA_ODO_ROTATION = 14\n  ORB_FEATURES = 15\n  MSCKF_TEST = 16\n  FEATURE_TRACK_TEST = 17\n  LANE_PT = 18\n  IMU_FRAME = 19\n  PSEUDORANGE_GLONASS = 20\n  PSEUDORANGE_RATE_GLONASS = 21\n  PSEUDORANGE = 22\n  PSEUDORANGE_RATE = 23\n  ECEF_VEL = 35\n  ECEF_ORIENTATION_FROM_GPS = 32\n  NO_ACCEL = 33\n  ORB_FEATURES_WIDE = 34\n\n  ROAD_FRAME_XY_SPEED = 24  # (x, y) [m/s]\n  ROAD_FRAME_YAW_RATE = 25  # [rad/s]\n  STEER_ANGLE = 26  # [rad]\n  ANGLE_OFFSET_FAST = 27  # [rad]\n  STIFFNESS = 28  # [-]\n  STEER_RATIO = 29  # [-]\n  ROAD_FRAME_X_SPEED = 30  # (x) [m/s]\n  ROAD_ROLL = 31  # [rad]\n\n  names = [\n    'Unknown',\n    'No observation',\n    'GPS NED',\n    'Odometric speed',\n    'Phone gyro',\n    'GPS velocity',\n    'GPS pseudorange',\n    'GPS pseudorange rate',\n    'Speed',\n    'No rotation',\n    'Phone acceleration',\n    'ORB point',\n    'ECEF pos',\n    'camera odometric translation',\n    'camera odometric rotation',\n    'ORB features',\n    'MSCKF test',\n    'Feature track test',\n    'Lane ecef point',\n    'imu frame eulers',\n    'GLONASS pseudorange',\n    'GLONASS pseudorange rate',\n    'pseudorange',\n    'pseudorange rate',\n\n    'Road Frame x,y speed',\n    'Road Frame yaw rate',\n    'Steer Angle',\n    'Fast Angle Offset',\n    'Stiffness',\n    'Steer Ratio',\n    'Road Frame x speed',\n    'Road Roll',\n    'ECEF orientation from GPS',\n    'NO accel',\n    'ORB features wide camera',\n    'ECEF_VEL',\n  ]\n\n  @classmethod\n  def to_string(cls, kind):\n    return cls.names[kind]", "target": "observation kind"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/car_kf.py:States:0", "source": "class CLASSTOKEN:\n  # Vehicle model params\n  STIFFNESS = _slice(1)  # [-]\n  STEER_RATIO = _slice(1)  # [-]\n  ANGLE_OFFSET = _slice(1)  # [rad]\n  ANGLE_OFFSET_FAST = _slice(1)  # [rad]\n\n  VELOCITY = _slice(2)  # (x, y) [m/s]\n  YAW_RATE = _slice(1)  # [rad/s]\n  STEER_ANGLE = _slice(1)  # [rad]\n  ROAD_ROLL = _slice(1)  # [rad]", "target": "states"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/models/car_kf.py:CarKalman:1", "source": "class CLASSTOKEN(KalmanFilter):\n  name = 'car'\n\n  initial_x = np.array([\n    1.0,\n    15.0,\n    0.0,\n    0.0,\n\n    10.0, 0.0,\n    0.0,\n    0.0,\n    0.0\n  ])\n\n  # process noise\n  Q = np.diag([\n    (.05 / 100)**2,\n    .01**2,\n    math.radians(0.02)**2,\n    math.radians(0.25)**2,\n\n    .1**2, .01**2,\n    math.radians(0.1)**2,\n    math.radians(0.1)**2,\n    math.radians(1)**2,\n  ])\n  P_initial = Q.copy()\n\n  obs_noise: dict[int, Any] = {\n    ObservationKind.STEER_ANGLE: np.atleast_2d(math.radians(0.05)**2),\n    ObservationKind.ANGLE_OFFSET_FAST: np.atleast_2d(math.radians(10.0)**2),\n    ObservationKind.ROAD_ROLL: np.atleast_2d(math.radians(1.0)**2),\n    ObservationKind.STEER_RATIO: np.atleast_2d(5.0**2),\n    ObservationKind.STIFFNESS: np.atleast_2d(0.5**2),\n    ObservationKind.ROAD_FRAME_X_SPEED: np.atleast_2d(0.1**2),\n  }\n\n  global_vars = [\n    'mass',\n    'rotational_inertia',\n    'center_to_front',\n    'center_to_rear',\n    'stiffness_front',\n    'stiffness_rear',\n  ]\n\n  @staticmethod\n  def generate_code(generated_dir):\n    dim_state = CLASSTOKEN.initial_x.shape[0]\n    name = CLASSTOKEN.name\n\n    # Linearized single-track lateral dynamics, equations 7.211-7.213\n    # Massimo Guiggiani, The Science of Vehicle Dynamics: Handling, Braking, and Ride of Road and Race Cars\n    # Springer Cham, 2023. doi: https://doi.org/10.1007/978-3-031-06461-6\n\n    # globals\n    global_vars = [sp.Symbol(name) for name in CLASSTOKEN.global_vars]\n    m, j, aF, aR, cF_orig, cR_orig = global_vars\n\n    # make functions and jacobians with sympy\n    # state variables\n    state_sym = sp.MatrixSymbol('state', dim_state, 1)\n    state = sp.Matrix(state_sym)\n\n    # Vehicle model constants\n    sf = state[States.STIFFNESS, :][0, 0]\n\n    cF, cR = sf * cF_orig, sf * cR_orig\n    angle_offset = state[States.ANGLE_OFFSET, :][0, 0]\n    angle_offset_fast = state[States.ANGLE_OFFSET_FAST, :][0, 0]\n    theta = state[States.ROAD_ROLL, :][0, 0]\n    sa = state[States.STEER_ANGLE, :][0, 0]\n\n    sR = state[States.STEER_RATIO, :][0, 0]\n    u, v = state[States.VELOCITY, :]\n    r = state[States.YAW_RATE, :][0, 0]\n\n    A = sp.Matrix(np.zeros((2, 2)))\n    A[0, 0] = -(cF + cR) / (m * u)\n    A[0, 1] = -(cF * aF - cR * aR) / (m * u) - u\n    A[1, 0] = -(cF * aF - cR * aR) / (j * u)\n    A[1, 1] = -(cF * aF**2 + cR * aR**2) / (j * u)\n\n    B = sp.Matrix(np.zeros((2, 1)))\n    B[0, 0] = cF / m / sR\n    B[1, 0] = (cF * aF) / j / sR\n\n    C = sp.Matrix(np.zeros((2, 1)))\n    C[0, 0] = ACCELERATION_DUE_TO_GRAVITY\n    C[1, 0] = 0\n\n    x = sp.Matrix([v, r])  # lateral velocity, yaw rate\n    x_dot = A * x + B * (sa - angle_offset - angle_offset_fast) - C * theta\n\n    dt = sp.Symbol('dt')\n    state_dot = sp.Matrix(np.zeros((dim_state, 1)))\n    state_dot[States.VELOCITY.start + 1, 0] = x_dot[0]\n    state_dot[States.YAW_RATE.start, 0] = x_dot[1]\n\n    # Basic descretization, 1st order integrator\n    # Can be pretty bad if dt is big\n    f_sym = state + dt * state_dot\n\n    #\n    # Observation functions\n    #\n    obs_eqs = [\n      [sp.Matrix([r]), ObservationKind.ROAD_FRAME_YAW_RATE, None],\n      [sp.Matrix([u, v]), ObservationKind.ROAD_FRAME_XY_SPEED, None],\n      [sp.Matrix([u]), ObservationKind.ROAD_FRAME_X_SPEED, None],\n      [sp.Matrix([sa]), ObservationKind.STEER_ANGLE, None],\n      [sp.Matrix([angle_offset_fast]), ObservationKind.ANGLE_OFFSET_FAST, None],\n      [sp.Matrix([sR]), ObservationKind.STEER_RATIO, None],\n      [sp.Matrix([sf]), ObservationKind.STIFFNESS, None],\n      [sp.Matrix([theta]), ObservationKind.ROAD_ROLL, None],\n    ]\n\n    gen_code(generated_dir, name, f_sym, dt, state_sym, obs_eqs, dim_state, dim_state, global_vars=global_vars)\n\n  def __init__(self, generated_dir):\n    dim_state, dim_state_err = CLASSTOKEN.initial_x.shape[0], CLASSTOKEN.P_initial.shape[0]\n    self.filter = EKF_sym_pyx(generated_dir, CLASSTOKEN.name, CLASSTOKEN.Q, CLASSTOKEN.initial_x, CLASSTOKEN.P_initial,\n                              dim_state, dim_state_err, global_vars=CLASSTOKEN.global_vars, logger=cloudlog)\n\n  def set_globals(self, mass, rotational_inertia, center_to_front, center_to_rear, stiffness_front, stiffness_rear):\n    self.filter.set_global(\"mass\", mass)\n    self.filter.set_global(\"rotational_inertia\", rotational_inertia)\n    self.filter.set_global(\"center_to_front\", center_to_front)\n    self.filter.set_global(\"center_to_rear\", center_to_rear)\n    self.filter.set_global(\"stiffness_front\", stiffness_front)\n    self.filter.set_global(\"stiffness_rear\", stiffness_rear)", "target": "car kalman"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/car_specific.py:MockCarState:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.sm = messaging.SubMaster(['gpsLocation', 'gpsLocationExternal'])\n\n  def update(self, CS: car.CarState):\n    self.sm.update(0)\n    gps_sock = 'gpsLocationExternal' if self.sm.recv_frame['gpsLocationExternal'] > 1 else 'gpsLocation'\n\n    CS.vEgo = self.sm[gps_sock].speed\n    CS.vEgoRaw = self.sm[gps_sock].speed\n\n    return CS", "target": "mock car state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/car_specific.py:CarSpecificEvents:1", "source": "class CLASSTOKEN:\n  def __init__(self, CP: structs.CarParams):\n    self.CP = CP\n\n    self.steering_unpressed = 0\n    self.low_speed_alert = False\n    self.no_steer_warning = False\n    self.silent_steer_warning = True\n\n  def update(self, CS: car.CarState, CS_prev: car.CarState, CC: car.CarControl):\n    if self.CP.brand in ('body', 'mock'):\n      events = Events()\n\n    elif self.CP.brand == 'ford':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.low, GearShifter.manumatic])\n\n    elif self.CP.brand == 'nissan':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.brake])\n\n    elif self.CP.brand == 'chrysler':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.low])\n\n      # Low speed steer alert hysteresis logic\n      if self.CP.minSteerSpeed > 0. and CS.vEgo < (self.CP.minSteerSpeed + 0.5):\n        self.low_speed_alert = True\n      elif CS.vEgo > (self.CP.minSteerSpeed + 1.):\n        self.low_speed_alert = False\n      if self.low_speed_alert:\n        events.add(EventName.belowSteerSpeed)\n\n    elif self.CP.brand == 'honda':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.sport], pcm_enable=False)\n\n      if self.CP.pcmCruise and CS.vEgo < self.CP.minEnableSpeed:\n        events.add(EventName.belowEngageSpeed)\n\n      if self.CP.pcmCruise:\n        # we engage when pcm is active (rising edge)\n        if CS.cruiseState.enabled and not CS_prev.cruiseState.enabled:\n          events.add(EventName.pcmEnable)\n        elif not CS.cruiseState.enabled and (CC.actuators.accel >= 0. or not self.CP.openpilotLongitudinalControl):\n          # it can happen that car cruise disables while comma system is enabled: need to\n          # keep braking if needed or if the speed is very low\n          if CS.vEgo < self.CP.minEnableSpeed + 2.:\n            # non loud alert if cruise disables below 25mph as expected (+ a little margin)\n            events.add(EventName.speedTooLow)\n          else:\n            events.add(EventName.cruiseDisabled)\n      if self.CP.minEnableSpeed > 0 and CS.vEgo < 0.001:\n        events.add(EventName.manualRestart)\n\n    elif self.CP.brand == 'toyota':\n      # TODO: when we check for unexpected disengagement, check gear not S1, S2, S3\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.sport])\n\n      if self.CP.openpilotLongitudinalControl:\n        if CS.cruiseState.standstill and not CS.brakePressed:\n          events.add(EventName.resumeRequired)\n        if CS.vEgo < self.CP.minEnableSpeed:\n          events.add(EventName.belowEngageSpeed)\n          if CC.actuators.accel > 0.3:\n            # some margin on the actuator to not false trigger cancellation while stopping\n            events.add(EventName.speedTooLow)\n          if CS.vEgo < 0.001:\n            # while in standstill, send a user alert\n            events.add(EventName.manualRestart)\n\n    elif self.CP.brand == 'gm':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.sport, GearShifter.low,\n                                                                   GearShifter.eco, GearShifter.manumatic],\n                                         pcm_enable=self.CP.pcmCruise)\n\n      # Enabling at a standstill with brake is allowed\n      # TODO: verify 17 Volt can enable for the first time at a stop and allow for all GMs\n      if CS.vEgo < self.CP.minEnableSpeed and not (CS.standstill and CS.brake >= 20 and\n                                                   self.CP.networkLocation == NetworkLocation.fwdCamera):\n        events.add(EventName.belowEngageSpeed)\n      if CS.cruiseState.standstill:\n        events.add(EventName.resumeRequired)\n\n    elif self.CP.brand == 'volkswagen':\n      events = self.create_common_events(CS, CS_prev, extra_gears=[GearShifter.eco, GearShifter.sport, GearShifter.manumatic],\n                                         pcm_enable=self.CP.pcmCruise)\n\n      if self.CP.openpilotLongitudinalControl:\n        if CS.vEgo < self.CP.minEnableSpeed + 0.5:\n          events.add(EventName.belowEngageSpeed)\n        if CC.enabled and CS.vEgo < self.CP.minEnableSpeed:\n          events.add(EventName.speedTooLow)\n\n      # TODO: this needs to be implemented generically in carState struct\n      # if CC.eps_timer_soft_disable_alert:  # type: ignore[attr-defined]\n      #   events.add(EventName.steerTimeLimit)\n\n    elif self.CP.brand == 'hyundai':\n      events = self.create_common_events(CS, CS_prev, extra_gears=(GearShifter.sport, GearShifter.manumatic),\n                                         pcm_enable=self.CP.pcmCruise, allow_button_cancel=False)\n\n    else:\n      events = self.create_common_events(CS, CS_prev)\n\n    return events\n\n  def create_common_events(self, CS: structs.CarState, CS_prev: car.CarState, extra_gears=None, pcm_enable=True,\n                           allow_button_cancel=True):\n    events = Events()\n\n    if CS.doorOpen:\n      events.add(EventName.doorOpen)\n    if CS.seatbeltUnlatched:\n      events.add(EventName.seatbeltNotLatched)\n    if CS.gearShifter != GearShifter.drive and (extra_gears is None or\n       CS.gearShifter not in extra_gears):\n      events.add(EventName.wrongGear)\n    if CS.gearShifter == GearShifter.reverse:\n      events.add(EventName.reverseGear)\n    if not CS.cruiseState.available:\n      events.add(EventName.wrongCarMode)\n    if CS.espDisabled:\n      events.add(EventName.espDisabled)\n    if CS.espActive:\n      events.add(EventName.espActive)\n    if CS.stockFcw:\n      events.add(EventName.stockFcw)\n    if CS.stockAeb:\n      events.add(EventName.stockAeb)\n    if CS.vEgo > MAX_CTRL_SPEED:\n      events.add(EventName.speedTooHigh)\n    if CS.cruiseState.nonAdaptive:\n      events.add(EventName.wrongCruiseMode)\n    if CS.brakeHoldActive and self.CP.openpilotLongitudinalControl:\n      events.add(EventName.brakeHold)\n    if CS.parkingBrake:\n      events.add(EventName.parkBrake)\n    if CS.accFaulted:\n      events.add(EventName.accFaulted)\n    if CS.steeringPressed:\n      events.add(EventName.steerOverride)\n    if CS.steeringDisengage and not CS_prev.steeringDisengage:\n      events.add(EventName.steerDisengage)\n    if CS.brakePressed and CS.standstill:\n      events.add(EventName.preEnableStandstill)\n    if CS.gasPressed:\n      events.add(EventName.gasPressedOverride)\n    if CS.vehicleSensorsInvalid:\n      events.add(EventName.vehicleSensorsInvalid)\n    if CS.invalidLkasSetting:\n      events.add(EventName.invalidLkasSetting)\n    if CS.lowSpeedAlert:\n      events.add(EventName.belowSteerSpeed)\n    if CS.buttonEnable:\n      events.add(EventName.buttonEnable)\n\n    # Handle cancel button presses\n    for b in CS.buttonEvents:\n      # Disable on rising and falling edge of cancel for both stock and OP long\n      # TODO: only check the cancel button with openpilot longitudinal on all brands to match panda safety\n      if b.type == ButtonType.cancel and (allow_button_cancel or not self.CP.pcmCruise):\n        events.add(EventName.buttonCancel)\n\n    # Handle permanent and temporary steering faults\n    self.steering_unpressed = 0 if CS.steeringPressed else self.steering_unpressed + 1\n    if CS.steerFaultTemporary:\n      if CS.steeringPressed and (not CS_prev.steerFaultTemporary or self.no_steer_warning):\n        self.no_steer_warning = True\n      else:\n        self.no_steer_warning = False\n\n        # if the user overrode recently, show a less harsh alert\n        if self.silent_steer_warning or CS.standstill or self.steering_unpressed < int(1.5 / DT_CTRL):\n          self.silent_steer_warning = True\n          events.add(EventName.steerTempUnavailableSilent)\n        else:\n          events.add(EventName.steerTempUnavailable)\n    else:\n      self.no_steer_warning = False\n      self.silent_steer_warning = False\n    if CS.steerFaultPermanent:\n      events.add(EventName.steerUnavailable)\n\n    # we engage when pcm is active (rising edge)\n    # enabling can optionally be blocked by the car interface\n    if pcm_enable:\n      if CS.cruiseState.enabled and not CS_prev.cruiseState.enabled and not CS.blockPcmEnable:\n        events.add(EventName.pcmEnable)\n      elif not CS.cruiseState.enabled:\n        events.add(EventName.pcmDisable)\n\n    return events", "target": "car specific events"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/cruise.py:VCruiseHelper:0", "source": "class CLASSTOKEN:\n  def __init__(self, CP):\n    self.CP = CP\n    self.v_cruise_kph = V_CRUISE_UNSET\n    self.v_cruise_cluster_kph = V_CRUISE_UNSET\n    self.v_cruise_kph_last = 0\n    self.button_timers = {ButtonType.decelCruise: 0, ButtonType.accelCruise: 0}\n    self.button_change_states = {btn: {\"standstill\": False, \"enabled\": False} for btn in self.button_timers}\n\n  @property\n  def v_cruise_initialized(self):\n    return self.v_cruise_kph != V_CRUISE_UNSET\n\n  def update_v_cruise(self, CS, enabled, is_metric):\n    self.v_cruise_kph_last = self.v_cruise_kph\n\n    if CS.cruiseState.available:\n      if not self.CP.pcmCruise:\n        # if stock cruise is completely disabled, then we can use our own set speed logic\n        self._update_v_cruise_non_pcm(CS, enabled, is_metric)\n        self.v_cruise_cluster_kph = self.v_cruise_kph\n        self.update_button_timers(CS, enabled)\n      else:\n        self.v_cruise_kph = CS.cruiseState.speed * CV.MS_TO_KPH\n        self.v_cruise_cluster_kph = CS.cruiseState.speedCluster * CV.MS_TO_KPH\n        if CS.cruiseState.speed == 0:\n          self.v_cruise_kph = V_CRUISE_UNSET\n          self.v_cruise_cluster_kph = V_CRUISE_UNSET\n        elif CS.cruiseState.speed == -1:\n          self.v_cruise_kph = -1\n          self.v_cruise_cluster_kph = -1\n    else:\n      self.v_cruise_kph = V_CRUISE_UNSET\n      self.v_cruise_cluster_kph = V_CRUISE_UNSET\n\n  def _update_v_cruise_non_pcm(self, CS, enabled, is_metric):\n    # handle button presses. TODO: this should be in state_control, but a decelCruise press\n    # would have the effect of both enabling and changing speed is checked after the state transition\n    if not enabled:\n      return\n\n    long_press = False\n    button_type = None\n\n    v_cruise_delta = 1. if is_metric else IMPERIAL_INCREMENT\n\n    for b in CS.buttonEvents:\n      if b.type.raw in self.button_timers and not b.pressed:\n        if self.button_timers[b.type.raw] > CRUISE_LONG_PRESS:\n          return  # end long press\n        button_type = b.type.raw\n        break\n    else:\n      for k, timer in self.button_timers.items():\n        if timer and timer % CRUISE_LONG_PRESS == 0:\n          button_type = k\n          long_press = True\n          break\n\n    if button_type is None:\n      return\n\n    # Don't adjust speed when pressing resume to exit standstill\n    cruise_standstill = self.button_change_states[button_type][\"standstill\"] or CS.cruiseState.standstill\n    if button_type == ButtonType.accelCruise and cruise_standstill:\n      return\n\n    # Don't adjust speed if we've enabled since the button was depressed (some ports enable on rising edge)\n    if not self.button_change_states[button_type][\"enabled\"]:\n      return\n\n    v_cruise_delta = v_cruise_delta * (5 if long_press else 1)\n    if long_press and self.v_cruise_kph % v_cruise_delta != 0:  # partial interval\n      self.v_cruise_kph = CRUISE_NEAREST_FUNC[button_type](self.v_cruise_kph / v_cruise_delta) * v_cruise_delta\n    else:\n      self.v_cruise_kph += v_cruise_delta * CRUISE_INTERVAL_SIGN[button_type]\n\n    # If set is pressed while overriding, clip cruise speed to minimum of vEgo\n    if CS.gasPressed and button_type in (ButtonType.decelCruise, ButtonType.setCruise):\n      self.v_cruise_kph = max(self.v_cruise_kph, CS.vEgo * CV.MS_TO_KPH)\n\n    self.v_cruise_kph = np.clip(round(self.v_cruise_kph, 1), V_CRUISE_MIN, V_CRUISE_MAX)\n\n  def update_button_timers(self, CS, enabled):\n    # increment timer for buttons still pressed\n    for k in self.button_timers:\n      if self.button_timers[k] > 0:\n        self.button_timers[k] += 1\n\n    for b in CS.buttonEvents:\n      if b.type.raw in self.button_timers:\n        # Start/end timer and store current state on change of button pressed\n        self.button_timers[b.type.raw] = 1 if b.pressed else 0\n        self.button_change_states[b.type.raw] = {\"standstill\": CS.cruiseState.standstill, \"enabled\": enabled}\n\n  def initialize_v_cruise(self, CS, experimental_mode: bool) -> None:\n    # initializing is handled by the PCM\n    if self.CP.pcmCruise:\n      return\n\n    initial = V_CRUISE_INITIAL_EXPERIMENTAL_MODE if experimental_mode else V_CRUISE_INITIAL\n\n    if any(b.type in (ButtonType.accelCruise, ButtonType.resumeCruise) for b in CS.buttonEvents) and self.v_cruise_initialized:\n      self.v_cruise_kph = self.v_cruise_kph_last\n    else:\n      self.v_cruise_kph = int(round(np.clip(CS.vEgo * CV.MS_TO_KPH, initial, V_CRUISE_MAX)))\n\n    self.v_cruise_cluster_kph = self.v_cruise_kph", "target": "v cruise helper"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/card.py:Car:0", "source": "class CLASSTOKEN:\n  CI: CarInterfaceBase\n  RI: RadarInterfaceBase\n  CP: car.CarParams\n\n  def __init__(self, CI=None, RI=None) -> None:\n    self.can_sock = messaging.sub_sock('can', timeout=20)\n    self.sm = messaging.SubMaster(['pandaStates', 'carControl', 'onroadEvents'])\n    self.pm = messaging.PubMaster(['sendcan', 'carState', 'carParams', 'carOutput', 'liveTracks'])\n\n    self.can_rcv_cum_timeout_counter = 0\n\n    self.CC_prev = car.CarControl.new_message()\n    self.CS_prev = car.CarState.new_message()\n    self.initialized_prev = False\n\n    self.last_actuators_output = structs.CarControl.Actuators()\n\n    self.params = Params()\n\n    self.can_callbacks = can_comm_callbacks(self.can_sock, self.pm.sock['sendcan'])\n\n    is_release = self.params.get_bool(\"IsReleaseBranch\")\n\n    if CI is None:\n      # wait for one pandaState and one CAN packet\n      print(\"Waiting for CAN messages...\")\n      while True:\n        can = messaging.recv_one_retry(self.can_sock)\n        if len(can.can) > 0:\n          break\n\n      alpha_long_allowed = self.params.get_bool(\"AlphaLongitudinalEnabled\")\n      num_pandas = len(messaging.recv_one_retry(self.sm.sock['pandaStates']).pandaStates)\n\n      cached_params = None\n      cached_params_raw = self.params.get(\"CarParamsCache\")\n      if cached_params_raw is not None:\n        with car.CarParams.from_bytes(cached_params_raw) as _cached_params:\n          cached_params = _cached_params\n\n      self.CI = get_car(*self.can_callbacks, obd_callback(self.params), alpha_long_allowed, is_release, num_pandas, cached_params)\n      self.RI = interfaces[self.CI.CP.carFingerprint].RadarInterface(self.CI.CP)\n      self.CP = self.CI.CP\n\n      # continue onto next fingerprinting step in pandad\n      self.params.put_bool(\"FirmwareQueryDone\", True)\n    else:\n      self.CI, self.CP = CI, CI.CP\n      self.RI = RI\n\n    self.CP.alternativeExperience = 0\n    openpilot_enabled_toggle = self.params.get_bool(\"OpenpilotEnabledToggle\")\n    controller_available = self.CI.CC is not None and openpilot_enabled_toggle and not self.CP.dashcamOnly\n    self.CP.passive = not controller_available or self.CP.dashcamOnly\n    if self.CP.passive:\n      safety_config = structs.CarParams.SafetyConfig()\n      safety_config.safetyModel = structs.CarParams.SafetyModel.noOutput\n      self.CP.safetyConfigs = [safety_config]\n\n    if self.CP.secOcRequired and not is_release:\n      # Copy user key if available\n      try:\n        with open(\"/cache/params/SecOCKey\") as f:\n          user_key = f.readline().strip()\n          if len(user_key) == 32:\n            self.params.put(\"SecOCKey\", user_key)\n      except Exception:\n        pass\n\n      secoc_key = self.params.get(\"SecOCKey\")\n      if secoc_key is not None:\n        saved_secoc_key = bytes.fromhex(secoc_key.strip())\n        if len(saved_secoc_key) == 16:\n          self.CP.secOcKeyAvailable = True\n          self.CI.CS.secoc_key = saved_secoc_key\n          if controller_available:\n            self.CI.CC.secoc_key = saved_secoc_key\n        else:\n          cloudlog.warning(\"Saved SecOC key is invalid\")\n\n    # Write previous route's CarParams\n    prev_cp = self.params.get(\"CarParamsPersistent\")\n    if prev_cp is not None:\n      self.params.put(\"CarParamsPrevRoute\", prev_cp)\n\n    # Write CarParams for controls and radard\n    cp_bytes = self.CP.to_bytes()\n    self.params.put(\"CarParams\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsCache\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsPersistent\", cp_bytes)\n\n    self.mock_carstate = MockCarState()\n    self.v_cruise_helper = VCruiseHelper(self.CP)\n\n    self.is_metric = self.params.get_bool(\"IsMetric\")\n    self.experimental_mode = self.params.get_bool(\"ExperimentalMode\")\n\n    # card is driven by can recv, expected at 100Hz\n    self.rk = Ratekeeper(100, print_delay_threshold=None)\n\n  def state_update(self) -> tuple[car.CarState, structs.RadarDataT | None]:\n    \"\"\"carState update loop, driven by can\"\"\"\n\n    can_strs = messaging.drain_sock_raw(self.can_sock, wait_for_one=True)\n    can_list = can_capnp_to_list(can_strs)\n\n    # Update carState from CAN\n    CS = self.CI.update(can_list)\n    if self.CP.brand == 'mock':\n      CS = self.mock_carstate.update(CS)\n\n    # Update radar tracks from CAN\n    RD: structs.RadarDataT | None = self.RI.update(can_list)\n\n    self.sm.update(0)\n\n    can_rcv_valid = len(can_strs) > 0\n\n    # Check for CAN timeout\n    if not can_rcv_valid:\n      self.can_rcv_cum_timeout_counter += 1\n\n    if can_rcv_valid and REPLAY:\n      self.can_log_mono_time = messaging.log_from_bytes(can_strs[0]).logMonoTime\n\n    self.v_cruise_helper.update_v_cruise(CS, self.sm['carControl'].enabled, self.is_metric)\n    if self.sm['carControl'].enabled and not self.CC_prev.enabled:\n      # Use CarState w/ buttons from the step selfdrived enables on\n      self.v_cruise_helper.initialize_v_cruise(self.CS_prev, self.experimental_mode)\n\n    # TODO: mirror the carState.cruiseState struct?\n    CS.vCruise = float(self.v_cruise_helper.v_cruise_kph)\n    CS.vCruiseCluster = float(self.v_cruise_helper.v_cruise_cluster_kph)\n\n    return CS, RD\n\n  def state_publish(self, CS: car.CarState, RD: structs.RadarDataT | None):\n    \"\"\"carState and carParams publish loop\"\"\"\n\n    # carParams - logged every 50 seconds (> 1 per segment)\n    if self.sm.frame % int(50. / DT_CTRL) == 0:\n      cp_send = messaging.new_message('carParams')\n      cp_send.valid = True\n      cp_send.carParams = self.CP\n      self.pm.send('carParams', cp_send)\n\n    # publish new carOutput\n    co_send = messaging.new_message('carOutput')\n    co_send.valid = self.sm.all_checks(['carControl'])\n    co_send.carOutput.actuatorsOutput = self.last_actuators_output\n    self.pm.send('carOutput', co_send)\n\n    # kick off controlsd step while we actuate the latest carControl packet\n    cs_send = messaging.new_message('carState')\n    cs_send.valid = CS.canValid\n    cs_send.carState = CS\n    cs_send.carState.canErrorCounter = self.can_rcv_cum_timeout_counter\n    cs_send.carState.cumLagMs = -self.rk.remaining * 1000.\n    self.pm.send('carState', cs_send)\n\n    if RD is not None:\n      tracks_msg = messaging.new_message('liveTracks')\n      tracks_msg.valid = not any(RD.errors.to_dict().values())\n      tracks_msg.liveTracks = RD\n      self.pm.send('liveTracks', tracks_msg)\n\n  def controls_update(self, CS: car.CarState, CC: car.CarControl):\n    \"\"\"control update loop, driven by carControl\"\"\"\n\n    if not self.initialized_prev:\n      # Initialize CarInterface, once controls are ready\n      # TODO: this can make us miss at least a few cycles when doing an ECU knockout\n      self.CI.init(self.CP, *self.can_callbacks)\n      # signal pandad to switch to car safety mode\n      self.params.put_bool_nonblocking(\"ControlsReady\", True)\n\n    if self.sm.all_alive(['carControl']):\n      # send car controls over can\n      now_nanos = self.can_log_mono_time if REPLAY else int(time.monotonic() * 1e9)\n      self.last_actuators_output, can_sends = self.CI.apply(CC, now_nanos)\n      self.pm.send('sendcan', can_list_to_can_capnp(can_sends, msgtype='sendcan', valid=CS.canValid))\n\n      self.CC_prev = CC\n\n  def step(self):\n    CS, RD = self.state_update()\n\n    self.state_publish(CS, RD)\n\n    initialized = (not any(e.name == EventName.selfdriveInitializing for e in self.sm['onroadEvents']) and\n                   self.sm.seen['onroadEvents'])\n    if not self.CP.passive and initialized:\n      self.controls_update(CS, self.sm['carControl'])\n\n    self.initialized_prev = initialized\n    self.CS_prev = CS\n\n  def params_thread(self, evt):\n    while not evt.is_set():\n      self.is_metric = self.params.get_bool(\"IsMetric\")\n      self.experimental_mode = self.params.get_bool(\"ExperimentalMode\") and self.CP.openpilotLongitudinalControl\n      time.sleep(0.1)\n\n  def card_thread(self):\n    e = threading.Event()\n    t = threading.Thread(target=self.params_thread, args=(e, ))\n    try:\n      t.start()\n      while True:\n        self.step()\n        self.rk.monitor_time()\n    finally:\n      e.set()\n      t.join()", "target": "car"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_models.py:TestCarModelBase:0", "source": "class CLASSTOKEN(unittest.TestCase):\n  platform: Platform | None = None\n  test_route: CarTestRoute | None = None\n\n  can_msgs: list[tuple[int, list[CanData]]]\n  fingerprint: dict[int, dict[int, int]]\n  elm_frame: int | None\n  car_safety_mode_frame: int | None\n\n  @classmethod\n  def get_testing_data_from_logreader(cls, lr):\n    car_fw = []\n    can_msgs = []\n    cls.elm_frame = None\n    cls.car_safety_mode_frame = None\n    cls.fingerprint = gen_empty_fingerprint()\n    alpha_long = False\n    for msg in lr:\n      if msg.which() == \"can\":\n        can = can_capnp_to_list((msg.as_builder().to_bytes(),))[0]\n        can_msgs.append((can[0], [CanData(*can) for can in can[1]]))\n        if len(can_msgs) <= FRAME_FINGERPRINT:\n          for m in msg.can:\n            if m.src < 64:\n              cls.fingerprint[m.src][m.address] = len(m.dat)\n\n      elif msg.which() == \"carParams\":\n        car_fw = msg.carParams.carFw\n        if msg.carParams.openpilotLongitudinalControl:\n          alpha_long = True\n        if cls.platform is None:\n          live_fingerprint = msg.carParams.carFingerprint\n          cls.platform = MIGRATION.get(live_fingerprint, live_fingerprint)\n\n      # Log which can frame the panda safety mode left ELM327, for CAN validity checks\n      elif msg.which() == 'pandaStates':\n        for ps in msg.pandaStates:\n          if cls.elm_frame is None and ps.safetyModel != SafetyModel.elm327:\n            cls.elm_frame = len(can_msgs)\n          if cls.car_safety_mode_frame is None and ps.safetyModel not in \\\n            (SafetyModel.elm327, SafetyModel.noOutput):\n            cls.car_safety_mode_frame = len(can_msgs)\n\n      elif msg.which() == 'pandaStateDEPRECATED':\n        if cls.elm_frame is None and msg.pandaStateDEPRECATED.safetyModel != SafetyModel.elm327:\n          cls.elm_frame = len(can_msgs)\n        if cls.car_safety_mode_frame is None and msg.pandaStateDEPRECATED.safetyModel not in \\\n          (SafetyModel.elm327, SafetyModel.noOutput):\n          cls.car_safety_mode_frame = len(can_msgs)\n\n    assert len(can_msgs) > int(50 / DT_CTRL), \"no can data found\"\n    return car_fw, can_msgs, alpha_long\n\n  @classmethod\n  def get_testing_data(cls):\n    test_segs = (2, 1, 0)\n    if cls.test_route.segment is not None:\n      test_segs = (cls.test_route.segment,)\n\n    for seg in test_segs:\n      segment_range = f\"{cls.test_route.route}/{seg}\"\n\n      try:\n        sources = [internal_source] if len(INTERNAL_SEG_LIST) else [openpilotci_source, comma_api_source]\n        lr = LogReader(segment_range, sources=sources, sort_by_time=True)\n        return cls.get_testing_data_from_logreader(lr)\n      except (LogsUnavailable, AssertionError):\n        pass\n\n    raise Exception(f\"Route: {repr(cls.test_route.route)} with segments: {test_segs} not found or no CAN msgs found. Is it uploaded and public?\")\n\n\n  @classmethod\n  def setUpClass(cls):\n    if cls.__name__ == 'TestCarModel' or cls.__name__.endswith('Base'):\n      raise unittest.SkipTest\n\n    if cls.test_route is None:\n      if cls.platform in non_tested_cars:\n        print(f\"Skipping tests for {cls.platform}: missing route\")\n        raise unittest.SkipTest\n      raise Exception(f\"missing test route for {cls.platform}\")\n\n    car_fw, cls.can_msgs, alpha_long = cls.get_testing_data()\n\n    # if relay is expected to be open in the route\n    cls.openpilot_enabled = cls.car_safety_mode_frame is not None\n\n    cls.CarInterface = interfaces[cls.platform]\n    cls.CP = cls.CarInterface.get_params(cls.platform, cls.fingerprint, car_fw, alpha_long, False, docs=False)\n    assert cls.CP\n    assert cls.CP.carFingerprint == cls.platform\n\n    os.environ[\"COMMA_CACHE\"] = DEFAULT_DOWNLOAD_CACHE_ROOT\n\n  @classmethod\n  def tearDownClass(cls):\n    del cls.can_msgs\n\n  def setUp(self):\n    self.CI = self.CarInterface(self.CP.copy())\n    assert self.CI\n\n    # TODO: check safetyModel is in release panda build\n    self.safety = libsafety_py.libsafety\n\n    cfg = self.CP.safetyConfigs[-1]\n    set_status = self.safety.set_safety_hooks(cfg.safetyModel.raw, cfg.safetyParam)\n    self.assertEqual(0, set_status, f\"failed to set safetyModel {cfg}\")\n    self.safety.init_tests()\n\n  def test_car_params(self):\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check carParams for dashcamOnly\")\n\n    # make sure car params are within a valid range\n    self.assertGreater(self.CP.mass, 1)\n\n    if self.CP.steerControlType != SteerControlType.angle:\n      tuning = self.CP.lateralTuning.which()\n      if tuning == 'pid':\n        self.assertTrue(len(self.CP.lateralTuning.pid.kpV))\n      elif tuning == 'torque':\n        self.assertTrue(self.CP.lateralTuning.torque.kf > 0)\n      else:\n        raise Exception(\"unknown tuning\")\n\n  def test_car_interface(self):\n    # TODO: also check for checksum violations from can parser\n    can_invalid_cnt = 0\n    CC = structs.CarControl().as_reader()\n\n    for i, msg in enumerate(self.can_msgs):\n      CS = self.CI.update(msg)\n      self.CI.apply(CC, msg[0])\n\n      # wait max of 2s for low frequency msgs to be seen\n      if i > 250:\n        can_invalid_cnt += not CS.canValid\n\n    self.assertEqual(can_invalid_cnt, 0)\n\n  def test_radar_interface(self):\n    RI = self.CarInterface.RadarInterface(self.CP)\n    assert RI\n\n    # Since OBD port is multiplexed to bus 1 (commonly radar bus) while fingerprinting,\n    # start parsing CAN messages after we've left ELM mode and can expect CAN traffic\n    error_cnt = 0\n    for i, msg in enumerate(self.can_msgs[self.elm_frame:]):\n      rr: structs.RadarData | None = RI.update(msg)\n      if rr is not None and i > 50:\n        error_cnt += rr.errors.canError\n    self.assertEqual(error_cnt, 0)\n\n  def test_panda_safety_rx_checks(self):\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    start_ts = self.can_msgs[0][0]\n\n    failed_addrs = Counter()\n    for can in self.can_msgs:\n      # update panda timer\n      t = (can[0] - start_ts) / 1e3\n      self.safety.set_timer(int(t))\n\n      # run all msgs through the safety RX hook\n      for msg in can[1]:\n        if msg.src >= 64:\n          continue\n\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        if self.safety.safety_rx_hook(to_send) != 1:\n          failed_addrs[hex(msg.address)] += 1\n\n      # ensure all msgs defined in the addr checks are valid\n      self.safety.safety_tick_current_safety_config()\n      if t > 1e6:\n        self.assertTrue(self.safety.safety_config_valid())\n\n      # Don't check relay malfunction on disabled routes (relay closed),\n      # or before fingerprinting is done (elm327 and noOutput)\n      if self.openpilot_enabled and t / 1e4 > self.car_safety_mode_frame:\n        self.assertFalse(self.safety.get_relay_malfunction())\n      else:\n        self.safety.set_relay_malfunction(False)\n\n    self.assertFalse(len(failed_addrs), f\"panda safety RX check failed: {failed_addrs}\")\n\n    # ensure RX checks go invalid after small time with no traffic\n    self.safety.set_timer(int(t + (2*1e6)))\n    self.safety.safety_tick_current_safety_config()\n    self.assertFalse(self.safety.safety_config_valid())\n\n  def test_panda_safety_tx_cases(self, data=None):\n    \"\"\"Asserts we can tx common messages\"\"\"\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    if self.CP.notCar:\n      self.skipTest(\"Skipping test for notCar\")\n\n    def test_car_controller(car_control):\n      now_nanos = 0\n      msgs_sent = 0\n      CI = self.CarInterface(self.CP)\n      for _ in range(round(10.0 / DT_CTRL)):  # make sure we hit the slowest messages\n        CI.update([])\n        _, sendcan = CI.apply(car_control, now_nanos)\n\n        now_nanos += DT_CTRL * 1e9\n        msgs_sent += len(sendcan)\n        for addr, dat, bus in sendcan:\n          to_send = libsafety_py.make_CANPacket(addr, bus % 4, dat)\n          self.assertTrue(self.safety.safety_tx_hook(to_send), (addr, dat, bus))\n\n      # Make sure we attempted to send messages\n      self.assertGreater(msgs_sent, 50)\n\n    # Make sure we can send all messages while inactive\n    CC = structs.CarControl()\n    test_car_controller(CC.as_reader())\n\n    # Test cancel + general messages (controls_allowed=False & cruise_engaged=True)\n    self.safety.set_cruise_engaged_prev(True)\n    CC = structs.CarControl(cruiseControl=structs.CarControl.CruiseControl(cancel=True))\n    test_car_controller(CC.as_reader())\n\n    # Test resume + general messages (controls_allowed=True & cruise_engaged=True)\n    self.safety.set_controls_allowed(True)\n    CC = structs.CarControl(cruiseControl=structs.CarControl.CruiseControl(resume=True))\n    test_car_controller(CC.as_reader())\n\n  # Skip stdout/stderr capture with pytest, causes elevated memory usage\n  @pytest.mark.nocapture\n  @settings(max_examples=MAX_EXAMPLES, deadline=None,\n            phases=(Phase.reuse, Phase.generate, Phase.shrink))\n  @given(data=st.data())\n  def test_panda_safety_carstate_fuzzy(self, data):\n    \"\"\"\n      For each example, pick a random CAN message on the bus and fuzz its data,\n      checking for panda state mismatches.\n    \"\"\"\n\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    valid_addrs = [(addr, bus, size) for bus, addrs in self.fingerprint.items() for addr, size in addrs.items()]\n    address, bus, size = data.draw(st.sampled_from(valid_addrs))\n\n    msg_strategy = st.binary(min_size=size, max_size=size)\n    msgs = data.draw(st.lists(msg_strategy, min_size=20))\n\n    vehicle_speed_seen = self.CP.steerControlType == SteerControlType.angle and not self.CP.notCar\n\n    for n, dat in enumerate(msgs):\n      # due to panda updating state selectively, only edges are expected to match\n      # TODO: warm up CarState with real CAN messages to check edge of both sources\n      #  (eg. toyota's gasPressed is the inverse of a signal being set)\n      prev_panda_gas = self.safety.get_gas_pressed_prev()\n      prev_panda_brake = self.safety.get_brake_pressed_prev()\n      prev_panda_regen_braking = self.safety.get_regen_braking_prev()\n      prev_panda_steering_disengage = self.safety.get_steering_disengage_prev()\n      prev_panda_vehicle_moving = self.safety.get_vehicle_moving()\n      prev_panda_vehicle_speed_min = self.safety.get_vehicle_speed_min()\n      prev_panda_vehicle_speed_max = self.safety.get_vehicle_speed_max()\n      prev_panda_cruise_engaged = self.safety.get_cruise_engaged_prev()\n      prev_panda_acc_main_on = self.safety.get_acc_main_on()\n\n      to_send = libsafety_py.make_CANPacket(address, bus, dat)\n      self.safety.safety_rx_hook(to_send)\n\n      can = [(int(time.monotonic() * 1e9), [CanData(address=address, dat=dat, src=bus)])]\n      CS = self.CI.update(can)\n      if n < 5:  # CANParser warmup time\n        continue\n\n      if self.safety.get_gas_pressed_prev() != prev_panda_gas:\n        self.assertEqual(CS.gasPressed, self.safety.get_gas_pressed_prev())\n\n      if self.safety.get_brake_pressed_prev() != prev_panda_brake:\n        # TODO: remove this exception once this mismatch is resolved\n        brake_pressed = CS.brakePressed\n        if CS.brakePressed and not self.safety.get_brake_pressed_prev():\n          if self.CP.carFingerprint in (HONDA.HONDA_PILOT, HONDA.HONDA_RIDGELINE) and CS.brake > 0.05:\n            brake_pressed = False\n\n        self.assertEqual(brake_pressed, self.safety.get_brake_pressed_prev())\n\n      if self.safety.get_regen_braking_prev() != prev_panda_regen_braking:\n        self.assertEqual(CS.regenBraking, self.safety.get_regen_braking_prev())\n\n      if self.safety.get_steering_disengage_prev() != prev_panda_steering_disengage:\n        self.assertEqual(CS.steeringDisengage, self.safety.get_steering_disengage_prev())\n\n      if self.safety.get_vehicle_moving() != prev_panda_vehicle_moving and not self.CP.notCar:\n        self.assertEqual(not CS.standstill, self.safety.get_vehicle_moving())\n\n      # check vehicle speed if angle control car or available\n      if self.safety.get_vehicle_speed_min() > 0 or self.safety.get_vehicle_speed_max() > 0:\n        vehicle_speed_seen = True\n\n      if vehicle_speed_seen and (self.safety.get_vehicle_speed_min() != prev_panda_vehicle_speed_min or\n                                 self.safety.get_vehicle_speed_max() != prev_panda_vehicle_speed_max):\n        v_ego_raw = CS.vEgoRaw / self.CP.wheelSpeedFactor\n        self.assertFalse(v_ego_raw > (self.safety.get_vehicle_speed_max() + 1e-3) or\n                         v_ego_raw < (self.safety.get_vehicle_speed_min() - 1e-3))\n\n      if not (self.CP.brand == \"honda\" and not (self.CP.flags & HondaFlags.BOSCH)):\n        if self.safety.get_cruise_engaged_prev() != prev_panda_cruise_engaged:\n          self.assertEqual(CS.cruiseState.enabled, self.safety.get_cruise_engaged_prev())\n\n      if self.CP.brand == \"honda\":\n        if self.safety.get_acc_main_on() != prev_panda_acc_main_on:\n          self.assertEqual(CS.cruiseState.available, self.safety.get_acc_main_on())\n\n  def test_panda_safety_carstate(self):\n    \"\"\"\n      Assert that panda safety matches openpilot's carState\n    \"\"\"\n    if self.CP.dashcamOnly:\n      self.skipTest(\"no need to check panda safety for dashcamOnly\")\n\n    # warm up pass, as initial states may be different\n    for can in self.can_msgs[:300]:\n      self.CI.update(can)\n      for msg in filter(lambda m: m.src < 64, can[1]):\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        self.safety.safety_rx_hook(to_send)\n\n    controls_allowed_prev = False\n    CS_prev = car.CarState.new_message()\n    checks = defaultdict(int)\n    vehicle_speed_seen = self.CP.steerControlType == SteerControlType.angle and not self.CP.notCar\n    for idx, can in enumerate(self.can_msgs):\n      CS = self.CI.update(can).as_reader()\n      for msg in filter(lambda m: m.src < 64, can[1]):\n        to_send = libsafety_py.make_CANPacket(msg.address, msg.src % 4, msg.dat)\n        ret = self.safety.safety_rx_hook(to_send)\n        self.assertEqual(1, ret, f\"safety rx failed ({ret=}): {(msg.address, msg.src % 4)}\")\n\n      # Skip first frame so CS_prev is properly initialized\n      if idx == 0:\n        CS_prev = CS\n        # Button may be left pressed in warm up period\n        if not self.CP.pcmCruise:\n          self.safety.set_controls_allowed(0)\n        continue\n\n      # TODO: check rest of panda's carstate (steering, ACC main on, etc.)\n\n      checks['gasPressed'] += CS.gasPressed != self.safety.get_gas_pressed_prev()\n      checks['standstill'] += (CS.standstill == self.safety.get_vehicle_moving()) and not self.CP.notCar\n\n      # check vehicle speed if angle control car or available\n      if self.safety.get_vehicle_speed_min() > 0 or self.safety.get_vehicle_speed_max() > 0:\n        vehicle_speed_seen = True\n\n      if vehicle_speed_seen:\n        v_ego_raw = CS.vEgoRaw / self.CP.wheelSpeedFactor\n        checks['vEgoRaw'] += (v_ego_raw > (self.safety.get_vehicle_speed_max() + 1e-3) or\n                              v_ego_raw < (self.safety.get_vehicle_speed_min() - 1e-3))\n\n      # TODO: remove this exception once this mismatch is resolved\n      brake_pressed = CS.brakePressed\n      if CS.brakePressed and not self.safety.get_brake_pressed_prev():\n        if self.CP.carFingerprint in (HONDA.HONDA_PILOT, HONDA.HONDA_RIDGELINE) and CS.brake > 0.05:\n          brake_pressed = False\n      checks['brakePressed'] += brake_pressed != self.safety.get_brake_pressed_prev()\n      checks['regenBraking'] += CS.regenBraking != self.safety.get_regen_braking_prev()\n      checks['steeringDisengage'] += CS.steeringDisengage != self.safety.get_steering_disengage_prev()\n\n      if self.CP.pcmCruise:\n        # On most pcmCruise cars, openpilot's state is always tied to the PCM's cruise state.\n        # On Honda Nidec, we always engage on the rising edge of the PCM cruise state, but\n        # openpilot brakes to zero even if the min ACC speed is non-zero (i.e. the PCM disengages).\n        if self.CP.brand == \"honda\" and not (self.CP.flags & HondaFlags.BOSCH):\n          # only the rising edges are expected to match\n          if CS.cruiseState.enabled and not CS_prev.cruiseState.enabled:\n            checks['controlsAllowed'] += not self.safety.get_controls_allowed()\n        else:\n          checks['controlsAllowed'] += not CS.cruiseState.enabled and self.safety.get_controls_allowed()\n\n        # TODO: fix notCar mismatch\n        if not self.CP.notCar:\n          checks['cruiseState'] += CS.cruiseState.enabled != self.safety.get_cruise_engaged_prev()\n      else:\n        # Check for user button enable on rising edge of controls allowed\n        button_enable = CS.buttonEnable and (not CS.brakePressed or CS.standstill)\n        mismatch = button_enable != (self.safety.get_controls_allowed() and not controls_allowed_prev)\n        checks['controlsAllowed'] += mismatch\n        controls_allowed_prev = self.safety.get_controls_allowed()\n        if button_enable and not mismatch:\n          self.safety.set_controls_allowed(False)\n\n      if self.CP.brand == \"honda\":\n        checks['mainOn'] += CS.cruiseState.available != self.safety.get_acc_main_on()\n\n      CS_prev = CS\n\n    failed_checks = {k: v for k, v in checks.items() if v > 0}\n    self.assertFalse(len(failed_checks), f\"panda safety doesn't agree with openpilot: {failed_checks}\")", "target": "test car model base"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_models.py:TestCarModel:1", "source": "class CLASSTOKEN(TestCarModelBase):\n  pass", "target": "test car model"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_cruise_speed.py:TestCruiseSpeed:0", "source": "class CLASSTOKEN:\n  def test_cruise_speed(self):\n    print(f'Testing {self.speed} m/s')\n    cruise_speed = float(self.speed)\n\n    simulation_steady_state = run_cruise_simulation(cruise_speed, self.e2e, self.personality)\n    assert simulation_steady_state == pytest.approx(cruise_speed, abs=.01), f'Did not reach {self.speed} m/s'", "target": "test cruise speed"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_cruise_speed.py:TestVCruiseHelper:1", "source": "class CLASSTOKEN:\n  def setup_method(self):\n    self.CP = car.CarParams(pcmCruise=self.pcm_cruise)\n    self.v_cruise_helper = VCruiseHelper(self.CP)\n    self.reset_cruise_speed_state()\n\n  def reset_cruise_speed_state(self):\n    # Two resets previous cruise speed\n    for _ in range(2):\n      self.v_cruise_helper.update_v_cruise(car.CarState(cruiseState={\"available\": False}), enabled=False, is_metric=False)\n\n  def enable(self, v_ego, experimental_mode):\n    # Simulates user pressing set with a current speed\n    self.v_cruise_helper.initialize_v_cruise(car.CarState(vEgo=v_ego), experimental_mode)\n\n  def test_adjust_speed(self):\n    \"\"\"\n    Asserts speed changes on falling edges of buttons.\n    \"\"\"\n\n    self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n    for btn in (ButtonType.accelCruise, ButtonType.decelCruise):\n      for pressed in (True, False):\n        CS = car.CarState(cruiseState={\"available\": True})\n        CS.buttonEvents = [ButtonEvent(type=btn, pressed=pressed)]\n\n        self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n        assert pressed == (self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last)\n\n  def test_rising_edge_enable(self):\n    \"\"\"\n    Some car interfaces may enable on rising edge of a button,\n    ensure we don't adjust speed if enabled changes mid-press.\n    \"\"\"\n\n    # NOTE: enabled is always one frame behind the result from button press in controlsd\n    for enabled, pressed in ((False, False),\n                             (False, True),\n                             (True, False)):\n      CS = car.CarState(cruiseState={\"available\": True})\n      CS.buttonEvents = [ButtonEvent(type=ButtonType.decelCruise, pressed=pressed)]\n      self.v_cruise_helper.update_v_cruise(CS, enabled=enabled, is_metric=False)\n      if pressed:\n        self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n      # Expected diff on enabling. Speed should not change on falling edge of pressed\n      assert not pressed == self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last\n\n  def test_resume_in_standstill(self):\n    \"\"\"\n    Asserts we don't increment set speed if user presses resume/accel to exit cruise standstill.\n    \"\"\"\n\n    self.enable(0, False)\n\n    for standstill in (True, False):\n      for pressed in (True, False):\n        CS = car.CarState(cruiseState={\"available\": True, \"standstill\": standstill})\n        CS.buttonEvents = [ButtonEvent(type=ButtonType.accelCruise, pressed=pressed)]\n        self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n\n        # speed should only update if not at standstill and button falling edge\n        should_equal = standstill or pressed\n        assert should_equal == (self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last)\n\n  def test_set_gas_pressed(self):\n    \"\"\"\n    Asserts pressing set while enabled with gas pressed sets\n    the speed to the maximum of vEgo and current cruise speed.\n    \"\"\"\n\n    for v_ego in np.linspace(0, 100, 101):\n      self.reset_cruise_speed_state()\n      self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n      # first decrement speed, then perform gas pressed logic\n      expected_v_cruise_kph = self.v_cruise_helper.v_cruise_kph - IMPERIAL_INCREMENT\n      expected_v_cruise_kph = max(expected_v_cruise_kph, v_ego * CV.MS_TO_KPH)  # clip to min of vEgo\n      expected_v_cruise_kph = float(np.clip(round(expected_v_cruise_kph, 1), V_CRUISE_MIN, V_CRUISE_MAX))\n\n      CS = car.CarState(vEgo=float(v_ego), gasPressed=True, cruiseState={\"available\": True})\n      CS.buttonEvents = [ButtonEvent(type=ButtonType.decelCruise, pressed=False)]\n      self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n\n      # TODO: fix skipping first run due to enabled on rising edge exception\n      if v_ego == 0.0:\n        continue\n      assert expected_v_cruise_kph == self.v_cruise_helper.v_cruise_kph\n\n  def test_initialize_v_cruise(self):\n    \"\"\"\n    Asserts allowed cruise speeds on enabling with SET.\n    \"\"\"\n\n    for experimental_mode in (True, False):\n      for v_ego in np.linspace(0, 100, 101):\n        self.reset_cruise_speed_state()\n        assert not self.v_cruise_helper.v_cruise_initialized\n\n        self.enable(float(v_ego), experimental_mode)\n        assert V_CRUISE_INITIAL <= self.v_cruise_helper.v_cruise_kph <= V_CRUISE_MAX\n        assert self.v_cruise_helper.v_cruise_initialized", "target": "test v cruise helper"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_car_interfaces.py:TestCarInterfaces:0", "source": "class CLASSTOKEN:\n  # FIXME: Due to the lists used in carParams, Phase.target is very slow and will cause\n  #  many generated examples to overrun when max_examples > ~20, don't use it\n  @parameterized.expand([(car,) for car in sorted(PLATFORMS)] + [MOCK.MOCK])\n  @settings(max_examples=MAX_EXAMPLES, deadline=None,\n            phases=(Phase.reuse, Phase.generate, Phase.shrink))\n  @given(data=st.data())\n  def test_car_interfaces(self, car_name, data):\n    car_interface = get_fuzzy_car_interface(car_name, data.draw)\n    car_params = car_interface.CP.as_reader()\n\n    cc_msg = FuzzyGenerator.get_random_msg(data.draw, car.CarControl, real_floats=True)\n    # Run car interface\n    now_nanos = 0\n    CC = car.CarControl.new_message(**cc_msg)\n    CC = CC.as_reader()\n    for _ in range(10):\n      car_interface.update([])\n      car_interface.apply(CC, now_nanos)\n      now_nanos += DT_CTRL * 1e9  # 10 ms\n\n    CC = car.CarControl.new_message(**cc_msg)\n    CC.enabled = True\n    CC.latActive = True\n    CC.longActive = True\n    CC = CC.as_reader()\n    for _ in range(10):\n      car_interface.update([])\n      car_interface.apply(CC, now_nanos)\n      now_nanos += DT_CTRL * 1e9  # 10ms\n\n    # Test controller initialization\n    # TODO: wait until card refactor is merged to run controller a few times,\n    #  hypothesis also slows down significantly with just one more message draw\n    LongControl(car_params)\n    if car_params.steerControlType == CarParams.SteerControlType.angle:\n      LatControlAngle(car_params, car_interface)\n    elif car_params.lateralTuning.which() == 'pid':\n      LatControlPID(car_params, car_interface)\n    elif car_params.lateralTuning.which() == 'torque':\n      LatControlTorque(car_params, car_interface)", "target": "test car interfaces"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_docs.py:TestCarDocs:0", "source": "class CLASSTOKEN:\n  @classmethod\n  def setup_class(cls):\n    cls.all_cars = get_all_car_docs()\n\n  def test_generator(self):\n    generate_cars_md(self.all_cars, CARS_MD_TEMPLATE)\n\n  def test_docs_diff(self):\n    dump_path = os.path.join(BASEDIR, \"selfdrive\", \"car\", \"tests\", \"cars_dump\")\n    dump_car_docs(dump_path)\n    print_car_docs_diff(dump_path)\n    os.remove(dump_path)", "target": "test car docs"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/parse_model_outputs.py:Parser:0", "source": "class CLASSTOKEN:\n  def __init__(self, ignore_missing=False):\n    self.ignore_missing = ignore_missing\n\n  def check_missing(self, outs, name):\n    missing = name not in outs\n    if missing and not self.ignore_missing:\n      raise ValueError(f\"Missing output {name}\")\n    return missing\n\n  def parse_categorical_crossentropy(self, name, outs, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    if out_shape is not None:\n      raw = raw.reshape((raw.shape[0],) + out_shape)\n    outs[name] = softmax(raw, axis=-1)\n\n  def parse_binary_crossentropy(self, name, outs):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    outs[name] = sigmoid(raw)\n\n  def parse_mdn(self, name, outs, in_N=0, out_N=1, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    raw = raw.reshape((raw.shape[0], max(in_N, 1), -1))\n\n    n_values = (raw.shape[2] - out_N)//2\n    pred_mu = raw[:,:,:n_values]\n    pred_std = safe_exp(raw[:,:,n_values: 2*n_values])\n\n    if in_N > 1:\n      weights = np.zeros((raw.shape[0], in_N, out_N), dtype=raw.dtype)\n      for i in range(out_N):\n        weights[:,:,i - out_N] = softmax(raw[:,:,i - out_N], axis=-1)\n\n      if out_N == 1:\n        for fidx in range(weights.shape[0]):\n          idxs = np.argsort(weights[fidx][:,0])[::-1]\n          weights[fidx] = weights[fidx][idxs]\n          pred_mu[fidx] = pred_mu[fidx][idxs]\n          pred_std[fidx] = pred_std[fidx][idxs]\n      full_shape = tuple([raw.shape[0], in_N] + list(out_shape))\n      outs[name + '_weights'] = weights\n      outs[name + '_hypotheses'] = pred_mu.reshape(full_shape)\n      outs[name + '_stds_hypotheses'] = pred_std.reshape(full_shape)\n\n      pred_mu_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      pred_std_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      for fidx in range(weights.shape[0]):\n        for hidx in range(out_N):\n          idxs = np.argsort(weights[fidx,:,hidx])[::-1]\n          pred_mu_final[fidx, hidx] = pred_mu[fidx, idxs[0]]\n          pred_std_final[fidx, hidx] = pred_std[fidx, idxs[0]]\n    else:\n      pred_mu_final = pred_mu\n      pred_std_final = pred_std\n\n    if out_N > 1:\n      final_shape = tuple([raw.shape[0], out_N] + list(out_shape))\n    else:\n      final_shape = tuple([raw.shape[0],] + list(out_shape))\n    outs[name] = pred_mu_final.reshape(final_shape)\n    outs[name + '_stds'] = pred_std_final.reshape(final_shape)\n\n  def is_mhp(self, outs, name, shape):\n    if self.check_missing(outs, name):\n      return False\n    if outs[name].shape[1] == 2 * shape:\n      return False\n    return True\n\n  def parse_vision_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    self.parse_mdn('pose', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('wide_from_device_euler', outs, in_N=0, out_N=0, out_shape=(ModelConstants.WIDE_FROM_DEVICE_WIDTH,))\n    self.parse_mdn('road_transform', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('lane_lines', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_LANE_LINES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_mdn('road_edges', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_ROAD_EDGES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_binary_crossentropy('lane_lines_prob', outs)\n    self.parse_categorical_crossentropy('desire_pred', outs, out_shape=(ModelConstants.DESIRE_PRED_LEN,ModelConstants.DESIRE_PRED_WIDTH))\n    self.parse_binary_crossentropy('meta', outs)\n    self.parse_binary_crossentropy('lead_prob', outs)\n    lead_mhp = self.is_mhp(outs, 'lead', ModelConstants.LEAD_MHP_SELECTION * ModelConstants.LEAD_TRAJ_LEN * ModelConstants.LEAD_WIDTH)\n    lead_in_N, lead_out_N = (ModelConstants.LEAD_MHP_N, ModelConstants.LEAD_MHP_SELECTION) if lead_mhp else (0, 0)\n    lead_out_shape = (ModelConstants.LEAD_TRAJ_LEN, ModelConstants.LEAD_WIDTH) if lead_mhp else \\\n        (ModelConstants.LEAD_MHP_SELECTION, ModelConstants.LEAD_TRAJ_LEN, ModelConstants.LEAD_WIDTH)\n    self.parse_mdn('lead', outs, in_N=lead_in_N, out_N=lead_out_N, out_shape=lead_out_shape)\n    return outs\n\n  def parse_policy_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    plan_mhp = self.is_mhp(outs, 'plan',  ModelConstants.IDX_N * ModelConstants.PLAN_WIDTH)\n    plan_in_N, plan_out_N = (ModelConstants.PLAN_MHP_N, ModelConstants.PLAN_MHP_SELECTION) if plan_mhp else (0, 0)\n    self.parse_mdn('plan', outs, in_N=plan_in_N, out_N=plan_out_N, out_shape=(ModelConstants.IDX_N, ModelConstants.PLAN_WIDTH))\n    self.parse_categorical_crossentropy('desire_state', outs, out_shape=(ModelConstants.DESIRE_PRED_WIDTH,))\n    return outs\n\n  def parse_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    outs = self.parse_vision_outputs(outs)\n    outs = self.parse_policy_outputs(outs)\n    return outs", "target": "parser"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/dmonitoringmodeld.py:DriverStateResult:0", "source": "class CLASSTOKEN(ctypes.Structure):\n  _fields_ = [\n    (\"face_orientation\", ctypes.c_float*3),\n    (\"face_position\", ctypes.c_float*3),\n    (\"face_orientation_std\", ctypes.c_float*3),\n    (\"face_position_std\", ctypes.c_float*3),\n    (\"face_prob\", ctypes.c_float),\n    (\"_unused_a\", ctypes.c_float*8),\n    (\"left_eye_prob\", ctypes.c_float),\n    (\"_unused_b\", ctypes.c_float*8),\n    (\"right_eye_prob\", ctypes.c_float),\n    (\"left_blink_prob\", ctypes.c_float),\n    (\"right_blink_prob\", ctypes.c_float),\n    (\"sunglasses_prob\", ctypes.c_float),\n    (\"occluded_prob\", ctypes.c_float),\n    (\"ready_prob\", ctypes.c_float*4),\n    (\"not_ready_prob\", ctypes.c_float*2)]", "target": "driver state result"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/dmonitoringmodeld.py:DMonitoringModelResult:1", "source": "class CLASSTOKEN(ctypes.Structure):\n  _fields_ = [\n    (\"driver_state_lhd\", DriverStateResult),\n    (\"driver_state_rhd\", DriverStateResult),\n    (\"poor_vision_prob\", ctypes.c_float),\n    (\"wheel_on_right_prob\", ctypes.c_float),\n    (\"features\", ctypes.c_float*FEATURE_LEN)]", "target": "d monitoring model result"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/dmonitoringmodeld.py:ModelState:2", "source": "class CLASSTOKEN:\n  inputs: dict[str, np.ndarray]\n  output: np.ndarray\n\n  def __init__(self, cl_ctx):\n    assert ctypes.sizeof(DMonitoringModelResult) == OUTPUT_SIZE * ctypes.sizeof(ctypes.c_float)\n\n    self.frame = MonitoringModelFrame(cl_ctx)\n    self.numpy_inputs = {\n      'calib': np.zeros((1, CALIB_LEN), dtype=np.float32),\n    }\n\n    self.tensor_inputs = {k: Tensor(v, device='NPY').realize() for k,v in self.numpy_inputs.items()}\n    with open(MODEL_PKL_PATH, \"rb\") as f:\n      self.model_run = pickle.load(f)\n\n  def run(self, buf: VisionBuf, calib: np.ndarray, transform: np.ndarray) -> tuple[np.ndarray, float]:\n    self.numpy_inputs['calib'][0,:] = calib\n\n    t1 = time.perf_counter()\n\n    input_img_cl = self.frame.prepare(buf, transform.flatten())\n    if TICI:\n      # The imgs tensors are backed by opencl memory, only need init once\n      if 'input_img' not in self.tensor_inputs:\n        self.tensor_inputs['input_img'] = qcom_tensor_from_opencl_address(input_img_cl.mem_address, (1, MODEL_WIDTH*MODEL_HEIGHT), dtype=dtypes.uint8)\n    else:\n      self.tensor_inputs['input_img'] = Tensor(self.frame.buffer_from_cl(input_img_cl).reshape((1, MODEL_WIDTH*MODEL_HEIGHT)), dtype=dtypes.uint8).realize()\n\n\n    output = self.model_run(**self.tensor_inputs).contiguous().realize().uop.base.buffer.numpy()\n\n    t2 = time.perf_counter()\n    return output, t2 - t1", "target": "model state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/fill_model_msg.py:PublishState:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.disengage_buffer = np.zeros(ModelConstants.CONFIDENCE_BUFFER_LEN*ModelConstants.DISENGAGE_WIDTH, dtype=np.float32)\n    self.prev_brake_5ms2_probs = np.zeros(ModelConstants.FCW_5MS2_PROBS_WIDTH, dtype=np.float32)\n    self.prev_brake_3ms2_probs = np.zeros(ModelConstants.FCW_3MS2_PROBS_WIDTH, dtype=np.float32)", "target": "publish state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/modeld.py:FrameMeta:0", "source": "class CLASSTOKEN:\n  frame_id: int = 0\n  timestamp_sof: int = 0\n  timestamp_eof: int = 0\n\n  def __init__(self, vipc=None):\n    if vipc is not None:\n      self.frame_id, self.timestamp_sof, self.timestamp_eof = vipc.frame_id, vipc.timestamp_sof, vipc.timestamp_eof", "target": "frame meta"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/modeld.py:InputQueues:1", "source": "class CLASSTOKEN:\n  def __init__ (self, model_fps, env_fps, n_frames_input):\n    assert env_fps % model_fps == 0\n    assert env_fps >= model_fps\n    self.model_fps = model_fps\n    self.env_fps = env_fps\n    self.n_frames_input = n_frames_input\n\n    self.dtypes = {}\n    self.shapes = {}\n    self.q = {}\n\n  def update_dtypes_and_shapes(self, input_dtypes, input_shapes) -> None:\n    self.dtypes.update(input_dtypes)\n    if self.env_fps == self.model_fps:\n      self.shapes.update(input_shapes)\n    else:\n      for k in input_shapes:\n        shape = list(input_shapes[k])\n        if 'img' in k:\n          n_channels = shape[1] // self.n_frames_input\n          shape[1] = (self.env_fps // self.model_fps + (self.n_frames_input - 1)) * n_channels\n        else:\n          shape[1] = (self.env_fps // self.model_fps) * shape[1]\n        self.shapes[k] = tuple(shape)\n\n  def reset(self) -> None:\n    self.q = {k: np.zeros(self.shapes[k], dtype=self.dtypes[k]) for k in self.dtypes.keys()}\n\n  def enqueue(self, inputs:dict[str, np.ndarray]) -> None:\n    for k in inputs.keys():\n      if inputs[k].dtype != self.dtypes[k]:\n        raise ValueError(f'supplied input <{k}({inputs[k].dtype})> has wrong dtype, expected {self.dtypes[k]}')\n      input_shape = list(self.shapes[k])\n      input_shape[1] = -1\n      single_input = inputs[k].reshape(tuple(input_shape))\n      sz = single_input.shape[1]\n      self.q[k][:,:-sz] = self.q[k][:,sz:]\n      self.q[k][:,-sz:] = single_input\n\n  def get(self, *names) -> dict[str, np.ndarray]:\n    if self.env_fps == self.model_fps:\n      return {k: self.q[k] for k in names}\n    else:\n      out = {}\n      for k in names:\n        shape = self.shapes[k]\n        if 'img' in k:\n          n_channels = shape[1] // (self.env_fps // self.model_fps + (self.n_frames_input - 1))\n          out[k] = np.concatenate([self.q[k][:, s:s+n_channels] for s in np.linspace(0, shape[1] - n_channels, self.n_frames_input, dtype=int)], axis=1)\n        elif 'pulse' in k:\n          # any pulse within interval counts\n          out[k] = self.q[k].reshape((shape[0], shape[1] * self.model_fps // self.env_fps, self.env_fps // self.model_fps, -1)).max(axis=2)\n        else:\n          idxs = np.arange(-1, -shape[1], -self.env_fps // self.model_fps)[::-1]\n          out[k] = self.q[k][:, idxs]\n      return out", "target": "input queues"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/modeld.py:ModelState:2", "source": "class CLASSTOKEN:\n  frames: dict[str, DrivingModelFrame]\n  inputs: dict[str, np.ndarray]\n  output: np.ndarray\n  prev_desire: np.ndarray  # for tracking the rising edge of the pulse\n\n  def __init__(self, context: CLContext):\n    with open(VISION_METADATA_PATH, 'rb') as f:\n      vision_metadata = pickle.load(f)\n      self.vision_input_shapes =  vision_metadata['input_shapes']\n      self.vision_input_names = list(self.vision_input_shapes.keys())\n      self.vision_output_slices = vision_metadata['output_slices']\n      vision_output_size = vision_metadata['output_shapes']['outputs'][1]\n\n    with open(POLICY_METADATA_PATH, 'rb') as f:\n      policy_metadata = pickle.load(f)\n      self.policy_input_shapes =  policy_metadata['input_shapes']\n      self.policy_output_slices = policy_metadata['output_slices']\n      policy_output_size = policy_metadata['output_shapes']['outputs'][1]\n\n    self.frames = {name: DrivingModelFrame(context, ModelConstants.MODEL_RUN_FREQ//ModelConstants.MODEL_CONTEXT_FREQ) for name in self.vision_input_names}\n    self.prev_desire = np.zeros(ModelConstants.DESIRE_LEN, dtype=np.float32)\n\n    # policy inputs\n    self.numpy_inputs = {k: np.zeros(self.policy_input_shapes[k], dtype=np.float32) for k in self.policy_input_shapes}\n    self.full_input_queues = InputQueues(ModelConstants.MODEL_CONTEXT_FREQ, ModelConstants.MODEL_RUN_FREQ, ModelConstants.N_FRAMES)\n    for k in ['desire_pulse', 'features_buffer']:\n      self.full_input_queues.update_dtypes_and_shapes({k: self.numpy_inputs[k].dtype}, {k: self.numpy_inputs[k].shape})\n    self.full_input_queues.reset()\n\n    # img buffers are managed in openCL transform code\n    self.vision_inputs: dict[str, Tensor] = {}\n    self.vision_output = np.zeros(vision_output_size, dtype=np.float32)\n    self.policy_inputs = {k: Tensor(v, device='NPY').realize() for k,v in self.numpy_inputs.items()}\n    self.policy_output = np.zeros(policy_output_size, dtype=np.float32)\n    self.parser = Parser()\n\n    with open(VISION_PKL_PATH, \"rb\") as f:\n      self.vision_run = pickle.load(f)\n\n    with open(POLICY_PKL_PATH, \"rb\") as f:\n      self.policy_run = pickle.load(f)\n\n  def slice_outputs(self, model_outputs: np.ndarray, output_slices: dict[str, slice]) -> dict[str, np.ndarray]:\n    parsed_model_outputs = {k: model_outputs[np.newaxis, v] for k,v in output_slices.items()}\n    return parsed_model_outputs\n\n  def run(self, bufs: dict[str, VisionBuf], transforms: dict[str, np.ndarray],\n                inputs: dict[str, np.ndarray], prepare_only: bool) -> dict[str, np.ndarray] | None:\n    # Model decides when action is completed, so desire input is just a pulse triggered on rising edge\n    inputs['desire_pulse'][0] = 0\n    new_desire = np.where(inputs['desire_pulse'] - self.prev_desire > .99, inputs['desire_pulse'], 0)\n    self.prev_desire[:] = inputs['desire_pulse']\n\n    imgs_cl = {name: self.frames[name].prepare(bufs[name], transforms[name].flatten()) for name in self.vision_input_names}\n\n    if TICI and not USBGPU:\n      # The imgs tensors are backed by opencl memory, only need init once\n      for key in imgs_cl:\n        if key not in self.vision_inputs:\n          self.vision_inputs[key] = qcom_tensor_from_opencl_address(imgs_cl[key].mem_address, self.vision_input_shapes[key], dtype=dtypes.uint8)\n    else:\n      for key in imgs_cl:\n        frame_input = self.frames[key].buffer_from_cl(imgs_cl[key]).reshape(self.vision_input_shapes[key])\n        self.vision_inputs[key] = Tensor(frame_input, dtype=dtypes.uint8).realize()\n\n    if prepare_only:\n      return None\n\n    self.vision_output = self.vision_run(**self.vision_inputs).contiguous().realize().uop.base.buffer.numpy()\n    vision_outputs_dict = self.parser.parse_vision_outputs(self.slice_outputs(self.vision_output, self.vision_output_slices))\n\n    self.full_input_queues.enqueue({'features_buffer': vision_outputs_dict['hidden_state'], 'desire_pulse': new_desire})\n    for k in ['desire_pulse', 'features_buffer']:\n      self.numpy_inputs[k][:] = self.full_input_queues.get(k)[k]\n    self.numpy_inputs['traffic_convention'][:] = inputs['traffic_convention']\n\n    self.policy_output = self.policy_run(**self.policy_inputs).contiguous().realize().uop.base.buffer.numpy()\n    policy_outputs_dict = self.parser.parse_policy_outputs(self.slice_outputs(self.policy_output, self.policy_output_slices))\n\n    combined_outputs_dict = {**vision_outputs_dict, **policy_outputs_dict}\n    if SEND_RAW_PRED:\n      combined_outputs_dict['raw_pred'] = np.concatenate([self.vision_output.copy(), self.policy_output.copy()])\n\n    return combined_outputs_dict", "target": "model state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/constants.py:ModelConstants:0", "source": "class CLASSTOKEN:\n  # time and distance indices\n  IDX_N = 33\n  T_IDXS = [index_function(idx, max_val=10.0) for idx in range(IDX_N)]\n  X_IDXS = [index_function(idx, max_val=192.0) for idx in range(IDX_N)]\n  LEAD_T_IDXS = [0., 2., 4., 6., 8., 10.]\n  LEAD_T_OFFSETS = [0., 2., 4.]\n  META_T_IDXS = [2., 4., 6., 8., 10.]\n\n  # model inputs constants\n  N_FRAMES = 2\n  MODEL_RUN_FREQ = 20\n  MODEL_CONTEXT_FREQ = 5 # \"model_trained_fps\"\n\n  FEATURE_LEN = 512\n\n  DESIRE_LEN = 8\n  TRAFFIC_CONVENTION_LEN = 2\n  LAT_PLANNER_STATE_LEN = 4\n  LATERAL_CONTROL_PARAMS_LEN = 2\n  PREV_DESIRED_CURV_LEN = 1\n\n  # model outputs constants\n  FCW_THRESHOLDS_5MS2 = np.array([.05, .05, .15, .15, .15], dtype=np.float32)\n  FCW_THRESHOLDS_3MS2 = np.array([.7, .7], dtype=np.float32)\n  FCW_5MS2_PROBS_WIDTH = 5\n  FCW_3MS2_PROBS_WIDTH = 2\n\n  DISENGAGE_WIDTH = 5\n  POSE_WIDTH = 6\n  WIDE_FROM_DEVICE_WIDTH = 3\n  LEAD_WIDTH = 4\n  LANE_LINES_WIDTH = 2\n  ROAD_EDGES_WIDTH = 2\n  PLAN_WIDTH = 15\n  DESIRE_PRED_WIDTH = 8\n  LAT_PLANNER_SOLUTION_WIDTH = 4\n  DESIRED_CURV_WIDTH = 1\n\n  NUM_LANE_LINES = 4\n  NUM_ROAD_EDGES = 2\n\n  LEAD_TRAJ_LEN = 6\n  DESIRE_PRED_LEN = 4\n\n  PLAN_MHP_N = 5\n  LEAD_MHP_N = 2\n  PLAN_MHP_SELECTION = 1\n  LEAD_MHP_SELECTION = 3\n\n  FCW_THRESHOLD_5MS2_HIGH = 0.15\n  FCW_THRESHOLD_5MS2_LOW = 0.05\n  FCW_THRESHOLD_3MS2 = 0.7\n\n  CONFIDENCE_BUFFER_LEN = 5\n  RYG_GREEN = 0.01165\n  RYG_YELLOW = 0.06157\n\n  POLY_PATH_DEGREE = 4", "target": "model constants"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/constants.py:Plan:1", "source": "class CLASSTOKEN:\n  POSITION = slice(0, 3)\n  VELOCITY = slice(3, 6)\n  ACCELERATION = slice(6, 9)\n  T_FROM_CURRENT_EULER = slice(9, 12)\n  ORIENTATION_RATE = slice(12, 15)", "target": "plan"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/constants.py:Meta:2", "source": "class CLASSTOKEN:\n  ENGAGED = slice(0, 1)\n  # next 2, 4, 6, 8, 10 seconds\n  GAS_DISENGAGE = slice(1, 31, 6)\n  BRAKE_DISENGAGE = slice(2, 31, 6)\n  STEER_OVERRIDE = slice(3, 31, 6)\n  HARD_BRAKE_3 = slice(4, 31, 6)\n  HARD_BRAKE_4 = slice(5, 31, 6)\n  HARD_BRAKE_5 = slice(6, 31, 6)\n  # next 0, 2, 4, 6, 8, 10 seconds\n  GAS_PRESS = slice(31, 55, 4)\n  BRAKE_PRESS = slice(32, 55, 4)\n  LEFT_BLINKER = slice(33, 55, 4)\n  RIGHT_BLINKER = slice(34, 55, 4)", "target": "meta"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/tests/test_modeld.py:TestModeld:0", "source": "class CLASSTOKEN:\n\n  def setup_method(self):\n    self.vipc_server = VisionIpcServer(\"camerad\")\n    self.vipc_server.create_buffers(VisionStreamType.VISION_STREAM_ROAD, 40, CAM.width, CAM.height)\n    self.vipc_server.create_buffers(VisionStreamType.VISION_STREAM_DRIVER, 40, CAM.width, CAM.height)\n    self.vipc_server.create_buffers(VisionStreamType.VISION_STREAM_WIDE_ROAD, 40, CAM.width, CAM.height)\n    self.vipc_server.start_listener()\n    Params().put(\"CarParams\", get_demo_car_params().to_bytes())\n\n    self.sm = messaging.SubMaster(['modelV2', 'cameraOdometry'])\n    self.pm = messaging.PubMaster(['roadCameraState', 'wideRoadCameraState', 'liveCalibration'])\n\n    managed_processes['modeld'].start()\n    self.pm.wait_for_readers_to_update(\"roadCameraState\", 10)\n\n  def teardown_method(self):\n    managed_processes['modeld'].stop()\n    del self.vipc_server\n\n  def _send_frames(self, frame_id, cams=None):\n    if cams is None:\n      cams = ('roadCameraState', 'wideRoadCameraState')\n\n    cs = None\n    for cam in cams:\n      msg = messaging.new_message(cam)\n      cs = getattr(msg, cam)\n      cs.frameId = frame_id\n      cs.timestampSof = int((frame_id * DT_MDL) * 1e9)\n      cs.timestampEof = int(cs.timestampSof + (DT_MDL * 1e9))\n      cam_meta = meta_from_camera_state(cam)\n\n      self.pm.send(msg.which(), msg)\n      self.vipc_server.send(cam_meta.stream, IMG_BYTES, cs.frameId,\n                            cs.timestampSof, cs.timestampEof)\n    return cs\n\n  def _wait(self):\n    self.sm.update(5000)\n    if self.sm['modelV2'].frameId != self.sm['cameraOdometry'].frameId:\n      self.sm.update(1000)\n\n  def test_modeld(self):\n    for n in range(1, 500):\n      cs = self._send_frames(n)\n      self._wait()\n\n      mdl = self.sm['modelV2']\n      assert mdl.frameId == n\n      assert mdl.frameIdExtra == n\n      assert mdl.timestampEof == cs.timestampEof\n      assert mdl.frameAge == 0\n      assert mdl.frameDropPerc == 0\n\n      odo = self.sm['cameraOdometry']\n      assert odo.frameId == n\n      assert odo.timestampEof == cs.timestampEof\n\n  def test_dropped_frames(self):\n    \"\"\"\n      modeld should only run on consecutive road frames\n    \"\"\"\n    frame_id = -1\n    road_frames = list()\n    for n in range(1, 50):\n      if (random.random() < 0.1) and n > 3:\n        cams = random.choice([(), ('wideRoadCameraState', )])\n        self._send_frames(n, cams)\n      else:\n        self._send_frames(n)\n        road_frames.append(n)\n      self._wait()\n\n      if len(road_frames) < 3 or road_frames[-1] - road_frames[-2] == 1:\n        frame_id = road_frames[-1]\n\n      mdl = self.sm['modelV2']\n      odo = self.sm['cameraOdometry']\n      assert mdl.frameId == frame_id\n      assert mdl.frameIdExtra == frame_id\n      assert odo.frameId == frame_id\n      if n != frame_id:\n        assert not self.sm.updated['modelV2']\n        assert not self.sm.updated['cameraOdometry']", "target": "test modeld"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/soundd.py:Soundd:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.load_sounds()\n\n    self.current_alert = AudibleAlert.none\n    self.current_volume = MIN_VOLUME\n    self.current_sound_frame = 0\n\n    self.selfdrive_timeout_alert = False\n\n    self.spl_filter_weighted = FirstOrderFilter(0, 2.5, FILTER_DT, initialized=False)\n\n  def load_sounds(self):\n    self.loaded_sounds: dict[int, np.ndarray] = {}\n\n    # Load all sounds\n    for sound in sound_list:\n      filename, play_count, volume = sound_list[sound]\n\n      with wave.open(BASEDIR + \"/selfdrive/assets/sounds/\" + filename, 'r') as wavefile:\n        assert wavefile.getnchannels() == 1\n        assert wavefile.getsampwidth() == 2\n        assert wavefile.getframerate() == SAMPLE_RATE\n\n        length = wavefile.getnframes()\n        self.loaded_sounds[sound] = np.frombuffer(wavefile.readframes(length), dtype=np.int16).astype(np.float32) / (2**16/2)\n\n  def get_sound_data(self, frames): # get \"frames\" worth of data from the current alert sound, looping when required\n\n    ret = np.zeros(frames, dtype=np.float32)\n\n    if self.current_alert != AudibleAlert.none:\n      num_loops = sound_list[self.current_alert][1]\n      sound_data = self.loaded_sounds[self.current_alert]\n      written_frames = 0\n\n      current_sound_frame = self.current_sound_frame % len(sound_data)\n      loops = self.current_sound_frame // len(sound_data)\n\n      while written_frames < frames and (num_loops is None or loops < num_loops):\n        available_frames = sound_data.shape[0] - current_sound_frame\n        frames_to_write = min(available_frames, frames - written_frames)\n        ret[written_frames:written_frames+frames_to_write] = sound_data[current_sound_frame:current_sound_frame+frames_to_write]\n        written_frames += frames_to_write\n        self.current_sound_frame += frames_to_write\n\n    return ret * self.current_volume\n\n  def callback(self, data_out: np.ndarray, frames: int, time, status) -> None:\n    if status:\n      cloudlog.warning(f\"soundd stream over/underflow: {status}\")\n    data_out[:frames, 0] = self.get_sound_data(frames)\n\n  def update_alert(self, new_alert):\n    current_alert_played_once = self.current_alert == AudibleAlert.none or self.current_sound_frame > len(self.loaded_sounds[self.current_alert])\n    if self.current_alert != new_alert and (new_alert != AudibleAlert.none or current_alert_played_once):\n      self.current_alert = new_alert\n      self.current_sound_frame = 0\n\n  def get_audible_alert(self, sm):\n    if sm.updated['selfdriveState']:\n      new_alert = sm['selfdriveState'].alertSound.raw\n      self.update_alert(new_alert)\n    elif check_selfdrive_timeout_alert(sm):\n      self.update_alert(AudibleAlert.warningImmediate)\n      self.selfdrive_timeout_alert = True\n    elif self.selfdrive_timeout_alert:\n      self.update_alert(AudibleAlert.none)\n      self.selfdrive_timeout_alert = False\n\n  def calculate_volume(self, weighted_db):\n    volume = ((weighted_db - AMBIENT_DB) / DB_SCALE) * (MAX_VOLUME - MIN_VOLUME) + MIN_VOLUME\n    return math.pow(10, (np.clip(volume, MIN_VOLUME, MAX_VOLUME) - 1))\n\n  @retry(attempts=7, delay=3)\n  def get_stream(self, sd):\n    # reload sounddevice to reinitialize portaudio\n    sd._terminate()\n    sd._initialize()\n    return sd.OutputStream(channels=1, samplerate=SAMPLE_RATE, callback=self.callback, blocksize=SAMPLE_BUFFER)\n\n  def soundd_thread(self):\n    # sounddevice must be imported after forking processes\n    import sounddevice as sd\n\n    sm = messaging.SubMaster(['selfdriveState', 'soundPressure'])\n\n    with self.get_stream(sd) as stream:\n      rk = Ratekeeper(20)\n\n      cloudlog.info(f\"soundd stream started: {stream.samplerate=} {stream.channels=} {stream.dtype=} {stream.device=}, {stream.blocksize=}\")\n      while True:\n        sm.update(0)\n\n        if sm.updated['soundPressure'] and self.current_alert == AudibleAlert.none: # only update volume filter when not playing alert\n          self.spl_filter_weighted.update(sm[\"soundPressure\"].soundPressureWeightedDb)\n          self.current_volume = self.calculate_volume(float(self.spl_filter_weighted.x))\n\n        self.get_audible_alert(sm)\n\n        rk.keep_time()\n\n        assert stream.active", "target": "soundd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/ui_state.py:UIStatus:0", "source": "class CLASSTOKEN(Enum):\n  DISENGAGED = \"disengaged\"\n  ENGAGED = \"engaged\"\n  OVERRIDE = \"override\"", "target": "ui status"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/ui_state.py:UIState:1", "source": "class CLASSTOKEN:\n  _instance: 'CLASSTOKEN | None' = None\n\n  def __new__(cls):\n    if cls._instance is None:\n      cls._instance = super().__new__(cls)\n      cls._instance._initialize()\n    return cls._instance\n\n  def _initialize(self):\n    self.params = Params()\n    self.sm = messaging.SubMaster(\n      [\n        \"modelV2\",\n        \"controlsState\",\n        \"liveCalibration\",\n        \"radarState\",\n        \"deviceState\",\n        \"pandaStates\",\n        \"carParams\",\n        \"driverMonitoringState\",\n        \"carState\",\n        \"driverStateV2\",\n        \"roadCameraState\",\n        \"wideRoadCameraState\",\n        \"managerState\",\n        \"selfdriveState\",\n        \"longitudinalPlan\",\n      ]\n    )\n\n    self.prime_state = PrimeState()\n\n    # UI Status tracking\n    self.status: UIStatus = UIStatus.DISENGAGED\n    self.started_frame: int = 0\n    self._engaged_prev: bool = False\n    self._started_prev: bool = False\n\n    # Core state variables\n    self.is_metric: bool = self.params.get_bool(\"IsMetric\")\n    self.started: bool = False\n    self.ignition: bool = False\n    self.panda_type: log.PandaState.PandaType = log.PandaState.PandaType.unknown\n    self.personality: log.LongitudinalPersonality = log.LongitudinalPersonality.standard\n    self.light_sensor: float = -1.0\n\n    self._update_params()\n\n  @property\n  def engaged(self) -> bool:\n    return self.started and self.sm[\"selfdriveState\"].enabled\n\n  def is_onroad(self) -> bool:\n    return self.started\n\n  def is_offroad(self) -> bool:\n    return not self.started\n\n  def update(self) -> None:\n    self.sm.update(0)\n    self._update_state()\n    self._update_status()\n    device.update()\n\n  def _update_state(self) -> None:\n    # Handle panda states updates\n    if self.sm.updated[\"pandaStates\"]:\n      panda_states = self.sm[\"pandaStates\"]\n\n      if len(panda_states) > 0:\n        # Get panda type from first panda\n        self.panda_type = panda_states[0].pandaType\n        # Check ignition status across all pandas\n        if self.panda_type != log.PandaState.PandaType.unknown:\n          self.ignition = any(state.ignitionLine or state.ignitionCan for state in panda_states)\n    elif self.sm.frame - self.sm.recv_frame[\"pandaStates\"] > 5 * rl.get_fps():\n      self.panda_type = log.PandaState.PandaType.unknown\n\n    # Handle wide road camera state updates\n    if self.sm.updated[\"wideRoadCameraState\"]:\n      cam_state = self.sm[\"wideRoadCameraState\"]\n      self.light_sensor = max(100.0 - cam_state.exposureValPercent, 0.0)\n    elif not self.sm.alive[\"wideRoadCameraState\"] or not self.sm.valid[\"wideRoadCameraState\"]:\n      self.light_sensor = -1\n\n    # Update started state\n    self.started = self.sm[\"deviceState\"].started and self.ignition\n\n  def _update_status(self) -> None:\n    if self.started and self.sm.updated[\"selfdriveState\"]:\n      ss = self.sm[\"selfdriveState\"]\n      state = ss.state\n\n      if state in (log.SelfdriveState.OpenpilotState.preEnabled, log.SelfdriveState.OpenpilotState.overriding):\n        self.status = UIStatus.OVERRIDE\n      else:\n        self.status = UIStatus.ENGAGED if ss.enabled else UIStatus.DISENGAGED\n\n    # Check for engagement state changes\n    if self.engaged != self._engaged_prev:\n      self._engaged_prev = self.engaged\n\n    # Handle onroad/offroad transition\n    if self.started != self._started_prev or self.sm.frame == 1:\n      if self.started:\n        self.status = UIStatus.DISENGAGED\n        self.started_frame = self.sm.frame\n\n      self._started_prev = self.started\n\n  def _update_params(self) -> None:\n    try:\n      self.is_metric = self.params.get_bool(\"IsMetric\")\n    except UnknownKeyName:\n      self.is_metric = False", "target": "ui state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/ui_state.py:Device:2", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self._ignition = False\n    self._interaction_time: float = -1\n    self._interactive_timeout_callbacks: list[Callable] = []\n    self._prev_timed_out = False\n    self._awake = False\n\n    self._offroad_brightness: int = BACKLIGHT_OFFROAD\n    self._last_brightness: int = 0\n    self._brightness_filter = FirstOrderFilter(BACKLIGHT_OFFROAD, 10.00, 1 / DEFAULT_FPS)\n    self._brightness_thread: threading.Thread | None = None\n\n  def reset_interactive_timeout(self, timeout: int = -1) -> None:\n    if timeout == -1:\n      timeout = 10 if ui_state.ignition else 30\n    self._interaction_time = time.monotonic() + timeout\n\n  def add_interactive_timeout_callback(self, callback: Callable):\n    self._interactive_timeout_callbacks.append(callback)\n\n  def update(self):\n    # do initial reset\n    if self._interaction_time <= 0:\n      self.reset_interactive_timeout()\n\n    self._update_brightness()\n    self._update_wakefulness()\n\n  def set_offroad_brightness(self, brightness: int):\n    # TODO: not yet used, should be used in prime widget for QR code, etc.\n    self._offroad_brightness = min(max(brightness, 0), 100)\n\n  def _update_brightness(self):\n    clipped_brightness = self._offroad_brightness\n\n    if ui_state.started and ui_state.light_sensor >= 0:\n      clipped_brightness = ui_state.light_sensor\n\n      # CIE 1931 - https://www.photonstophotos.net/GeneralTopics/Exposure/Psychometric_Lightness_and_Gamma.htm\n      if clipped_brightness <= 8:\n        clipped_brightness = clipped_brightness / 903.3\n      else:\n        clipped_brightness = ((clipped_brightness + 16.0) / 116.0) ** 3.0\n\n      clipped_brightness = float(np.clip(100 * clipped_brightness, 10, 100))\n\n    brightness = round(self._brightness_filter.update(clipped_brightness))\n    if not self._awake:\n      brightness = 0\n\n    if brightness != self._last_brightness:\n      if self._brightness_thread is None or not self._brightness_thread.is_alive():\n        cloudlog.debug(f\"setting display brightness {brightness}\")\n        self._brightness_thread = threading.Thread(target=HARDWARE.set_screen_brightness, args=(brightness,))\n        self._brightness_thread.start()\n        self._last_brightness = brightness\n\n  def _update_wakefulness(self):\n    # Handle interactive timeout\n    ignition_just_turned_off = not ui_state.ignition and self._ignition\n    self._ignition = ui_state.ignition\n\n    if ignition_just_turned_off or any(ev.left_down for ev in gui_app.mouse_events):\n      self.reset_interactive_timeout()\n\n    interaction_timeout = time.monotonic() > self._interaction_time\n    if interaction_timeout and not self._prev_timed_out:\n      for callback in self._interactive_timeout_callbacks:\n        callback()\n    self._prev_timed_out = interaction_timeout\n\n    self._set_awake(ui_state.ignition or not interaction_timeout)\n\n  def _set_awake(self, on: bool):\n    if on != self._awake:\n      self._awake = on\n      cloudlog.debug(f\"setting display power {int(on)}\")\n      HARDWARE.set_display_power(on)", "target": "device"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/lib/prime_state.py:PrimeType:0", "source": "class CLASSTOKEN(IntEnum):\n  UNKNOWN = -2,\n  UNPAIRED = -1,\n  NONE = 0,\n  MAGENTA = 1,\n  LITE = 2,\n  BLUE = 3,\n  MAGENTA_NEW = 4,\n  PURPLE = 5,", "target": "prime type"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/lib/prime_state.py:PrimeState:1", "source": "class CLASSTOKEN:\n  FETCH_INTERVAL = 5.0  # seconds between API calls\n  API_TIMEOUT = 10.0  # seconds for API requests\n  SLEEP_INTERVAL = 0.5  # seconds to sleep between checks in the worker thread\n\n  def __init__(self):\n    self._params = Params()\n    self._lock = threading.Lock()\n    self.prime_type: PrimeType = self._load_initial_state()\n\n    self._running = False\n    self._thread = None\n    self.start()\n\n  def _load_initial_state(self) -> PrimeType:\n    prime_type_str = os.getenv(\"PRIME_TYPE\") or self._params.get(\"PrimeType\")\n    try:\n      if prime_type_str is not None:\n        return PrimeType(int(prime_type_str))\n    except (ValueError, TypeError):\n      pass\n    return PrimeType.UNKNOWN\n\n  def _fetch_prime_status(self) -> None:\n    dongle_id = self._params.get(\"DongleId\")\n    if not dongle_id or dongle_id == UNREGISTERED_DONGLE_ID:\n      return\n\n    try:\n      identity_token = get_token(dongle_id)\n      response = api_get(f\"v1.1/devices/{dongle_id}\", timeout=self.API_TIMEOUT, access_token=identity_token)\n      if response.status_code == 200:\n        data = response.json()\n        is_paired = data.get(\"is_paired\", False)\n        prime_type = data.get(\"prime_type\", 0)\n        self.set_type(PrimeType(prime_type) if is_paired else PrimeType.UNPAIRED)\n    except Exception as e:\n      cloudlog.error(f\"Failed to fetch prime status: {e}\")\n\n  def set_type(self, prime_type: PrimeType) -> None:\n    with self._lock:\n      if prime_type != self.prime_type:\n        self.prime_type = prime_type\n        self._params.put(\"PrimeType\", int(prime_type))\n        cloudlog.info(f\"Prime type updated to {prime_type}\")\n\n  def _worker_thread(self) -> None:\n    while self._running:\n      self._fetch_prime_status()\n\n      for _ in range(int(self.FETCH_INTERVAL / self.SLEEP_INTERVAL)):\n        if not self._running:\n          break\n        time.sleep(self.SLEEP_INTERVAL)\n\n  def start(self) -> None:\n    if self._thread and self._thread.is_alive():\n      return\n    self._running = True\n    self._thread = threading.Thread(target=self._worker_thread, daemon=True)\n    self._thread.start()\n\n  def stop(self) -> None:\n    self._running = False\n    if self._thread and self._thread.is_alive():\n      self._thread.join(timeout=1.0)\n\n  def get_type(self) -> PrimeType:\n    with self._lock:\n      return self.prime_type\n\n  def is_prime(self) -> bool:\n    with self._lock:\n      return bool(self.prime_type > PrimeType.NONE)\n\n  def __del__(self):\n    self.stop()", "target": "prime state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/exp_button.py:ExpButton:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self, button_size: int, icon_size: int):\n    super().__init__()\n    self._params = Params()\n    self._experimental_mode: bool = False\n    self._engageable: bool = False\n\n    # State hold mechanism\n    self._hold_duration = 2.0  # seconds\n    self._held_mode: bool | None = None\n    self._hold_end_time: float | None = None\n\n    self._white_color: rl.Color = rl.Color(255, 255, 255, 255)\n    self._black_bg: rl.Color = rl.Color(0, 0, 0, 166)\n    self._txt_wheel: rl.Texture = gui_app.texture('icons/chffr_wheel.png', icon_size, icon_size)\n    self._txt_exp: rl.Texture = gui_app.texture('icons/experimental.png', icon_size, icon_size)\n    self._rect = rl.Rectangle(0, 0, button_size, button_size)\n\n  def set_rect(self, rect: rl.Rectangle) -> None:\n    self._rect.x, self._rect.y = rect.x, rect.y\n\n  def _update_state(self) -> None:\n    selfdrive_state = ui_state.sm[\"selfdriveState\"]\n    self._experimental_mode = selfdrive_state.experimentalMode\n    self._engageable = selfdrive_state.engageable or selfdrive_state.enabled\n\n  def handle_mouse_event(self) -> bool:\n    if rl.check_collision_point_rec(rl.get_mouse_position(), self._rect):\n      if (rl.is_mouse_button_released(rl.MouseButton.MOUSE_BUTTON_LEFT) and\n          self._is_toggle_allowed()):\n        new_mode = not self._experimental_mode\n        self._params.put_bool(\"ExperimentalMode\", new_mode)\n\n        # Hold new state temporarily\n        self._held_mode = new_mode\n        self._hold_end_time = time.monotonic() + self._hold_duration\n      return True\n    return False\n\n  def _render(self, rect: rl.Rectangle) -> None:\n    center_x = int(self._rect.x + self._rect.width // 2)\n    center_y = int(self._rect.y + self._rect.height // 2)\n\n    mouse_over = rl.check_collision_point_rec(rl.get_mouse_position(), self._rect)\n    mouse_down = rl.is_mouse_button_down(rl.MouseButton.MOUSE_BUTTON_LEFT) and self.is_pressed\n    self._white_color.a = 180 if (mouse_down and mouse_over) or not self._engageable else 255\n\n    texture = self._txt_exp if self._held_or_actual_mode() else self._txt_wheel\n    rl.draw_circle(center_x, center_y, self._rect.width / 2, self._black_bg)\n    rl.draw_texture(texture, center_x - texture.width // 2, center_y - texture.height // 2, self._white_color)\n\n  def _held_or_actual_mode(self):\n    now = time.monotonic()\n    if self._hold_end_time and now < self._hold_end_time:\n      return self._held_mode\n\n    if self._hold_end_time and now >= self._hold_end_time:\n      self._hold_end_time = self._held_mode = None\n\n    return self._experimental_mode\n\n  def _is_toggle_allowed(self):\n    if not self._params.get_bool(\"ExperimentalModeConfirmed\"):\n      return False\n\n    car_params = ui_state.sm[\"carParams\"]\n    if car_params.alphaLongitudinalAvailable:\n      return self._params.get_bool(\"AlphaLongitudinalEnabled\")\n    else:\n      return car_params.openpilotLongitudinalControl", "target": "exp button"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/driver_camera_dialog.py:DriverCameraDialog:0", "source": "class CLASSTOKEN(CameraView):\n  def __init__(self):\n    super().__init__(\"camerad\", VisionStreamType.VISION_STREAM_DRIVER)\n    self.driver_state_renderer = DriverStateRenderer()\n\n  def _render(self, rect):\n    super()._render(rect)\n\n    if rl.is_mouse_button_pressed(rl.MouseButton.MOUSE_BUTTON_LEFT):\n      return 1\n\n    if not self.frame:\n      gui_label(\n        rect,\n        \"camera starting\",\n        font_size=100,\n        font_weight=FontWeight.BOLD,\n        alignment=rl.GuiTextAlignment.TEXT_ALIGN_CENTER,\n      )\n      return -1\n\n    self._draw_face_detection(rect)\n    self.driver_state_renderer.render(rect)\n\n    return -1\n\n  def _draw_face_detection(self, rect: rl.Rectangle) -> None:\n    driver_state = ui_state.sm[\"driverStateV2\"]\n    is_rhd = driver_state.wheelOnRightProb > 0.5\n    driver_data = driver_state.rightDriverData if is_rhd else driver_state.leftDriverData\n    face_detect = driver_data.faceProb > 0.7\n    if not face_detect:\n      return\n\n    # Get face position and orientation\n    face_x, face_y = driver_data.facePosition\n    face_std = max(driver_data.faceOrientationStd[0], driver_data.faceOrientationStd[1])\n    alpha = 0.7\n    if face_std > 0.15:\n      alpha = max(0.7 - (face_std - 0.15) * 3.5, 0.0)\n\n    # use approx instead of distort_points\n    # TODO: replace with distort_points\n    fbox_x = int(1080.0 - 1714.0 * face_x)\n    fbox_y = int(-135.0 + (504.0 + abs(face_x) * 112.0) + (1205.0 - abs(face_x) * 724.0) * face_y)\n    box_size = 220\n\n    line_color = rl.Color(255, 255, 255, int(alpha * 255))\n    rl.draw_rectangle_rounded_lines_ex(\n      rl.Rectangle(fbox_x - box_size / 2, fbox_y - box_size / 2, box_size, box_size),\n      35.0 / box_size / 2,\n      10,\n      10,\n      line_color,\n    )\n\n  def _calc_frame_matrix(self, rect: rl.Rectangle) -> np.ndarray:\n    driver_view_ratio = 2.0\n\n    # Get stream dimensions\n    if self.frame:\n      stream_width = self.frame.width\n      stream_height = self.frame.height\n    else:\n      # Default values if frame not available\n      stream_width = 1928\n      stream_height = 1208\n\n    yscale = stream_height * driver_view_ratio / stream_width\n    xscale = yscale * rect.height / rect.width * stream_width / stream_height\n\n    return np.array([\n      [xscale, 0.0, 0.0],\n      [0.0, yscale, 0.0],\n      [0.0, 0.0, 1.0]\n    ])", "target": "driver camera dialog"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/cameraview.py:CameraView:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self, name: str, stream_type: VisionStreamType):\n    super().__init__()\n    self._name = name\n    # Primary stream\n    self.client = VisionIpcClient(name, stream_type, conflate=True)\n    self._stream_type = stream_type\n    self.available_streams: list[VisionStreamType] = []\n\n    # Target stream for switching\n    self._target_client: VisionIpcClient | None = None\n    self._target_stream_type: VisionStreamType | None = None\n    self._switching: bool = False\n\n    self._texture_needs_update = True\n    self.last_connection_attempt: float = 0.0\n    self.shader = rl.load_shader_from_memory(VERTEX_SHADER, FRAME_FRAGMENT_SHADER)\n    self._texture1_loc: int = rl.get_shader_location(self.shader, \"texture1\") if not TICI else -1\n\n    self.frame: VisionBuf | None = None\n    self.texture_y: rl.Texture | None = None\n    self.texture_uv: rl.Texture | None = None\n\n    # EGL resources\n    self.egl_images: dict[int, EGLImage] = {}\n    self.egl_texture: rl.Texture | None = None\n\n    self._placeholder_color: rl.Color | None = None\n\n    # Initialize EGL for zero-copy rendering on TICI\n    if TICI:\n      if not init_egl():\n        raise RuntimeError(\"Failed to initialize EGL\")\n\n      # Create a 1x1 pixel placeholder texture for EGL image binding\n      temp_image = rl.gen_image_color(1, 1, rl.BLACK)\n      self.egl_texture = rl.load_texture_from_image(temp_image)\n      rl.unload_image(temp_image)\n\n  def _set_placeholder_color(self, color: rl.Color):\n    \"\"\"Set a placeholder color to be drawn when no frame is available.\"\"\"\n    self._placeholder_color = color\n\n  def switch_stream(self, stream_type: VisionStreamType) -> None:\n    if self._stream_type == stream_type:\n      return\n\n    if self._switching and self._target_stream_type == stream_type:\n      return\n\n    cloudlog.debug(f'Preparing switch from {self._stream_type} to {stream_type}')\n\n    if self._target_client:\n      del self._target_client\n\n    self._target_stream_type = stream_type\n    self._target_client = VisionIpcClient(self._name, stream_type, conflate=True)\n    self._switching = True\n\n  @property\n  def stream_type(self) -> VisionStreamType:\n    return self._stream_type\n\n  def close(self) -> None:\n    self._clear_textures()\n\n    # Clean up EGL texture\n    if TICI and self.egl_texture:\n      rl.unload_texture(self.egl_texture)\n      self.egl_texture = None\n\n    # Clean up shader\n    if self.shader and self.shader.id:\n      rl.unload_shader(self.shader)\n\n    self.client = None\n\n  def __del__(self):\n    self.close()\n\n  def _calc_frame_matrix(self, rect: rl.Rectangle) -> np.ndarray:\n    if not self.frame:\n      return np.eye(3)\n\n    # Calculate aspect ratios\n    widget_aspect_ratio = rect.width / rect.height\n    frame_aspect_ratio = self.frame.width / self.frame.height\n\n    # Calculate scaling factors to maintain aspect ratio\n    zx = min(frame_aspect_ratio / widget_aspect_ratio, 1.0)\n    zy = min(widget_aspect_ratio / frame_aspect_ratio, 1.0)\n\n    return np.array([\n      [zx, 0.0, 0.0],\n      [0.0, zy, 0.0],\n      [0.0, 0.0, 1.0]\n    ])\n\n  def _render(self, rect: rl.Rectangle):\n    if self._switching:\n      self._handle_switch()\n\n    if not self._ensure_connection():\n      self._draw_placeholder(rect)\n      return\n\n    # Try to get a new buffer without blocking\n    buffer = self.client.recv(timeout_ms=0)\n    if buffer:\n      self._texture_needs_update = True\n      self.frame = buffer\n\n    if not self.frame:\n      self._draw_placeholder(rect)\n      return\n\n    transform = self._calc_frame_matrix(rect)\n    src_rect = rl.Rectangle(0, 0, float(self.frame.width), float(self.frame.height))\n    # Flip driver camera horizontally\n    if self._stream_type == VisionStreamType.VISION_STREAM_DRIVER:\n      src_rect.width = -src_rect.width\n\n    # Calculate scale\n    scale_x = rect.width * transform[0, 0]  # zx\n    scale_y = rect.height * transform[1, 1]  # zy\n\n    # Calculate base position (centered)\n    x_offset = rect.x + (rect.width - scale_x) / 2\n    y_offset = rect.y + (rect.height - scale_y) / 2\n\n    x_offset += transform[0, 2] * rect.width / 2\n    y_offset += transform[1, 2] * rect.height / 2\n\n    dst_rect = rl.Rectangle(x_offset, y_offset, scale_x, scale_y)\n\n    # Render with appropriate method\n    if TICI:\n      self._render_egl(src_rect, dst_rect)\n    else:\n      self._render_textures(src_rect, dst_rect)\n\n  def _draw_placeholder(self, rect: rl.Rectangle):\n    if self._placeholder_color:\n      rl.draw_rectangle_rec(rect, self._placeholder_color)\n\n  def _render_egl(self, src_rect: rl.Rectangle, dst_rect: rl.Rectangle) -> None:\n    \"\"\"Render using EGL for direct buffer access\"\"\"\n    if self.frame is None or self.egl_texture is None:\n      return\n\n    idx = self.frame.idx\n    egl_image = self.egl_images.get(idx)\n\n    # Create EGL image if needed\n    if egl_image is None:\n      egl_image = create_egl_image(self.frame.width, self.frame.height, self.frame.stride, self.frame.fd, self.frame.uv_offset)\n      if egl_image:\n        self.egl_images[idx] = egl_image\n      else:\n        return\n\n    # Update texture dimensions to match current frame\n    self.egl_texture.width = self.frame.width\n    self.egl_texture.height = self.frame.height\n\n    # Bind the EGL image to our texture\n    bind_egl_image_to_texture(self.egl_texture.id, egl_image)\n\n    # Render with shader\n    rl.begin_shader_mode(self.shader)\n    rl.draw_texture_pro(self.egl_texture, src_rect, dst_rect, rl.Vector2(0, 0), 0.0, rl.WHITE)\n    rl.end_shader_mode()\n\n  def _render_textures(self, src_rect: rl.Rectangle, dst_rect: rl.Rectangle) -> None:\n    \"\"\"Render using texture copies\"\"\"\n    if not self.texture_y or not self.texture_uv or self.frame is None:\n      return\n\n    # Update textures with new frame data\n    if self._texture_needs_update:\n      y_data = self.frame.data[: self.frame.uv_offset]\n      uv_data = self.frame.data[self.frame.uv_offset:]\n\n      rl.update_texture(self.texture_y, rl.ffi.cast(\"void *\", y_data.ctypes.data))\n      rl.update_texture(self.texture_uv, rl.ffi.cast(\"void *\", uv_data.ctypes.data))\n      self._texture_needs_update = False\n\n    # Render with shader\n    rl.begin_shader_mode(self.shader)\n    rl.set_shader_value_texture(self.shader, self._texture1_loc, self.texture_uv)\n    rl.draw_texture_pro(self.texture_y, src_rect, dst_rect, rl.Vector2(0, 0), 0.0, rl.WHITE)\n    rl.end_shader_mode()\n\n  def _ensure_connection(self) -> bool:\n    if not self.client.is_connected():\n      self.frame = None\n      self.available_streams.clear()\n\n      # Throttle connection attempts\n      current_time = rl.get_time()\n      if current_time - self.last_connection_attempt < CONNECTION_RETRY_INTERVAL:\n        return False\n      self.last_connection_attempt = current_time\n\n      if not self.client.connect(False) or not self.client.num_buffers:\n        return False\n\n      cloudlog.debug(f\"Connected to {self._name} stream: {self._stream_type}, buffers: {self.client.num_buffers}\")\n      self._initialize_textures()\n      self.available_streams = self.client.available_streams(self._name, block=False)\n\n    return True\n\n  def _handle_switch(self) -> None:\n    \"\"\"Check if target stream is ready and switch immediately.\"\"\"\n    if not self._target_client or not self._switching:\n      return\n\n    # Try to connect target if needed\n    if not self._target_client.is_connected():\n      if not self._target_client.connect(False) or not self._target_client.num_buffers:\n        return\n\n      cloudlog.debug(f\"Target stream connected: {self._target_stream_type}\")\n\n    # Check if target has frames ready\n    target_frame = self._target_client.recv(timeout_ms=0)\n    if target_frame:\n      self.frame = target_frame  # Update current frame to target frame\n      self._complete_switch()\n\n  def _complete_switch(self) -> None:\n    \"\"\"Instantly switch to target stream.\"\"\"\n    cloudlog.debug(f\"Switching to {self._target_stream_type}\")\n    # Clean up current resources\n    if self.client:\n      del self.client\n\n    # Switch to target\n    self.client = self._target_client\n    self._stream_type = self._target_stream_type\n    self._texture_needs_update = True\n\n    # Reset state\n    self._target_client = None\n    self._target_stream_type = None\n    self._switching = False\n\n    # Initialize textures for new stream\n    self._initialize_textures()\n\n  def _initialize_textures(self):\n      self._clear_textures()\n      if not TICI:\n        self.texture_y = rl.load_texture_from_image(rl.Image(None, int(self.client.stride),\n          int(self.client.height), 1, rl.PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAYSCALE))\n        self.texture_uv = rl.load_texture_from_image(rl.Image(None, int(self.client.stride // 2),\n          int(self.client.height // 2), 1, rl.PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA))\n\n  def _clear_textures(self):\n    if self.texture_y and self.texture_y.id:\n      rl.unload_texture(self.texture_y)\n      self.texture_y = None\n\n    if self.texture_uv and self.texture_uv.id:\n      rl.unload_texture(self.texture_uv)\n      self.texture_uv = None\n\n    # Clean up EGL resources\n    if TICI:\n      for data in self.egl_images.values():\n        destroy_egl_image(data)\n      self.egl_images = {}", "target": "camera view"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/model_renderer.py:ModelPoints:0", "source": "class CLASSTOKEN:\n  raw_points: np.ndarray = field(default_factory=lambda: np.empty((0, 3), dtype=np.float32))\n  projected_points: np.ndarray = field(default_factory=lambda: np.empty((0, 2), dtype=np.float32))", "target": "model points"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/model_renderer.py:LeadVehicle:1", "source": "class CLASSTOKEN:\n  glow: list[float] = field(default_factory=list)\n  chevron: list[float] = field(default_factory=list)\n  fill_alpha: int = 0", "target": "lead vehicle"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/model_renderer.py:ModelRenderer:2", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._longitudinal_control = False\n    self._experimental_mode = False\n    self._blend_factor = 1.0\n    self._prev_allow_throttle = True\n    self._lane_line_probs = np.zeros(4, dtype=np.float32)\n    self._road_edge_stds = np.zeros(2, dtype=np.float32)\n    self._lead_vehicles = [LeadVehicle(), LeadVehicle()]\n    self._path_offset_z = HEIGHT_INIT[0]\n\n    # Initialize ModelPoints objects\n    self._path = ModelPoints()\n    self._lane_lines = [ModelPoints() for _ in range(4)]\n    self._road_edges = [ModelPoints() for _ in range(2)]\n    self._acceleration_x = np.empty((0,), dtype=np.float32)\n\n    # Transform matrix (3x3 for car space to screen space)\n    self._car_space_transform = np.zeros((3, 3), dtype=np.float32)\n    self._transform_dirty = True\n    self._clip_region = None\n\n    self._exp_gradient = {\n      'start': (0.0, 1.0),  # Bottom of path\n      'end': (0.0, 0.0),  # Top of path\n      'colors': [],\n      'stops': [],\n    }\n\n    # Get longitudinal control setting from car parameters\n    if car_params := Params().get(\"CarParams\"):\n      cp = messaging.log_from_bytes(car_params, car.CarParams)\n      self._longitudinal_control = cp.openpilotLongitudinalControl\n\n  def set_transform(self, transform: np.ndarray):\n    self._car_space_transform = transform.astype(np.float32)\n    self._transform_dirty = True\n\n  def _render(self, rect: rl.Rectangle):\n    sm = ui_state.sm\n\n    # Check if data is up-to-date\n    if (sm.recv_frame[\"liveCalibration\"] < ui_state.started_frame or\n        sm.recv_frame[\"modelV2\"] < ui_state.started_frame):\n      return\n\n    # Set up clipping region\n    self._clip_region = rl.Rectangle(\n      rect.x - CLIP_MARGIN, rect.y - CLIP_MARGIN, rect.width + 2 * CLIP_MARGIN, rect.height + 2 * CLIP_MARGIN\n    )\n\n    # Update state\n    self._experimental_mode = sm['selfdriveState'].experimentalMode\n\n    live_calib = sm['liveCalibration']\n    self._path_offset_z = live_calib.height[0] if live_calib.height else HEIGHT_INIT[0]\n\n    if sm.updated['carParams']:\n      self._longitudinal_control = sm['carParams'].openpilotLongitudinalControl\n\n    model = sm['modelV2']\n    radar_state = sm['radarState'] if sm.valid['radarState'] else None\n    lead_one = radar_state.leadOne if radar_state else None\n    render_lead_indicator = self._longitudinal_control and radar_state is not None\n\n    # Update model data when needed\n    model_updated = sm.updated['modelV2']\n    if model_updated or sm.updated['radarState'] or self._transform_dirty:\n      if model_updated:\n        self._update_raw_points(model)\n\n      path_x_array = self._path.raw_points[:, 0]\n      if path_x_array.size == 0:\n        return\n\n      self._update_model(lead_one, path_x_array)\n      if render_lead_indicator:\n        self._update_leads(radar_state, path_x_array)\n      self._transform_dirty = False\n\n    # Draw elements\n    self._draw_lane_lines()\n    self._draw_path(sm)\n\n    if render_lead_indicator and radar_state:\n      self._draw_lead_indicator()\n\n  def _update_raw_points(self, model):\n    \"\"\"Update raw 3D points from model data\"\"\"\n    self._path.raw_points = np.array([model.position.x, model.position.y, model.position.z], dtype=np.float32).T\n\n    for i, lane_line in enumerate(model.laneLines):\n      self._lane_lines[i].raw_points = np.array([lane_line.x, lane_line.y, lane_line.z], dtype=np.float32).T\n\n    for i, road_edge in enumerate(model.roadEdges):\n      self._road_edges[i].raw_points = np.array([road_edge.x, road_edge.y, road_edge.z], dtype=np.float32).T\n\n    self._lane_line_probs = np.array(model.laneLineProbs, dtype=np.float32)\n    self._road_edge_stds = np.array(model.roadEdgeStds, dtype=np.float32)\n    self._acceleration_x = np.array(model.acceleration.x, dtype=np.float32)\n\n  def _update_leads(self, radar_state, path_x_array):\n    \"\"\"Update positions of lead vehicles\"\"\"\n    self._lead_vehicles = [LeadVehicle(), LeadVehicle()]\n    leads = [radar_state.leadOne, radar_state.leadTwo]\n\n    for i, lead_data in enumerate(leads):\n      if lead_data and lead_data.status:\n        d_rel, y_rel, v_rel = lead_data.dRel, lead_data.yRel, lead_data.vRel\n        idx = self._get_path_length_idx(path_x_array, d_rel)\n\n        # Get z-coordinate from path at the lead vehicle position\n        z = self._path.raw_points[idx, 2] if idx < len(self._path.raw_points) else 0.0\n        point = self._map_to_screen(d_rel, -y_rel, z + self._path_offset_z)\n        if point:\n          self._lead_vehicles[i] = self._update_lead_vehicle(d_rel, v_rel, point, self._rect)\n\n  def _update_model(self, lead, path_x_array):\n    \"\"\"Update model visualization data based on model message\"\"\"\n    max_distance = np.clip(path_x_array[-1], MIN_DRAW_DISTANCE, MAX_DRAW_DISTANCE)\n    max_idx = self._get_path_length_idx(self._lane_lines[0].raw_points[:, 0], max_distance)\n\n    # Update lane lines using raw points\n    for i, lane_line in enumerate(self._lane_lines):\n      lane_line.projected_points = self._map_line_to_polygon(\n        lane_line.raw_points, 0.025 * self._lane_line_probs[i], 0.0, max_idx\n      )\n\n    # Update road edges using raw points\n    for road_edge in self._road_edges:\n      road_edge.projected_points = self._map_line_to_polygon(road_edge.raw_points, 0.025, 0.0, max_idx)\n\n    # Update path using raw points\n    if lead and lead.status:\n      lead_d = lead.dRel * 2.0\n      max_distance = np.clip(lead_d - min(lead_d * 0.35, 10.0), 0.0, max_distance)\n\n    max_idx = self._get_path_length_idx(path_x_array, max_distance)\n    self._path.projected_points = self._map_line_to_polygon(\n      self._path.raw_points, 0.9, self._path_offset_z, max_idx, allow_invert=False\n    )\n\n    self._update_experimental_gradient()\n\n  def _update_experimental_gradient(self):\n    \"\"\"Pre-calculate experimental mode gradient colors\"\"\"\n    if not self._experimental_mode:\n      return\n\n    max_len = min(len(self._path.projected_points) // 2, len(self._acceleration_x))\n\n    segment_colors = []\n    gradient_stops = []\n\n    i = 0\n    while i < max_len:\n      # Some points (screen space) are out of frame (rect space)\n      track_y = self._path.projected_points[i][1]\n      if track_y < self._rect.y or track_y > (self._rect.y + self._rect.height):\n        i += 1\n        continue\n\n      # Calculate color based on acceleration (0 is bottom, 1 is top)\n      lin_grad_point = 1 - (track_y - self._rect.y) / self._rect.height\n\n      # speed up: 120, slow down: 0\n      path_hue = np.clip(60 + self._acceleration_x[i] * 35, 0, 120)\n\n      saturation = min(abs(self._acceleration_x[i] * 1.5), 1)\n      lightness = np.interp(saturation, [0.0, 1.0], [0.95, 0.62])\n      alpha = np.interp(lin_grad_point, [0.75 / 2.0, 0.75], [0.4, 0.0])\n\n      # Use HSL to RGB conversion\n      color = self._hsla_to_color(path_hue / 360.0, saturation, lightness, alpha)\n\n      gradient_stops.append(lin_grad_point)\n      segment_colors.append(color)\n\n      # Skip a point, unless next is last\n      i += 1 + (1 if (i + 2) < max_len else 0)\n\n    # Store the gradient in the path object\n    self._exp_gradient['colors'] = segment_colors\n    self._exp_gradient['stops'] = gradient_stops\n\n  def _update_lead_vehicle(self, d_rel, v_rel, point, rect):\n    speed_buff, lead_buff = 10.0, 40.0\n\n    # Calculate fill alpha\n    fill_alpha = 0\n    if d_rel < lead_buff:\n      fill_alpha = 255 * (1.0 - (d_rel / lead_buff))\n      if v_rel < 0:\n        fill_alpha += 255 * (-1 * (v_rel / speed_buff))\n      fill_alpha = min(fill_alpha, 255)\n\n    # Calculate size and position\n    sz = np.clip((25 * 30) / (d_rel / 3 + 30), 15.0, 30.0) * 2.35\n    x = np.clip(point[0], 0.0, rect.width - sz / 2)\n    y = min(point[1], rect.height - sz * 0.6)\n\n    g_xo = sz / 5\n    g_yo = sz / 10\n\n    glow = [(x + (sz * 1.35) + g_xo, y + sz + g_yo), (x, y - g_yo), (x - (sz * 1.35) - g_xo, y + sz + g_yo)]\n    chevron = [(x + (sz * 1.25), y + sz), (x, y), (x - (sz * 1.25), y + sz)]\n\n    return LeadVehicle(glow=glow, chevron=chevron, fill_alpha=int(fill_alpha))\n\n  def _draw_lane_lines(self):\n    \"\"\"Draw lane lines and road edges\"\"\"\n    for i, lane_line in enumerate(self._lane_lines):\n      if lane_line.projected_points.size == 0:\n        continue\n\n      alpha = np.clip(self._lane_line_probs[i], 0.0, 0.7)\n      color = rl.Color(255, 255, 255, int(alpha * 255))\n      draw_polygon(self._rect, lane_line.projected_points, color)\n\n    for i, road_edge in enumerate(self._road_edges):\n      if road_edge.projected_points.size == 0:\n        continue\n\n      alpha = np.clip(1.0 - self._road_edge_stds[i], 0.0, 1.0)\n      color = rl.Color(255, 0, 0, int(alpha * 255))\n      draw_polygon(self._rect, road_edge.projected_points, color)\n\n  def _draw_path(self, sm):\n    \"\"\"Draw path with dynamic coloring based on mode and throttle state.\"\"\"\n    if not self._path.projected_points.size:\n      return\n\n    if self._experimental_mode:\n      # Draw with acceleration coloring\n      if len(self._exp_gradient['colors']) > 1:\n        draw_polygon(self._rect, self._path.projected_points, gradient=self._exp_gradient)\n      else:\n        draw_polygon(self._rect, self._path.projected_points, rl.Color(255, 255, 255, 30))\n    else:\n      # Draw with throttle/no throttle gradient\n      allow_throttle = sm['longitudinalPlan'].allowThrottle or not self._longitudinal_control\n\n      # Start transition if throttle state changes\n      if allow_throttle != self._prev_allow_throttle:\n        self._prev_allow_throttle = allow_throttle\n        self._blend_factor = max(1.0 - self._blend_factor, 0.0)\n\n      # Update blend factor\n      if self._blend_factor < 1.0:\n        self._blend_factor = min(self._blend_factor + PATH_BLEND_INCREMENT, 1.0)\n\n      begin_colors = NO_THROTTLE_COLORS if allow_throttle else THROTTLE_COLORS\n      end_colors = THROTTLE_COLORS if allow_throttle else NO_THROTTLE_COLORS\n\n      # Blend colors based on transition\n      blended_colors = self._blend_colors(begin_colors, end_colors, self._blend_factor)\n      gradient = {\n        'start': (0.0, 1.0),  # Bottom of path\n        'end': (0.0, 0.0),  # Top of path\n        'colors': blended_colors,\n        'stops': [0.0, 0.5, 1.0],\n      }\n      draw_polygon(self._rect, self._path.projected_points, gradient=gradient)\n\n  def _draw_lead_indicator(self):\n    # Draw lead vehicles if available\n    for lead in self._lead_vehicles:\n      if not lead.glow or not lead.chevron:\n        continue\n\n      rl.draw_triangle_fan(lead.glow, len(lead.glow), rl.Color(218, 202, 37, 255))\n      rl.draw_triangle_fan(lead.chevron, len(lead.chevron), rl.Color(201, 34, 49, lead.fill_alpha))\n\n  @staticmethod\n  def _get_path_length_idx(pos_x_array: np.ndarray, path_height: float) -> int:\n    \"\"\"Get the index corresponding to the given path height\"\"\"\n    if len(pos_x_array) == 0:\n      return 0\n    indices = np.where(pos_x_array <= path_height)[0]\n    return indices[-1] if indices.size > 0 else 0\n\n  def _map_to_screen(self, in_x, in_y, in_z):\n    \"\"\"Project a point in car space to screen space\"\"\"\n    input_pt = np.array([in_x, in_y, in_z])\n    pt = self._car_space_transform @ input_pt\n\n    if abs(pt[2]) < 1e-6:\n      return None\n\n    x, y = pt[0] / pt[2], pt[1] / pt[2]\n\n    clip = self._clip_region\n    if not (clip.x <= x <= clip.x + clip.width and clip.y <= y <= clip.y + clip.height):\n      return None\n\n    return (x, y)\n\n  def _map_line_to_polygon(self, line: np.ndarray, y_off: float, z_off: float, max_idx: int, allow_invert: bool = True) -> np.ndarray:\n    \"\"\"Convert 3D line to 2D polygon for rendering.\"\"\"\n    if line.shape[0] == 0:\n      return np.empty((0, 2), dtype=np.float32)\n\n    # Slice points and filter non-negative x-coordinates\n    points = line[:max_idx + 1]\n    points = points[points[:, 0] >= 0]\n    if points.shape[0] == 0:\n      return np.empty((0, 2), dtype=np.float32)\n\n    N = points.shape[0]\n    # Generate left and right 3D points in one array using broadcasting\n    offsets = np.array([[0, -y_off, z_off], [0, y_off, z_off]], dtype=np.float32)\n    points_3d = points[None, :, :] + offsets[:, None, :]  # Shape: 2xNx3\n    points_3d = points_3d.reshape(2 * N, 3)  # Shape: (2*N)x3\n\n    # Transform all points to projected space in one operation\n    proj = self._car_space_transform @ points_3d.T  # Shape: 3x(2*N)\n    proj = proj.reshape(3, 2, N)\n    left_proj = proj[:, 0, :]\n    right_proj = proj[:, 1, :]\n\n    # Filter points where z is sufficiently large\n    valid_proj = (np.abs(left_proj[2]) >= 1e-6) & (np.abs(right_proj[2]) >= 1e-6)\n    if not np.any(valid_proj):\n      return np.empty((0, 2), dtype=np.float32)\n\n    # Compute screen coordinates\n    left_screen = left_proj[:2, valid_proj] / left_proj[2, valid_proj][None, :]\n    right_screen = right_proj[:2, valid_proj] / right_proj[2, valid_proj][None, :]\n\n    # Define clip region bounds\n    clip = self._clip_region\n    x_min, x_max = clip.x, clip.x + clip.width\n    y_min, y_max = clip.y, clip.y + clip.height\n\n    # Filter points within clip region\n    left_in_clip = (\n      (left_screen[0] >= x_min) & (left_screen[0] <= x_max) &\n      (left_screen[1] >= y_min) & (left_screen[1] <= y_max)\n    )\n    right_in_clip = (\n      (right_screen[0] >= x_min) & (right_screen[0] <= x_max) &\n      (right_screen[1] >= y_min) & (right_screen[1] <= y_max)\n    )\n    both_in_clip = left_in_clip & right_in_clip\n\n    if not np.any(both_in_clip):\n      return np.empty((0, 2), dtype=np.float32)\n\n    # Select valid and clipped points\n    left_screen = left_screen[:, both_in_clip]\n    right_screen = right_screen[:, both_in_clip]\n\n    # Handle Y-coordinate inversion on hills\n    if not allow_invert and left_screen.shape[1] > 1:\n      y = left_screen[1, :]  # y-coordinates\n      keep = y == np.minimum.accumulate(y)\n      if not np.any(keep):\n        return np.empty((0, 2), dtype=np.float32)\n      left_screen = left_screen[:, keep]\n      right_screen = right_screen[:, keep]\n\n    return np.vstack((left_screen.T, right_screen[:, ::-1].T)).astype(np.float32)\n\n  @staticmethod\n  def _hsla_to_color(h, s, l, a):\n    rgb = colorsys.hls_to_rgb(h, l, s)\n    return rl.Color(\n      int(rgb[0] * 255),\n      int(rgb[1] * 255),\n      int(rgb[2] * 255),\n      int(a * 255)\n    )\n\n  @staticmethod\n  def _blend_colors(begin_colors, end_colors, t):\n    if t >= 1.0:\n      return end_colors\n    if t <= 0.0:\n      return begin_colors\n\n    inv_t = 1.0 - t\n    return [rl.Color(\n      int(inv_t * start.r + t * end.r),\n      int(inv_t * start.g + t * end.g),\n      int(inv_t * start.b + t * end.b),\n      int(inv_t * start.a + t * end.a)\n    ) for start, end in zip(begin_colors, end_colors, strict=True)]", "target": "model renderer"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/augmented_road_view.py:AugmentedRoadView:0", "source": "class CLASSTOKEN(CameraView):\n  def __init__(self, stream_type: VisionStreamType = VisionStreamType.VISION_STREAM_ROAD):\n    super().__init__(\"camerad\", stream_type)\n    self._set_placeholder_color(BORDER_COLORS[UIStatus.DISENGAGED])\n\n    self.device_camera: DeviceCameraConfig | None = None\n    self.view_from_calib = view_frame_from_device_frame.copy()\n    self.view_from_wide_calib = view_frame_from_device_frame.copy()\n\n    self._last_calib_time: float = 0\n    self._last_rect_dims = (0.0, 0.0)\n    self._last_stream_type = stream_type\n    self._cached_matrix: np.ndarray | None = None\n    self._content_rect = rl.Rectangle()\n\n    self.model_renderer = ModelRenderer()\n    self._hud_renderer = HudRenderer()\n    self.alert_renderer = AlertRenderer()\n    self.driver_state_renderer = DriverStateRenderer()\n\n    # Callbacks\n    self._click_callback: Callable | None = None\n\n  def set_callbacks(self, on_click: Callable | None = None):\n    self._click_callback = on_click\n\n  def _render(self, rect):\n    # Only render when system is started to avoid invalid data access\n    if not ui_state.started:\n      return\n\n    self._switch_stream_if_needed(ui_state.sm)\n\n    # Update calibration before rendering\n    self._update_calibration()\n\n    # Create inner content area with border padding\n    self._content_rect = rl.Rectangle(\n      rect.x + UI_BORDER_SIZE,\n      rect.y + UI_BORDER_SIZE,\n      rect.width - 2 * UI_BORDER_SIZE,\n      rect.height - 2 * UI_BORDER_SIZE,\n    )\n\n    # Draw colored border based on driving state\n    self._draw_border(rect)\n\n    # Enable scissor mode to clip all rendering within content rectangle boundaries\n    # This creates a rendering viewport that prevents graphics from drawing outside the border\n    rl.begin_scissor_mode(\n      int(self._content_rect.x),\n      int(self._content_rect.y),\n      int(self._content_rect.width),\n      int(self._content_rect.height)\n    )\n\n    # Render the base camera view\n    super()._render(rect)\n\n    # Draw all UI overlays\n    self.model_renderer.render(self._content_rect)\n    self._hud_renderer.render(self._content_rect)\n    if not self.alert_renderer.render(self._content_rect):\n      self.driver_state_renderer.render(self._content_rect)\n\n    # Custom UI extension point - add custom overlays here\n    # Use self._content_rect for positioning within camera bounds\n\n    # End clipping region\n    rl.end_scissor_mode()\n\n    # Handle click events if no HUD interaction occurred\n    if not self._hud_renderer.handle_mouse_event():\n      if self._click_callback is not None and rl.is_mouse_button_pressed(rl.MouseButton.MOUSE_BUTTON_LEFT):\n        if rl.check_collision_point_rec(rl.get_mouse_position(), self._content_rect):\n          self._click_callback()\n\n  def _handle_mouse_release(self, _):\n    pass\n\n  def _draw_border(self, rect: rl.Rectangle):\n    border_color = BORDER_COLORS.get(ui_state.status, BORDER_COLORS[UIStatus.DISENGAGED])\n    rl.draw_rectangle_lines_ex(rect, UI_BORDER_SIZE, border_color)\n\n  def _switch_stream_if_needed(self, sm):\n    if sm['selfdriveState'].experimentalMode and WIDE_CAM in self.available_streams:\n      v_ego = sm['carState'].vEgo\n      if v_ego < WIDE_CAM_MAX_SPEED:\n        target = WIDE_CAM\n      elif v_ego > ROAD_CAM_MIN_SPEED:\n        target = ROAD_CAM\n      else:\n        # Hysteresis zone - keep current stream\n        target = self.stream_type\n    else:\n      target = ROAD_CAM\n\n    if self.stream_type != target:\n      self.switch_stream(target)\n\n  def _update_calibration(self):\n    # Update device camera if not already set\n    sm = ui_state.sm\n    if not self.device_camera and sm.seen['roadCameraState'] and sm.seen['deviceState']:\n      self.device_camera = DEVICE_CAMERAS[(str(sm['deviceState'].deviceType), str(sm['roadCameraState'].sensor))]\n\n    # Check if live calibration data is available and valid\n    if not (sm.updated[\"liveCalibration\"] and sm.valid['liveCalibration']):\n      return\n\n    calib = sm['liveCalibration']\n    if len(calib.rpyCalib) != 3 or calib.calStatus != CALIBRATED:\n      return\n\n    # Update view_from_calib matrix\n    device_from_calib = rot_from_euler(calib.rpyCalib)\n    self.view_from_calib = view_frame_from_device_frame @ device_from_calib\n\n    # Update wide calibration if available\n    if hasattr(calib, 'wideFromDeviceEuler') and len(calib.wideFromDeviceEuler) == 3:\n      wide_from_device = rot_from_euler(calib.wideFromDeviceEuler)\n      self.view_from_wide_calib = view_frame_from_device_frame @ wide_from_device @ device_from_calib\n\n  def _calc_frame_matrix(self, rect: rl.Rectangle) -> np.ndarray:\n    # Check if we can use cached matrix\n    calib_time = ui_state.sm.recv_frame['liveCalibration']\n    current_dims = (self._content_rect.width, self._content_rect.height)\n    if (self._last_calib_time == calib_time and\n        self._last_rect_dims == current_dims and\n        self._last_stream_type == self.stream_type and\n        self._cached_matrix is not None):\n      return self._cached_matrix\n\n    # Get camera configuration\n    device_camera = self.device_camera or DEFAULT_DEVICE_CAMERA\n    is_wide_camera = self.stream_type == WIDE_CAM\n    intrinsic = device_camera.ecam.intrinsics if is_wide_camera else device_camera.fcam.intrinsics\n    calibration = self.view_from_wide_calib if is_wide_camera else self.view_from_calib\n    zoom = 2.0 if is_wide_camera else 1.1\n\n    # Calculate transforms for vanishing point\n    inf_point = np.array([1000.0, 0.0, 0.0])\n    calib_transform = intrinsic @ calibration\n    kep = calib_transform @ inf_point\n\n    # Calculate center points and dimensions\n    x, y = self._content_rect.x, self._content_rect.y\n    w, h = self._content_rect.width, self._content_rect.height\n    cx, cy = intrinsic[0, 2], intrinsic[1, 2]\n\n    # Calculate max allowed offsets with margins\n    margin = 5\n    max_x_offset = cx * zoom - w / 2 - margin\n    max_y_offset = cy * zoom - h / 2 - margin\n\n    # Calculate and clamp offsets to prevent out-of-bounds issues\n    try:\n      if abs(kep[2]) > 1e-6:\n        x_offset = np.clip((kep[0] / kep[2] - cx) * zoom, -max_x_offset, max_x_offset)\n        y_offset = np.clip((kep[1] / kep[2] - cy) * zoom, -max_y_offset, max_y_offset)\n      else:\n        x_offset, y_offset = 0, 0\n    except (ZeroDivisionError, OverflowError):\n      x_offset, y_offset = 0, 0\n\n    # Cache the computed transformation matrix to avoid recalculations\n    self._last_calib_time = calib_time\n    self._last_rect_dims = current_dims\n    self._last_stream_type = self.stream_type\n    self._cached_matrix = np.array([\n      [zoom * 2 * cx / w, 0, -x_offset / w * 2],\n      [0, zoom * 2 * cy / h, -y_offset / h * 2],\n      [0, 0, 1.0]\n    ])\n\n    video_transform = np.array([\n      [zoom, 0.0, (w / 2 + x - x_offset) - (cx * zoom)],\n      [0.0, zoom, (h / 2 + y - y_offset) - (cy * zoom)],\n      [0.0, 0.0, 1.0]\n    ])\n    self.model_renderer.set_transform(video_transform @ calib_transform)\n\n    return self._cached_matrix", "target": "augmented road view"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/alert_renderer.py:Alert:0", "source": "class CLASSTOKEN:\n  text1: str = \"\"\n  text2: str = \"\"\n  size: int = 0\n  status: int = 0", "target": "alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/alert_renderer.py:AlertRenderer:1", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self.font_regular: rl.Font = gui_app.font(FontWeight.NORMAL)\n    self.font_bold: rl.Font = gui_app.font(FontWeight.BOLD)\n\n  def get_alert(self, sm: messaging.SubMaster) -> Alert | None:\n    \"\"\"Generate the current alert based on selfdrive state.\"\"\"\n    ss = sm['selfdriveState']\n\n    # Check if selfdriveState messages have stopped arriving\n    if not sm.updated['selfdriveState']:\n      recv_frame = sm.recv_frame['selfdriveState']\n      time_since_onroad = (sm.frame - ui_state.started_frame) / DEFAULT_FPS\n\n      # 1. Never received selfdriveState since going onroad\n      waiting_for_startup = recv_frame < ui_state.started_frame\n      if waiting_for_startup and time_since_onroad > 5:\n        return ALERT_STARTUP_PENDING\n\n      # 2. Lost communication with selfdriveState after receiving it\n      if TICI and not waiting_for_startup:\n        ss_missing = time.monotonic() - sm.recv_time['selfdriveState']\n        if ss_missing > SELFDRIVE_STATE_TIMEOUT:\n          if ss.enabled and (ss_missing - SELFDRIVE_STATE_TIMEOUT) < SELFDRIVE_UNRESPONSIVE_TIMEOUT:\n            return ALERT_CRITICAL_TIMEOUT\n          return ALERT_CRITICAL_REBOOT\n\n    # No alert if size is none\n    if ss.alertSize == 0:\n      return None\n\n    # Return current alert\n    return Alert(text1=ss.alertText1, text2=ss.alertText2, size=ss.alertSize.raw, status=ss.alertStatus.raw)\n\n  def _render(self, rect: rl.Rectangle) -> bool:\n    alert = self.get_alert(ui_state.sm)\n    if not alert:\n      return False\n\n    alert_rect = self._get_alert_rect(rect, alert.size)\n    self._draw_background(alert_rect, alert)\n\n    text_rect = rl.Rectangle(\n      alert_rect.x + ALERT_PADDING,\n      alert_rect.y + ALERT_PADDING,\n      alert_rect.width - 2 * ALERT_PADDING,\n      alert_rect.height - 2 * ALERT_PADDING\n    )\n    self._draw_text(text_rect, alert)\n    return True\n\n  def _get_alert_rect(self, rect: rl.Rectangle, size: int) -> rl.Rectangle:\n    if size == AlertSize.full:\n      return rect\n\n    height = (ALERT_FONT_MEDIUM + 2 * ALERT_PADDING if size == AlertSize.small else\n              ALERT_FONT_BIG + ALERT_LINE_SPACING + ALERT_FONT_SMALL + 2 * ALERT_PADDING)\n\n    return rl.Rectangle(\n      rect.x + ALERT_MARGIN,\n      rect.y + rect.height - ALERT_MARGIN - height,\n      rect.width - 2 * ALERT_MARGIN,\n      height\n    )\n\n  def _draw_background(self, rect: rl.Rectangle, alert: Alert) -> None:\n    color = ALERT_COLORS.get(alert.status, ALERT_COLORS[AlertStatus.normal])\n\n    if alert.size != AlertSize.full:\n      roundness = ALERT_BORDER_RADIUS / (min(rect.width, rect.height) / 2)\n      rl.draw_rectangle_rounded(rect, roundness, 10, color)\n    else:\n      rl.draw_rectangle_rec(rect, color)\n\n  def _draw_text(self, rect: rl.Rectangle, alert: Alert) -> None:\n    if alert.size == AlertSize.small:\n      self._draw_centered(alert.text1, rect, self.font_bold, ALERT_FONT_MEDIUM)\n\n    elif alert.size == AlertSize.mid:\n      self._draw_centered(alert.text1, rect, self.font_bold, ALERT_FONT_BIG, center_y=False)\n      rect.y += ALERT_FONT_BIG + ALERT_LINE_SPACING\n      self._draw_centered(alert.text2, rect, self.font_regular, ALERT_FONT_SMALL, center_y=False)\n\n    else:\n      is_long = len(alert.text1) > 15\n      font_size1 = 132 if is_long else 177\n      align_ment = rl.GuiTextAlignment.TEXT_ALIGN_CENTER\n      vertical_align = rl.GuiTextAlignmentVertical.TEXT_ALIGN_MIDDLE\n      text_rect = rl.Rectangle(rect.x, rect.y, rect.width, rect.height // 2)\n\n      gui_text_box(text_rect, alert.text1, font_size1, alignment=align_ment, alignment_vertical=vertical_align, font_weight=FontWeight.BOLD)\n      text_rect.y = rect.y + rect.height // 2\n      gui_text_box(text_rect, alert.text2, ALERT_FONT_BIG, alignment=align_ment)\n\n  def _draw_centered(self, text, rect, font, font_size, center_y=True, color=rl.WHITE) -> None:\n    text_size = measure_text_cached(font, text, font_size)\n    x = rect.x + (rect.width - text_size.x) / 2\n    y = rect.y + ((rect.height - text_size.y) / 2 if center_y else 0)\n    rl.draw_text_ex(font, text, rl.Vector2(x, y), font_size, 0, color)", "target": "alert renderer"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/driver_state.py:ArcData:0", "source": "class CLASSTOKEN:\n  \"\"\"Data structure for arc rendering parameters.\"\"\"\n  x: float\n  y: float\n  width: float\n  height: float\n  thickness: float", "target": "arc data"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/driver_state.py:DriverStateRenderer:1", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    # Initial state with NumPy arrays\n    self.face_kpts_draw = DEFAULT_FACE_KPTS_3D.copy()\n    self.is_active = False\n    self.is_rhd = False\n    self.dm_fade_state = 0.0\n    self.last_rect: rl.Rectangle = rl.Rectangle(0, 0, 0, 0)\n    self.driver_pose_vals = np.zeros(3, dtype=np.float32)\n    self.driver_pose_diff = np.zeros(3, dtype=np.float32)\n    self.driver_pose_sins = np.zeros(3, dtype=np.float32)\n    self.driver_pose_coss = np.zeros(3, dtype=np.float32)\n    self.face_keypoints_transformed = np.zeros((DEFAULT_FACE_KPTS_3D.shape[0], 2), dtype=np.float32)\n    self.position_x: float = 0.0\n    self.position_y: float = 0.0\n    self.h_arc_data = None\n    self.v_arc_data = None\n\n    # Pre-allocate drawing arrays\n    self.face_lines = [rl.Vector2(0, 0) for _ in range(len(DEFAULT_FACE_KPTS_3D))]\n    self.h_arc_lines = [rl.Vector2(0, 0) for _ in range(ARC_POINT_COUNT)]\n    self.v_arc_lines = [rl.Vector2(0, 0) for _ in range(ARC_POINT_COUNT)]\n\n    # Load the driver face icon\n    self.dm_img = gui_app.texture(\"icons/driver_face.png\", IMG_SIZE, IMG_SIZE)\n\n    # Colors\n    self.white_color = rl.Color(255, 255, 255, 255)\n    self.arc_color = rl.Color(26, 242, 66, 255)\n    self.engaged_color = rl.Color(26, 242, 66, 255)\n    self.disengaged_color = rl.Color(139, 139, 139, 255)\n\n    self.set_visible(lambda: (ui_state.sm.recv_frame['driverStateV2'] > ui_state.started_frame and\n                              ui_state.sm.seen['driverMonitoringState']))\n\n  def _render(self, rect):\n    # Set opacity based on active state\n    opacity = 0.65 if self.is_active else 0.2\n\n    # Draw background circle\n    rl.draw_circle(int(self.position_x), int(self.position_y), BTN_SIZE // 2, rl.Color(0, 0, 0, 70))\n\n    # Draw face icon\n    icon_pos = rl.Vector2(self.position_x - self.dm_img.width // 2, self.position_y - self.dm_img.height // 2)\n    rl.draw_texture_v(self.dm_img, icon_pos, rl.Color(255, 255, 255, int(255 * opacity)))\n\n    # Draw face outline\n    self.white_color.a = int(255 * opacity)\n    rl.draw_spline_linear(self.face_lines, len(self.face_lines), 5.2, self.white_color)\n\n    # Set arc color based on engaged state\n    self.arc_color = self.engaged_color if ui_state.engaged else self.disengaged_color\n    self.arc_color.a = int(0.4 * 255 * (1.0 - self.dm_fade_state))  # Fade out when inactive\n\n    # Draw arcs\n    if self.h_arc_data:\n      rl.draw_spline_linear(self.h_arc_lines, len(self.h_arc_lines), self.h_arc_data.thickness, self.arc_color)\n    if self.v_arc_data:\n      rl.draw_spline_linear(self.v_arc_lines, len(self.v_arc_lines), self.v_arc_data.thickness, self.arc_color)\n\n  def _update_state(self):\n    \"\"\"Update the driver monitoring state based on model data\"\"\"\n    sm = ui_state.sm\n    if not sm.updated[\"driverMonitoringState\"]:\n      if (self._rect.x != self.last_rect.x or self._rect.y != self.last_rect.y or\n          self._rect.width != self.last_rect.width or self._rect.height != self.last_rect.height):\n        self._pre_calculate_drawing_elements()\n        self.last_rect = self._rect\n      return\n\n    # Get monitoring state\n    dm_state = sm[\"driverMonitoringState\"]\n    self.is_active = dm_state.isActiveMode\n    self.is_rhd = dm_state.isRHD\n\n    # Update fade state (smoother transition between active/inactive)\n    fade_target = 0.0 if self.is_active else 0.5\n    self.dm_fade_state = np.clip(self.dm_fade_state + 0.2 * (fade_target - self.dm_fade_state), 0.0, 1.0)\n\n    # Get driver orientation data from appropriate camera\n    driverstate = sm[\"driverStateV2\"]\n    driver_data = driverstate.rightDriverData if self.is_rhd else driverstate.leftDriverData\n    driver_orient = driver_data.faceOrientation\n\n    # Update pose values with scaling and smoothing\n    driver_orient = np.array(driver_orient)\n    scales = np.where(driver_orient < 0, SCALES_NEG, SCALES_POS)\n    v_this = driver_orient * scales\n    self.driver_pose_diff = np.abs(self.driver_pose_vals - v_this)\n    self.driver_pose_vals = 0.8 * v_this + 0.2 * self.driver_pose_vals  # Smooth changes\n\n    # Apply fade to rotation and compute sin/cos\n    rotation_amount = self.driver_pose_vals * (1.0 - self.dm_fade_state)\n    self.driver_pose_sins = np.sin(rotation_amount)\n    self.driver_pose_coss = np.cos(rotation_amount)\n\n    # Create rotation matrix for 3D face model\n    sin_y, sin_x, sin_z = self.driver_pose_sins\n    cos_y, cos_x, cos_z = self.driver_pose_coss\n    r_xyz = np.array(\n      [\n        [cos_x * cos_z, cos_x * sin_z, -sin_x],\n        [-sin_y * sin_x * cos_z - cos_y * sin_z, -sin_y * sin_x * sin_z + cos_y * cos_z, -sin_y * cos_x],\n        [cos_y * sin_x * cos_z - sin_y * sin_z, cos_y * sin_x * sin_z + sin_y * cos_z, cos_y * cos_x],\n      ]\n    )\n\n    # Transform face keypoints using vectorized matrix multiplication\n    self.face_kpts_draw = DEFAULT_FACE_KPTS_3D @ r_xyz.T\n    self.face_kpts_draw[:, 2] = self.face_kpts_draw[:, 2] * (1.0 - self.dm_fade_state) + 8 * self.dm_fade_state\n\n    # Pre-calculate the transformed keypoints\n    kp_depth = (self.face_kpts_draw[:, 2] - 8) / 120.0 + 1.0\n    self.face_keypoints_transformed = self.face_kpts_draw[:, :2] * kp_depth[:, None]\n\n    # Pre-calculate all drawing elements\n    self._pre_calculate_drawing_elements()\n\n  def _pre_calculate_drawing_elements(self):\n    \"\"\"Pre-calculate all drawing elements based on the current rectangle\"\"\"\n    # Calculate icon position (bottom-left or bottom-right)\n    width, height = self._rect.width, self._rect.height\n    offset = UI_BORDER_SIZE + BTN_SIZE // 2\n    self.position_x = self._rect.x + (width - offset if self.is_rhd else offset)\n    self.position_y = self._rect.y + height - offset\n\n    # Pre-calculate the face lines positions\n    positioned_keypoints = self.face_keypoints_transformed + np.array([self.position_x, self.position_y])\n    for i in range(len(positioned_keypoints)):\n      self.face_lines[i].x = positioned_keypoints[i][0]\n      self.face_lines[i].y = positioned_keypoints[i][1]\n\n    # Calculate arc dimensions based on head rotation\n    delta_x = -self.driver_pose_sins[1] * ARC_LENGTH / 2.0  # Horizontal movement\n    delta_y = -self.driver_pose_sins[0] * ARC_LENGTH / 2.0  # Vertical movement\n\n    # Horizontal arc\n    h_width = abs(delta_x)\n    self.h_arc_data = self._calculate_arc_data(\n      delta_x, h_width, self.position_x, self.position_y - ARC_LENGTH / 2,\n      self.driver_pose_sins[1], self.driver_pose_diff[1], is_horizontal=True\n    )\n\n    # Vertical arc\n    v_height = abs(delta_y)\n    self.v_arc_data = self._calculate_arc_data(\n      delta_y, v_height, self.position_x - ARC_LENGTH / 2, self.position_y,\n      self.driver_pose_sins[0], self.driver_pose_diff[0], is_horizontal=False\n    )\n\n  def _calculate_arc_data(\n    self, delta: float, size: float, x: float, y: float, sin_val: float, diff_val: float, is_horizontal: bool\n  ):\n    \"\"\"Calculate arc data and pre-compute arc points.\"\"\"\n    if size <= 0:\n      return None\n\n    thickness = ARC_THICKNESS_DEFAULT + ARC_THICKNESS_EXTEND * min(1.0, diff_val * 5.0)\n    start_angle = (90 if sin_val > 0 else -90) if is_horizontal else (0 if sin_val > 0 else 180)\n    x = min(x + delta, x) if is_horizontal else x\n    y = y if is_horizontal else min(y + delta, y)\n\n    arc_data = ArcData(\n      x=x,\n      y=y,\n      width=size if is_horizontal else ARC_LENGTH,\n      height=ARC_LENGTH if is_horizontal else size,\n      thickness=thickness,\n    )\n\n    # Pre-calculate arc points\n    angles = ARC_ANGLES + np.deg2rad(start_angle)\n\n    center_x = x + arc_data.width / 2\n    center_y = y + arc_data.height / 2\n    radius_x = arc_data.width / 2\n    radius_y = arc_data.height / 2\n\n    x_coords = center_x + np.cos(angles) * radius_x\n    y_coords = center_y + np.sin(angles) * radius_y\n\n    arc_lines = self.h_arc_lines if is_horizontal else self.v_arc_lines\n    for i, (x_coord, y_coord) in enumerate(zip(x_coords, y_coords, strict=True)):\n      arc_lines[i].x = x_coord\n      arc_lines[i].y = y_coord\n\n    return arc_data", "target": "driver state renderer"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/hud_renderer.py:UIConfig:0", "source": "class CLASSTOKEN:\n  header_height: int = 300\n  border_size: int = 30\n  button_size: int = 192\n  set_speed_width_metric: int = 200\n  set_speed_width_imperial: int = 172\n  set_speed_height: int = 204\n  wheel_icon_size: int = 144", "target": "ui config"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/hud_renderer.py:FontSizes:1", "source": "class CLASSTOKEN:\n  current_speed: int = 176\n  speed_unit: int = 66\n  max_speed: int = 40\n  set_speed: int = 90", "target": "font sizes"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/hud_renderer.py:Colors:2", "source": "class CLASSTOKEN:\n  white: rl.Color = rl.WHITE\n  disengaged: rl.Color = rl.Color(145, 155, 149, 255)\n  override: rl.Color = rl.Color(145, 155, 149, 255)  # Added\n  engaged: rl.Color = rl.Color(128, 216, 166, 255)\n  disengaged_bg: rl.Color = rl.Color(0, 0, 0, 153)\n  override_bg: rl.Color = rl.Color(145, 155, 149, 204)\n  engaged_bg: rl.Color = rl.Color(128, 216, 166, 204)\n  grey: rl.Color = rl.Color(166, 166, 166, 255)\n  dark_grey: rl.Color = rl.Color(114, 114, 114, 255)\n  black_translucent: rl.Color = rl.Color(0, 0, 0, 166)\n  white_translucent: rl.Color = rl.Color(255, 255, 255, 200)\n  border_translucent: rl.Color = rl.Color(255, 255, 255, 75)\n  header_gradient_start: rl.Color = rl.Color(0, 0, 0, 114)\n  header_gradient_end: rl.Color = rl.BLANK", "target": "colors"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/onroad/hud_renderer.py:HudRenderer:3", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    \"\"\"Initialize the HUD renderer.\"\"\"\n    self.is_cruise_set: bool = False\n    self.is_cruise_available: bool = False\n    self.set_speed: float = SET_SPEED_NA\n    self.speed: float = 0.0\n    self.v_ego_cluster_seen: bool = False\n\n    self._font_semi_bold: rl.Font = gui_app.font(FontWeight.SEMI_BOLD)\n    self._font_bold: rl.Font = gui_app.font(FontWeight.BOLD)\n    self._font_medium: rl.Font = gui_app.font(FontWeight.MEDIUM)\n\n    self._exp_button = ExpButton(UI_CONFIG.button_size, UI_CONFIG.wheel_icon_size)\n\n  def _update_state(self) -> None:\n    \"\"\"Update HUD state based on car state and controls state.\"\"\"\n    sm = ui_state.sm\n    if sm.recv_frame[\"carState\"] < ui_state.started_frame:\n      self.is_cruise_set = False\n      self.set_speed = SET_SPEED_NA\n      self.speed = 0.0\n      return\n\n    controls_state = sm['controlsState']\n    car_state = sm['carState']\n\n    v_cruise_cluster = car_state.vCruiseCluster\n    self.set_speed = (\n      controls_state.vCruiseDEPRECATED if v_cruise_cluster == 0.0 else v_cruise_cluster\n    )\n    self.is_cruise_set = 0 < self.set_speed < SET_SPEED_NA\n    self.is_cruise_available = self.set_speed != -1\n\n    if self.is_cruise_set and not ui_state.is_metric:\n      self.set_speed *= KM_TO_MILE\n\n    v_ego_cluster = car_state.vEgoCluster\n    self.v_ego_cluster_seen = self.v_ego_cluster_seen or v_ego_cluster != 0.0\n    v_ego = v_ego_cluster if self.v_ego_cluster_seen else car_state.vEgo\n    speed_conversion = CV.MS_TO_KPH if ui_state.is_metric else CV.MS_TO_MPH\n    self.speed = max(0.0, v_ego * speed_conversion)\n\n  def _render(self, rect: rl.Rectangle) -> None:\n    \"\"\"Render HUD elements to the screen.\"\"\"\n    # Draw the header background\n    rl.draw_rectangle_gradient_v(\n      int(rect.x),\n      int(rect.y),\n      int(rect.width),\n      UI_CONFIG.header_height,\n      COLORS.header_gradient_start,\n      COLORS.header_gradient_end,\n    )\n\n    if self.is_cruise_available:\n      self._draw_set_speed(rect)\n\n    self._draw_current_speed(rect)\n\n    button_x = rect.x + rect.width - UI_CONFIG.border_size - UI_CONFIG.button_size\n    button_y = rect.y + UI_CONFIG.border_size\n    self._exp_button.render(rl.Rectangle(button_x, button_y, UI_CONFIG.button_size, UI_CONFIG.button_size))\n\n  def handle_mouse_event(self) -> bool:\n    return bool(self._exp_button.handle_mouse_event())\n\n  def _draw_set_speed(self, rect: rl.Rectangle) -> None:\n    \"\"\"Draw the MAX speed indicator box.\"\"\"\n    set_speed_width = UI_CONFIG.set_speed_width_metric if ui_state.is_metric else UI_CONFIG.set_speed_width_imperial\n    x = rect.x + 60 + (UI_CONFIG.set_speed_width_imperial - set_speed_width) // 2\n    y = rect.y + 45\n\n    set_speed_rect = rl.Rectangle(x, y, set_speed_width, UI_CONFIG.set_speed_height)\n    rl.draw_rectangle_rounded(set_speed_rect, 0.2, 30, COLORS.black_translucent)\n    rl.draw_rectangle_rounded_lines_ex(set_speed_rect, 0.2, 30, 6, COLORS.border_translucent)\n\n    max_color = COLORS.grey\n    set_speed_color = COLORS.dark_grey\n    if self.is_cruise_set:\n      set_speed_color = COLORS.white\n      if ui_state.status == UIStatus.ENGAGED:\n        max_color = COLORS.engaged\n      elif ui_state.status == UIStatus.DISENGAGED:\n        max_color = COLORS.disengaged\n      elif ui_state.status == UIStatus.OVERRIDE:\n        max_color = COLORS.override\n\n    max_text = \"MAX\"\n    max_text_width = measure_text_cached(self._font_semi_bold, max_text, FONT_SIZES.max_speed).x\n    rl.draw_text_ex(\n      self._font_semi_bold,\n      max_text,\n      rl.Vector2(x + (set_speed_width - max_text_width) / 2, y + 27),\n      FONT_SIZES.max_speed,\n      0,\n      max_color,\n    )\n\n    set_speed_text = CRUISE_DISABLED_CHAR if not self.is_cruise_set else str(round(self.set_speed))\n    speed_text_width = measure_text_cached(self._font_bold, set_speed_text, FONT_SIZES.set_speed).x\n    rl.draw_text_ex(\n      self._font_bold,\n      set_speed_text,\n      rl.Vector2(x + (set_speed_width - speed_text_width) / 2, y + 77),\n      FONT_SIZES.set_speed,\n      0,\n      set_speed_color,\n    )\n\n  def _draw_current_speed(self, rect: rl.Rectangle) -> None:\n    \"\"\"Draw the current vehicle speed and unit.\"\"\"\n    speed_text = str(round(self.speed))\n    speed_text_size = measure_text_cached(self._font_bold, speed_text, FONT_SIZES.current_speed)\n    speed_pos = rl.Vector2(rect.x + rect.width / 2 - speed_text_size.x / 2, 180 - speed_text_size.y / 2)\n    rl.draw_text_ex(self._font_bold, speed_text, speed_pos, FONT_SIZES.current_speed, 0, COLORS.white)\n\n    unit_text = \"km/h\" if ui_state.is_metric else \"mph\"\n    unit_text_size = measure_text_cached(self._font_medium, unit_text, FONT_SIZES.speed_unit)\n    unit_pos = rl.Vector2(rect.x + rect.width / 2 - unit_text_size.x / 2, 290 - unit_text_size.y / 2)\n    rl.draw_text_ex(self._font_medium, unit_text, unit_pos, FONT_SIZES.speed_unit, 0, COLORS.white_translucent)", "target": "hud renderer"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/tests/test_translations.py:TestTranslations:0", "source": "class CLASSTOKEN:\n  name: str\n  file: str\n\n  @staticmethod\n  def _read_translation_file(path, file):\n    tr_file = os.path.join(path, f\"{file}.ts\")\n    with open(tr_file) as f:\n      return f.read()\n\n  def test_missing_translation_files(self):\n    assert os.path.exists(os.path.join(TRANSLATIONS_DIR, f\"{self.file}.ts\")), \\\n                    f\"{self.name} has no XML translation file, run selfdrive/ui/update_translations.py\"\n\n  @pytest.mark.skip(\"Only test unfinished translations before going to release\")\n  def test_unfinished_translations(self):\n    cur_translations = self._read_translation_file(TRANSLATIONS_DIR, self.file)\n    assert UNFINISHED_TRANSLATION_TAG not in cur_translations, \\\n                    f\"{self.file} ({self.name}) translation file has unfinished translations. Finish translations or mark them as completed in Qt Linguist\"\n\n  def test_vanished_translations(self):\n    cur_translations = self._read_translation_file(TRANSLATIONS_DIR, self.file)\n    assert \"<translation type=\\\"vanished\\\">\" not in cur_translations, \\\n                    f\"{self.file} ({self.name}) translation file has obsolete translations. Run selfdrive/ui/update_translations.py --vanish to remove them\"\n\n  def test_finished_translations(self):\n    \"\"\"\n      Tests ran on each translation marked \"finished\"\n      Plural:\n      - that any numerus (plural) translations have all plural forms non-empty\n      - that the correct format specifier is used (%n)\n      Non-plural:\n      - that translation is not empty\n      - that translation format arguments are consistent\n    \"\"\"\n    tr_xml = ET.parse(os.path.join(TRANSLATIONS_DIR, f\"{self.file}.ts\"))\n\n    for context in tr_xml.getroot():\n      for message in context.iterfind(\"message\"):\n        translation = message.find(\"translation\")\n        source_text = message.find(\"source\").text\n\n        # Do not test unfinished translations\n        if translation.get(\"type\") == \"unfinished\":\n          continue\n\n        if message.get(\"numerus\") == \"yes\":\n          numerusform = [t.text for t in translation.findall(\"numerusform\")]\n\n          for nf in numerusform:\n            assert nf is not None, f\"Ensure all plural translation forms are completed: {source_text}\"\n            assert \"%n\" in nf, \"Ensure numerus argument (%n) exists in translation.\"\n            assert FORMAT_ARG.search(nf) is None, f\"Plural translations must use %n, not %1, %2, etc.: {numerusform}\"\n\n        else:\n          assert translation.text is not None, f\"Ensure translation is completed: {source_text}\"\n\n          source_args = FORMAT_ARG.findall(source_text)\n          translation_args = FORMAT_ARG.findall(translation.text)\n          assert sorted(source_args) == sorted(translation_args), \\\n                           f\"Ensure format arguments are consistent: `{source_text}` vs. `{translation.text}`\"\n\n  def test_no_locations(self):\n    for line in self._read_translation_file(TRANSLATIONS_DIR, self.file).splitlines():\n      assert not line.strip().startswith(LOCATION_TAG), \\\n                       f\"Line contains location tag: {line.strip()}, remove all line numbers.\"\n\n  def test_entities_error(self):\n    cur_translations = self._read_translation_file(TRANSLATIONS_DIR, self.file)\n    matches = re.findall(r'@(\\w+);', cur_translations)\n    assert len(matches) == 0, f\"The string(s) {matches} were found with '@' instead of '&'\"\n\n  def test_bad_language(self):\n    IGNORED_WORDS = {'pédale'}\n\n    match = re.search(r'_([a-zA-Z]{2,3})', self.file)\n    assert match, f\"{self.name} - could not parse language\"\n\n    try:\n      response = requests.get(\n        f\"https://raw.githubusercontent.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/master/{match.group(1)}\"\n      )\n      response.raise_for_status()\n    except requests.exceptions.HTTPError as e:\n      if e.response is not None and e.response.status_code == 429:\n        pytest.skip(\"word list rate limited\")\n      raise\n\n    banned_words = {line.strip() for line in response.text.splitlines()}\n\n    for context in ET.parse(os.path.join(TRANSLATIONS_DIR, f\"{self.file}.ts\")).getroot():\n      for message in context.iterfind(\"message\"):\n        translation = message.find(\"translation\")\n        if translation.get(\"type\") == \"unfinished\":\n          continue\n\n        translation_text = \" \".join([t.text for t in translation.findall(\"numerusform\")]) if message.get(\"numerus\") == \"yes\" else translation.text\n\n        if not translation_text:\n          continue\n\n        words = set(translation_text.translate(str.maketrans('', '', string.punctuation + '%n')).lower().split())\n        bad_words_found = words & (banned_words - IGNORED_WORDS)\n        assert not bad_words_found, f\"Bad language found in {self.name}: '{translation_text}'. Bad word(s): {', '.join(bad_words_found)}\"", "target": "test translations"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/tests/test_feedbackd.py:TestFeedbackd:0", "source": "class CLASSTOKEN:\n  def setup_method(self):\n    self.pm = messaging.PubMaster(['carState', 'rawAudioData'])\n    self.sm = messaging.SubMaster(['audioFeedback'])\n\n  def _send_lkas_button(self, pressed: bool):\n    msg = messaging.new_message('carState')\n    msg.carState.canValid = True\n    msg.carState.buttonEvents = [{'type': car.CarState.ButtonEvent.Type.lkas, 'pressed': pressed}]\n    self.pm.send('carState', msg)\n\n  def _send_audio_data(self, count: int = 5):\n    for _ in range(count):\n      audio_msg = messaging.new_message('rawAudioData')\n      audio_msg.rawAudioData.data = bytes(1600)  # 800 samples of int16\n      audio_msg.rawAudioData.sampleRate = 16000\n      self.pm.send('rawAudioData', audio_msg)\n      self.sm.update(timeout=100)\n\n  @pytest.mark.parametrize(\"record_feedback\", [False, True])\n  def test_audio_feedback(self, record_feedback):\n    Params().put_bool(\"RecordAudioFeedback\", record_feedback)\n\n    managed_processes[\"feedbackd\"].start()\n    assert self.pm.wait_for_readers_to_update('carState', timeout=5)\n    assert self.pm.wait_for_readers_to_update('rawAudioData', timeout=5)\n\n    self._send_lkas_button(pressed=True)\n    self._send_audio_data()\n    self._send_lkas_button(pressed=False)\n    self._send_audio_data()\n\n    if record_feedback:\n      assert self.sm.updated['audioFeedback'], \"audioFeedback should be published when enabled\"\n    else:\n      assert not self.sm.updated['audioFeedback'], \"audioFeedback should not be published when disabled\"\n\n    self._send_lkas_button(pressed=True)\n    self._send_audio_data()\n    self._send_lkas_button(pressed=False)\n    self._send_audio_data()\n\n    assert not self.sm.updated['audioFeedback'], \"audioFeedback should not be published after second press\"\n\n    managed_processes[\"feedbackd\"].stop()", "target": "test feedbackd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/tests/test_soundd.py:TestSoundd:0", "source": "class CLASSTOKEN:\n  def test_check_selfdrive_timeout_alert(self):\n    sm = SubMaster(['selfdriveState'])\n    pm = PubMaster(['selfdriveState'])\n\n    for _ in range(100):\n      cs = messaging.new_message('selfdriveState')\n      cs.selfdriveState.enabled = True\n\n      pm.send(\"selfdriveState\", cs)\n\n      time.sleep(0.01)\n\n      sm.update(0)\n\n      assert not check_selfdrive_timeout_alert(sm)\n\n    for _ in range(SELFDRIVE_STATE_TIMEOUT * 110):\n      sm.update(0)\n      time.sleep(0.01)\n\n    assert check_selfdrive_timeout_alert(sm)", "target": "test soundd"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/tests/test_ui/run.py:TestUI:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    os.environ[\"SCALE\"] = \"1\"\n    sys.modules[\"mouseinfo\"] = False\n\n  def setup(self):\n    self.pm = PubMaster(list(DATA.keys()))\n    DATA['deviceState'].deviceState.networkType = log.DeviceState.NetworkType.wifi\n    DATA['deviceState'].deviceState.lastAthenaPingTime = 0\n    for _ in range(10):\n      self.pm.send('deviceState', DATA['deviceState'])\n      DATA['deviceState'].clear_write_flag()\n      time.sleep(0.05)\n    try:\n      self.ui = pywinctl.getWindowsWithTitle(\"ui\")[0]\n    except Exception as e:\n      print(f\"failed to find ui window, assuming that it's in the top left (for Xvfb) {e}\")\n      self.ui = namedtuple(\"bb\", [\"left\", \"top\", \"width\", \"height\"])(0,0,2160,1080)\n\n  def screenshot(self, name):\n    im = pyautogui.screenshot(SCREENSHOTS_DIR / f\"{name}.png\", region=(self.ui.left, self.ui.top, self.ui.width, self.ui.height))\n    assert im.width == 2160\n    assert im.height == 1080\n\n  def click(self, x, y, *args, **kwargs):\n    pyautogui.click(self.ui.left + x, self.ui.top + y, *args, **kwargs)\n    time.sleep(UI_DELAY) # give enough time for the UI to react\n\n  @with_processes([\"ui\"])\n  def test_ui(self, name, setup_case):\n    self.setup()\n    setup_case(self.click, self.pm)\n    self.screenshot(name)", "target": "test ui"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/pairing_dialog.py:PairingDialog:0", "source": "class CLASSTOKEN:\n  \"\"\"Dialog for device pairing with QR code.\"\"\"\n\n  QR_REFRESH_INTERVAL = 300  # 5 minutes in seconds\n\n  def __init__(self):\n    self.params = Params()\n    self.qr_texture: rl.Texture | None = None\n    self.last_qr_generation = 0\n\n  def _get_pairing_url(self) -> str:\n    try:\n      dongle_id = self.params.get(\"DongleId\") or \"\"\n      token = Api(dongle_id).get_token({'pair': True})\n    except Exception as e:\n      cloudlog.warning(f\"Failed to get pairing token: {e}\")\n      token = \"\"\n    return f\"https://connect.comma.ai/?pair={token}\"\n\n  def _generate_qr_code(self) -> None:\n    try:\n      qr = qrcode.QRCode(version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4)\n      qr.add_data(self._get_pairing_url())\n      qr.make(fit=True)\n\n      pil_img = qr.make_image(fill_color=\"black\", back_color=\"white\").convert('RGBA')\n      img_array = np.array(pil_img, dtype=np.uint8)\n\n      if self.qr_texture and self.qr_texture.id != 0:\n        rl.unload_texture(self.qr_texture)\n\n      rl_image = rl.Image()\n      rl_image.data = rl.ffi.cast(\"void *\", img_array.ctypes.data)\n      rl_image.width = pil_img.width\n      rl_image.height = pil_img.height\n      rl_image.mipmaps = 1\n      rl_image.format = rl.PixelFormat.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8\n\n      self.qr_texture = rl.load_texture_from_image(rl_image)\n    except Exception as e:\n      cloudlog.warning(f\"QR code generation failed: {e}\")\n      self.qr_texture = None\n\n  def _check_qr_refresh(self) -> None:\n    current_time = time.monotonic()\n    if current_time - self.last_qr_generation >= self.QR_REFRESH_INTERVAL:\n      self._generate_qr_code()\n      self.last_qr_generation = current_time\n\n  def render(self, rect: rl.Rectangle) -> int:\n    rl.clear_background(rl.Color(224, 224, 224, 255))\n\n    self._check_qr_refresh()\n\n    margin = 70\n    content_rect = rl.Rectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin)\n    y = content_rect.y\n\n    # Close button\n    close_size = 80\n    close_icon = gui_app.texture(\"icons/close.png\", close_size, close_size)\n    close_rect = rl.Rectangle(content_rect.x, y, close_size, close_size)\n\n    mouse_pos = rl.get_mouse_position()\n    is_hover = rl.check_collision_point_rec(mouse_pos, close_rect)\n    is_pressed = rl.is_mouse_button_down(rl.MouseButton.MOUSE_BUTTON_LEFT)\n    is_released = rl.is_mouse_button_released(rl.MouseButton.MOUSE_BUTTON_LEFT)\n\n    color = rl.Color(180, 180, 180, 150) if (is_hover and is_pressed) else rl.WHITE\n    rl.draw_texture(close_icon, int(content_rect.x), int(y), color)\n\n    if (is_hover and is_released) or rl.is_key_pressed(rl.KeyboardKey.KEY_ESCAPE):\n      return 1\n\n    y += close_size + 40\n\n    # Title\n    title = \"Pair your device to your comma account\"\n    title_font = gui_app.font(FontWeight.NORMAL)\n    left_width = int(content_rect.width * 0.5 - 15)\n\n    title_wrapped = wrap_text(title_font, title, 75, left_width)\n    rl.draw_text_ex(title_font, \"\\n\".join(title_wrapped), rl.Vector2(content_rect.x, y), 75, 0.0, rl.BLACK)\n    y += len(title_wrapped) * 75 + 60\n\n    # Two columns: instructions and QR code\n    remaining_height = content_rect.height - (y - content_rect.y)\n    right_width = content_rect.width // 2 - 20\n\n    # Instructions\n    self._render_instructions(rl.Rectangle(content_rect.x, y, left_width, remaining_height))\n\n    # QR code\n    qr_size = min(right_width, content_rect.height) - 40\n    qr_x = content_rect.x + left_width + 40 + (right_width - qr_size) // 2\n    qr_y = content_rect.y\n    self._render_qr_code(rl.Rectangle(qr_x, qr_y, qr_size, qr_size))\n\n    return -1\n\n  def _render_instructions(self, rect: rl.Rectangle) -> None:\n    instructions = [\n      \"Go to https://connect.comma.ai on your phone\",\n      \"Click \\\"add new device\\\" and scan the QR code on the right\",\n      \"Bookmark connect.comma.ai to your home screen to use it like an app\",\n    ]\n\n    font = gui_app.font(FontWeight.BOLD)\n    y = rect.y\n\n    for i, text in enumerate(instructions):\n      circle_radius = 25\n      circle_x = rect.x + circle_radius + 15\n      text_x = rect.x + circle_radius * 2 + 40\n      text_width = rect.width - (circle_radius * 2 + 40)\n\n      wrapped = wrap_text(font, text, 47, int(text_width))\n      text_height = len(wrapped) * 47\n      circle_y = y + text_height // 2\n\n      # Circle and number\n      rl.draw_circle(int(circle_x), int(circle_y), circle_radius, rl.Color(70, 70, 70, 255))\n      number = str(i + 1)\n      number_width = measure_text_cached(font, number, 30).x\n      rl.draw_text(number, int(circle_x - number_width // 2), int(circle_y - 15), 30, rl.WHITE)\n\n      # Text\n      rl.draw_text_ex(font, \"\\n\".join(wrapped), rl.Vector2(text_x, y), 47, 0.0, rl.BLACK)\n      y += text_height + 50\n\n  def _render_qr_code(self, rect: rl.Rectangle) -> None:\n    if not self.qr_texture:\n      rl.draw_rectangle_rounded(rect, 0.1, 20, rl.Color(240, 240, 240, 255))\n      error_font = gui_app.font(FontWeight.BOLD)\n      rl.draw_text_ex(\n        error_font, \"QR Code Error\", rl.Vector2(rect.x + 20, rect.y + rect.height // 2 - 15), 30, 0.0, rl.RED\n      )\n      return\n\n    source = rl.Rectangle(0, 0, self.qr_texture.width, self.qr_texture.height)\n    rl.draw_texture_pro(self.qr_texture, source, rect, rl.Vector2(0, 0), 0, rl.WHITE)\n\n  def __del__(self):\n    if self.qr_texture and self.qr_texture.id != 0:\n      rl.unload_texture(self.qr_texture)", "target": "pairing dialog"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/ssh_key.py:SshKeyActionState:0", "source": "class CLASSTOKEN(Enum):\n  LOADING = \"LOADING\"\n  ADD = \"ADD\"\n  REMOVE = \"REMOVE\"", "target": "ssh key action state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/ssh_key.py:SshKeyAction:1", "source": "class CLASSTOKEN(ItemAction):\n  HTTP_TIMEOUT = 15  # seconds\n  MAX_WIDTH = 500\n\n  def __init__(self):\n    super().__init__(self.MAX_WIDTH, True)\n\n    self._keyboard = Keyboard()\n    self._params = Params()\n    self._error_message: str = \"\"\n    self._text_font = gui_app.font(FontWeight.MEDIUM)\n\n    self._refresh_state()\n\n  def _refresh_state(self):\n    self._username = self._params.get(\"GithubUsername\")\n    self._state = SshKeyActionState.REMOVE if self._params.get(\"GithubSshKeys\") else SshKeyActionState.ADD\n\n  def _render(self, rect: rl.Rectangle) -> bool:\n    # Show error dialog if there's an error\n    if self._error_message:\n      message = copy.copy(self._error_message)\n      gui_app.set_modal_overlay(lambda: alert_dialog(message))\n      self._username = \"\"\n      self._error_message = \"\"\n\n    # Draw username if exists\n    if self._username:\n      text_size = measure_text_cached(self._text_font, self._username, BUTTON_FONT_SIZE)\n      rl.draw_text_ex(\n        self._text_font,\n        self._username,\n        (rect.x + rect.width - BUTTON_WIDTH - text_size.x - 30, rect.y + (rect.height - text_size.y) / 2),\n        BUTTON_FONT_SIZE,\n        1.0,\n        rl.WHITE,\n      )\n\n    # Draw button\n    if gui_button(\n      rl.Rectangle(\n        rect.x + rect.width - BUTTON_WIDTH, rect.y + (rect.height - BUTTON_HEIGHT) / 2, BUTTON_WIDTH, BUTTON_HEIGHT\n      ),\n      self._state.value,\n      is_enabled=self._state != SshKeyActionState.LOADING,\n      border_radius=BUTTON_BORDER_RADIUS,\n      font_size=BUTTON_FONT_SIZE,\n      button_style=ButtonStyle.LIST_ACTION,\n    ):\n      self._handle_button_click()\n      return True\n    return False\n\n  def _handle_button_click(self):\n    if self._state == SshKeyActionState.ADD:\n      self._keyboard.clear()\n      self._keyboard.set_title(\"Enter your GitHub username\")\n      gui_app.set_modal_overlay(self._keyboard, callback=self._on_username_submit)\n    elif self._state == SshKeyActionState.REMOVE:\n      self._params.remove(\"GithubUsername\")\n      self._params.remove(\"GithubSshKeys\")\n      self._refresh_state()\n\n  def _on_username_submit(self, result: DialogResult):\n    if result != DialogResult.CONFIRM:\n      return\n\n    username = self._keyboard.text.strip()\n    if not username:\n      return\n\n    self._state = SshKeyActionState.LOADING\n    threading.Thread(target=lambda: self._fetch_ssh_key(username), daemon=True).start()\n\n  def _fetch_ssh_key(self, username: str):\n    try:\n      url = f\"https://github.com/{username}.keys\"\n      response = requests.get(url, timeout=self.HTTP_TIMEOUT)\n      response.raise_for_status()\n      keys = response.text.strip()\n      if not keys:\n        raise requests.exceptions.HTTPError(\"No SSH keys found\")\n\n      # Success - save keys\n      self._params.put(\"GithubUsername\", username)\n      self._params.put(\"GithubSshKeys\", keys)\n      self._state = SshKeyActionState.REMOVE\n      self._username = username\n\n    except requests.exceptions.Timeout:\n      self._error_message = \"Request timed out\"\n      self._state = SshKeyActionState.ADD\n    except Exception:\n      self._error_message = f\"No SSH keys found for user '{username}'\"\n      self._state = SshKeyActionState.ADD", "target": "ssh key action"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:AlertColors:0", "source": "class CLASSTOKEN:\n  HIGH_SEVERITY = rl.Color(226, 44, 44, 255)\n  LOW_SEVERITY = rl.Color(41, 41, 41, 255)\n  BACKGROUND = rl.Color(57, 57, 57, 255)\n  BUTTON = rl.WHITE\n  BUTTON_TEXT = rl.BLACK\n  SNOOZE_BG = rl.Color(79, 79, 79, 255)\n  TEXT = rl.WHITE", "target": "alert colors"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:AlertConstants:1", "source": "class CLASSTOKEN:\n  BUTTON_SIZE = (400, 125)\n  SNOOZE_BUTTON_SIZE = (550, 125)\n  REBOOT_BUTTON_SIZE = (600, 125)\n  MARGIN = 50\n  SPACING = 30\n  FONT_SIZE = 48\n  BORDER_RADIUS = 30\n  ALERT_HEIGHT = 120\n  ALERT_SPACING = 20", "target": "alert constants"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:AlertData:2", "source": "class CLASSTOKEN:\n  key: str\n  text: str\n  severity: int\n  visible: bool = False", "target": "alert data"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:AbstractAlert:3", "source": "class CLASSTOKEN(Widget, ABC):\n  def __init__(self, has_reboot_btn: bool = False):\n    super().__init__()\n    self.params = Params()\n    self.has_reboot_btn = has_reboot_btn\n    self.dismiss_callback: Callable | None = None\n\n    self.dismiss_btn_rect = rl.Rectangle(0, 0, *AlertConstants.BUTTON_SIZE)\n    self.snooze_btn_rect = rl.Rectangle(0, 0, *AlertConstants.SNOOZE_BUTTON_SIZE)\n    self.reboot_btn_rect = rl.Rectangle(0, 0, *AlertConstants.REBOOT_BUTTON_SIZE)\n\n    self.snooze_visible = False\n    self.content_rect = rl.Rectangle(0, 0, 0, 0)\n    self.scroll_panel_rect = rl.Rectangle(0, 0, 0, 0)\n    self.scroll_panel = GuiScrollPanel()\n\n  def set_dismiss_callback(self, callback: Callable):\n    self.dismiss_callback = callback\n\n  @abstractmethod\n  def refresh(self) -> bool:\n    pass\n\n  @abstractmethod\n  def get_content_height(self) -> float:\n    pass\n\n  def handle_input(self, mouse_pos: rl.Vector2, mouse_clicked: bool) -> bool:\n    if not mouse_clicked or not self.scroll_panel.is_touch_valid():\n      return False\n\n    if rl.check_collision_point_rec(mouse_pos, self.dismiss_btn_rect):\n      if self.dismiss_callback:\n        self.dismiss_callback()\n      return True\n\n    if self.snooze_visible and rl.check_collision_point_rec(mouse_pos, self.snooze_btn_rect):\n      self.params.put_bool(\"SnoozeUpdate\", True)\n      if self.dismiss_callback:\n        self.dismiss_callback()\n      return True\n\n    if self.has_reboot_btn and rl.check_collision_point_rec(mouse_pos, self.reboot_btn_rect):\n      HARDWARE.reboot()\n      return True\n\n    return False\n\n  def _render(self, rect: rl.Rectangle):\n    rl.draw_rectangle_rounded(rect, AlertConstants.BORDER_RADIUS / rect.width, 10, AlertColors.BACKGROUND)\n\n    footer_height = AlertConstants.BUTTON_SIZE[1] + AlertConstants.SPACING\n    content_height = rect.height - 2 * AlertConstants.MARGIN - footer_height\n\n    self.content_rect = rl.Rectangle(\n      rect.x + AlertConstants.MARGIN,\n      rect.y + AlertConstants.MARGIN,\n      rect.width - 2 * AlertConstants.MARGIN,\n      content_height,\n    )\n    self.scroll_panel_rect = rl.Rectangle(\n      self.content_rect.x, self.content_rect.y, self.content_rect.width, self.content_rect.height\n    )\n\n    self._render_scrollable_content()\n    self._render_footer(rect)\n\n  def _render_scrollable_content(self):\n    content_total_height = self.get_content_height()\n    content_bounds = rl.Rectangle(0, 0, self.scroll_panel_rect.width, content_total_height)\n    scroll_offset = self.scroll_panel.handle_scroll(self.scroll_panel_rect, content_bounds)\n\n    rl.begin_scissor_mode(\n      int(self.scroll_panel_rect.x),\n      int(self.scroll_panel_rect.y),\n      int(self.scroll_panel_rect.width),\n      int(self.scroll_panel_rect.height),\n    )\n\n    content_rect_with_scroll = rl.Rectangle(\n      self.scroll_panel_rect.x,\n      self.scroll_panel_rect.y + scroll_offset.y,\n      self.scroll_panel_rect.width,\n      content_total_height,\n    )\n\n    self._render_content(content_rect_with_scroll)\n    rl.end_scissor_mode()\n\n  @abstractmethod\n  def _render_content(self, content_rect: rl.Rectangle):\n    pass\n\n  def _render_footer(self, rect: rl.Rectangle):\n    footer_y = rect.y + rect.height - AlertConstants.MARGIN - AlertConstants.BUTTON_SIZE[1]\n    font = gui_app.font(FontWeight.MEDIUM)\n\n    self.dismiss_btn_rect.x = rect.x + AlertConstants.MARGIN\n    self.dismiss_btn_rect.y = footer_y\n    rl.draw_rectangle_rounded(self.dismiss_btn_rect, 0.3, 10, AlertColors.BUTTON)\n\n    text = \"Close\"\n    text_width = measure_text_cached(font, text, AlertConstants.FONT_SIZE).x\n    text_x = self.dismiss_btn_rect.x + (AlertConstants.BUTTON_SIZE[0] - text_width) // 2\n    text_y = self.dismiss_btn_rect.y + (AlertConstants.BUTTON_SIZE[1] - AlertConstants.FONT_SIZE) // 2\n    rl.draw_text_ex(\n      font, text, rl.Vector2(int(text_x), int(text_y)), AlertConstants.FONT_SIZE, 0, AlertColors.BUTTON_TEXT\n    )\n\n    if self.snooze_visible:\n      self.snooze_btn_rect.x = rect.x + rect.width - AlertConstants.MARGIN - AlertConstants.SNOOZE_BUTTON_SIZE[0]\n      self.snooze_btn_rect.y = footer_y\n      rl.draw_rectangle_rounded(self.snooze_btn_rect, 0.3, 10, AlertColors.SNOOZE_BG)\n\n      text = \"Snooze Update\"\n      text_width = measure_text_cached(font, text, AlertConstants.FONT_SIZE).x\n      text_x = self.snooze_btn_rect.x + (AlertConstants.SNOOZE_BUTTON_SIZE[0] - text_width) // 2\n      text_y = self.snooze_btn_rect.y + (AlertConstants.SNOOZE_BUTTON_SIZE[1] - AlertConstants.FONT_SIZE) // 2\n      rl.draw_text_ex(font, text, rl.Vector2(int(text_x), int(text_y)), AlertConstants.FONT_SIZE, 0, AlertColors.TEXT)\n\n    elif self.has_reboot_btn:\n      self.reboot_btn_rect.x = rect.x + rect.width - AlertConstants.MARGIN - AlertConstants.REBOOT_BUTTON_SIZE[0]\n      self.reboot_btn_rect.y = footer_y\n      rl.draw_rectangle_rounded(self.reboot_btn_rect, 0.3, 10, AlertColors.BUTTON)\n\n      text = \"Reboot and Update\"\n      text_width = measure_text_cached(font, text, AlertConstants.FONT_SIZE).x\n      text_x = self.reboot_btn_rect.x + (AlertConstants.REBOOT_BUTTON_SIZE[0] - text_width) // 2\n      text_y = self.reboot_btn_rect.y + (AlertConstants.REBOOT_BUTTON_SIZE[1] - AlertConstants.FONT_SIZE) // 2\n      rl.draw_text_ex(\n        font, text, rl.Vector2(int(text_x), int(text_y)), AlertConstants.FONT_SIZE, 0, AlertColors.BUTTON_TEXT\n      )", "target": "abstract alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:OffroadAlert:4", "source": "class CLASSTOKEN(AbstractAlert):\n  def __init__(self):\n    super().__init__(has_reboot_btn=False)\n    self.sorted_alerts: list[AlertData] = []\n\n  def refresh(self):\n    if not self.sorted_alerts:\n      self._build_alerts()\n\n    active_count = 0\n    connectivity_needed = False\n\n    for alert_data in self.sorted_alerts:\n      text = \"\"\n      alert_json = self.params.get(alert_data.key)\n\n      if alert_json:\n        text = alert_json.get(\"text\", \"\").replace(\"{}\", alert_json.get(\"extra\", \"\"))\n\n      alert_data.text = text\n      alert_data.visible = bool(text)\n\n      if alert_data.visible:\n        active_count += 1\n\n      if alert_data.key == \"Offroad_ConnectivityNeeded\" and alert_data.visible:\n        connectivity_needed = True\n\n    self.snooze_visible = connectivity_needed\n    return active_count\n\n  def get_content_height(self) -> float:\n    if not self.sorted_alerts:\n      return 0\n\n    total_height = 20\n    font = gui_app.font(FontWeight.NORMAL)\n\n    for alert_data in self.sorted_alerts:\n      if not alert_data.visible:\n        continue\n\n      text_width = int(self.content_rect.width - 90)\n      wrapped_lines = wrap_text(font, alert_data.text, AlertConstants.FONT_SIZE, text_width)\n      line_count = len(wrapped_lines)\n      text_height = line_count * (AlertConstants.FONT_SIZE + 5)\n      alert_item_height = max(text_height + 40, AlertConstants.ALERT_HEIGHT)\n      total_height += alert_item_height + AlertConstants.ALERT_SPACING\n\n    if total_height > 20:\n      total_height = total_height - AlertConstants.ALERT_SPACING + 20\n\n    return total_height\n\n  def _build_alerts(self):\n    self.sorted_alerts = []\n    try:\n      with open(\"../selfdrived/alerts_offroad.json\", \"rb\") as f:\n        alerts_config = json.load(f)\n        for key, config in sorted(alerts_config.items(), key=lambda x: x[1].get(\"severity\", 0), reverse=True):\n          severity = config.get(\"severity\", 0)\n          alert_data = AlertData(key=key, text=\"\", severity=severity)\n          self.sorted_alerts.append(alert_data)\n    except (FileNotFoundError, json.JSONDecodeError):\n      pass\n\n  def _render_content(self, content_rect: rl.Rectangle):\n    y_offset = 20\n    font = gui_app.font(FontWeight.NORMAL)\n\n    for alert_data in self.sorted_alerts:\n      if not alert_data.visible:\n        continue\n\n      bg_color = AlertColors.HIGH_SEVERITY if alert_data.severity > 0 else AlertColors.LOW_SEVERITY\n      text_width = int(content_rect.width - 90)\n      wrapped_lines = wrap_text(font, alert_data.text, AlertConstants.FONT_SIZE, text_width)\n      line_count = len(wrapped_lines)\n      text_height = line_count * (AlertConstants.FONT_SIZE + 5)\n      alert_item_height = max(text_height + 40, AlertConstants.ALERT_HEIGHT)\n\n      alert_rect = rl.Rectangle(\n        content_rect.x + 10,\n        content_rect.y + y_offset,\n        content_rect.width - 30,\n        alert_item_height,\n      )\n\n      rl.draw_rectangle_rounded(alert_rect, 0.2, 10, bg_color)\n\n      text_x = alert_rect.x + 30\n      text_y = alert_rect.y + 20\n\n      for i, line in enumerate(wrapped_lines):\n        rl.draw_text_ex(\n          font,\n          line,\n          rl.Vector2(text_x, text_y + i * (AlertConstants.FONT_SIZE + 5)),\n          AlertConstants.FONT_SIZE,\n          0,\n          AlertColors.TEXT,\n        )\n\n      y_offset += alert_item_height + AlertConstants.ALERT_SPACING", "target": "offroad alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/offroad_alerts.py:UpdateAlert:5", "source": "class CLASSTOKEN(AbstractAlert):\n  def __init__(self):\n    super().__init__(has_reboot_btn=True)\n    self.release_notes = \"\"\n    self._wrapped_release_notes = \"\"\n    self._cached_content_height: float = 0.0\n\n  def refresh(self) -> bool:\n    update_available: bool = self.params.get_bool(\"UpdateAvailable\")\n    if update_available:\n      self.release_notes = self.params.get(\"UpdaterNewReleaseNotes\")\n      self._cached_content_height = 0\n\n    return update_available\n\n  def get_content_height(self) -> float:\n    if not self.release_notes:\n      return 100\n\n    if self._cached_content_height == 0:\n      self._wrapped_release_notes = self.release_notes\n      size = measure_text_cached(gui_app.font(FontWeight.NORMAL), self._wrapped_release_notes, AlertConstants.FONT_SIZE)\n      self._cached_content_height = max(size.y + 60, 100)\n\n    return self._cached_content_height\n\n  def _render_content(self, content_rect: rl.Rectangle):\n    if self.release_notes:\n      rl.draw_text_ex(\n        gui_app.font(FontWeight.NORMAL),\n        self._wrapped_release_notes,\n        rl.Vector2(content_rect.x + 30, content_rect.y + 30),\n        AlertConstants.FONT_SIZE,\n        0.0,\n        AlertColors.TEXT,\n      )\n    else:\n      no_notes_text = \"No release notes available.\"\n      text_width = rl.measure_text(no_notes_text, AlertConstants.FONT_SIZE)\n      text_x = content_rect.x + (content_rect.width - text_width) // 2\n      text_y = content_rect.y + 50\n      rl.draw_text(no_notes_text, int(text_x), int(text_y), AlertConstants.FONT_SIZE, AlertColors.TEXT)", "target": "update alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/prime.py:PrimeWidget:0", "source": "class CLASSTOKEN(Widget):\n  \"\"\"Widget for displaying comma prime subscription status\"\"\"\n\n  PRIME_BG_COLOR = rl.Color(51, 51, 51, 255)\n\n  def _render(self, rect):\n    if ui_state.prime_state.is_prime():\n      self._render_for_prime_user(rect)\n    else:\n      self._render_for_non_prime_users(rect)\n\n  def _render_for_non_prime_users(self, rect: rl.Rectangle):\n    \"\"\"Renders the advertisement for non-Prime users.\"\"\"\n\n    rl.draw_rectangle_rounded(rect, 0.02, 10, self.PRIME_BG_COLOR)\n\n    # Layout\n    x, y = rect.x + 80, rect.y + 90\n    w = rect.width - 160\n\n    # Title\n    gui_label(rl.Rectangle(x, y, w, 90), \"Upgrade Now\", 75, font_weight=FontWeight.BOLD)\n\n    # Description with wrapping\n    desc_y = y + 140\n    font = gui_app.font(FontWeight.LIGHT)\n    wrapped_text = \"\\n\".join(wrap_text(font, \"Become a comma prime member at connect.comma.ai\", 56, int(w)))\n    text_size = measure_text_cached(font, wrapped_text, 56)\n    rl.draw_text_ex(font, wrapped_text, rl.Vector2(x, desc_y), 56, 0, rl.WHITE)\n\n    # Features section\n    features_y = desc_y + text_size.y + 50\n    gui_label(rl.Rectangle(x, features_y, w, 50), \"PRIME FEATURES:\", 41, font_weight=FontWeight.BOLD)\n\n    # Feature list\n    features = [\"Remote access\", \"24/7 LTE connectivity\", \"1 year of drive storage\", \"Remote snapshots\"]\n    for i, feature in enumerate(features):\n      item_y = features_y + 80 + i * 65\n      gui_label(rl.Rectangle(x, item_y, 50, 60), \"✓\", 50, color=rl.Color(70, 91, 234, 255))\n      gui_label(rl.Rectangle(x + 60, item_y, w - 60, 60), feature, 50)\n\n  def _render_for_prime_user(self, rect: rl.Rectangle):\n    \"\"\"Renders the prime user widget with subscription status.\"\"\"\n\n    rl.draw_rectangle_rounded(rl.Rectangle(rect.x, rect.y, rect.width, 230), 0.02, 10, self.PRIME_BG_COLOR)\n\n    x = rect.x + 56\n    y = rect.y + 40\n\n    font = gui_app.font(FontWeight.BOLD)\n    rl.draw_text_ex(font, \"✓ SUBSCRIBED\", rl.Vector2(x, y), 41, 0, rl.Color(134, 255, 78, 255))\n    rl.draw_text_ex(font, \"comma prime\", rl.Vector2(x, y + 61), 75, 0, rl.WHITE)", "target": "prime widget"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/exp_mode_button.py:ExperimentalModeButton:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n\n    self.img_width = 80\n    self.horizontal_padding = 50\n    self.button_height = 125\n\n    self.params = Params()\n    self.experimental_mode = self.params.get_bool(\"ExperimentalMode\")\n\n    self.chill_pixmap = gui_app.texture(\"icons/couch.png\", self.img_width, self.img_width)\n    self.experimental_pixmap = gui_app.texture(\"icons/experimental_grey.png\", self.img_width, self.img_width)\n\n  def _get_gradient_colors(self):\n    alpha = 0xCC if self.is_pressed else 0xFF\n\n    if self.experimental_mode:\n      return rl.Color(255, 155, 63, alpha), rl.Color(219, 56, 34, alpha)\n    else:\n      return rl.Color(20, 255, 171, alpha), rl.Color(35, 149, 255, alpha)\n\n  def _draw_gradient_background(self, rect):\n    start_color, end_color = self._get_gradient_colors()\n    rl.draw_rectangle_gradient_h(int(rect.x), int(rect.y), int(rect.width), int(rect.height),\n                                 start_color, end_color)\n\n  def _handle_mouse_release(self, mouse_pos):\n    self.experimental_mode = not self.experimental_mode\n    # TODO: Opening settings for ExperimentalMode\n    self.params.put_bool(\"ExperimentalMode\", self.experimental_mode)\n\n  def _render(self, rect):\n    rl.draw_rectangle_rounded(rect, 0.08, 20, rl.WHITE)\n\n    rl.begin_scissor_mode(int(rect.x), int(rect.y), int(rect.width), int(rect.height))\n    self._draw_gradient_background(rect)\n    rl.end_scissor_mode()\n\n    # Draw vertical separator line\n    line_x = rect.x + rect.width - self.img_width - (2 * self.horizontal_padding)\n    separator_color = rl.Color(0, 0, 0, 77)  # 0x4d = 77\n    rl.draw_line_ex(rl.Vector2(line_x, rect.y), rl.Vector2(line_x, rect.y + rect.height), 3, separator_color)\n\n    # Draw text label (left aligned)\n    text = \"EXPERIMENTAL MODE ON\" if self.experimental_mode else \"CHILL MODE ON\"\n    text_x = rect.x + self.horizontal_padding\n    text_y = rect.y + rect.height / 2 - 45 // 2  # Center vertically\n\n    rl.draw_text_ex(gui_app.font(FontWeight.NORMAL), text, rl.Vector2(int(text_x), int(text_y)), 45, 0, rl.BLACK)\n\n    # Draw icon (right aligned)\n    icon_x = rect.x + rect.width - self.horizontal_padding - self.img_width\n    icon_y = rect.y + (rect.height - self.img_width) / 2\n    icon_rect = rl.Rectangle(icon_x, icon_y, self.img_width, self.img_width)\n\n    # Draw current mode icon\n    current_icon = self.experimental_pixmap if self.experimental_mode else self.chill_pixmap\n    source_rect = rl.Rectangle(0, 0, current_icon.width, current_icon.height)\n    rl.draw_texture_pro(current_icon, source_rect, icon_rect, rl.Vector2(0, 0), 0, rl.WHITE)", "target": "experimental mode button"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/setup.py:SetupWidget:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._open_settings_callback = None\n    self._pairing_dialog: PairingDialog | None = None\n\n  def set_open_settings_callback(self, callback):\n    self._open_settings_callback = callback\n\n  def _render(self, rect: rl.Rectangle):\n    if ui_state.prime_state.get_type() == PrimeType.UNPAIRED:\n      self._render_registration(rect)\n    else:\n      self._render_firehose_prompt(rect)\n\n  def _render_registration(self, rect: rl.Rectangle):\n    \"\"\"Render registration prompt.\"\"\"\n\n    rl.draw_rectangle_rounded(rl.Rectangle(rect.x, rect.y, rect.width, 590), 0.02, 20, rl.Color(51, 51, 51, 255))\n\n    x = rect.x + 64\n    y = rect.y + 48\n    w = rect.width - 128\n\n    # Title\n    font = gui_app.font(FontWeight.BOLD)\n    rl.draw_text_ex(font, \"Finish Setup\", rl.Vector2(x, y), 75, 0, rl.WHITE)\n    y += 113  # 75 + 38 spacing\n\n    # Description\n    desc = \"Pair your device with comma connect (connect.comma.ai) and claim your comma prime offer.\"\n    light_font = gui_app.font(FontWeight.LIGHT)\n    wrapped = wrap_text(light_font, desc, 50, int(w))\n    for line in wrapped:\n      rl.draw_text_ex(light_font, line, rl.Vector2(x, y), 50, 0, rl.WHITE)\n      y += 50\n\n    button_rect = rl.Rectangle(x, y + 50, w, 128)\n    if gui_button(button_rect, \"Pair device\", button_style=ButtonStyle.PRIMARY):\n      self._show_pairing()\n\n  def _render_firehose_prompt(self, rect: rl.Rectangle):\n    \"\"\"Render firehose prompt widget.\"\"\"\n\n    rl.draw_rectangle_rounded(rl.Rectangle(rect.x, rect.y, rect.width, 450), 0.02, 20, rl.Color(51, 51, 51, 255))\n\n    # Content margins (56, 40, 56, 40)\n    x = rect.x + 56\n    y = rect.y + 40\n    w = rect.width - 112\n    spacing = 42\n\n    # Title with fire emojis\n    title_font = gui_app.font(FontWeight.MEDIUM)\n    title_text = \"Firehose Mode\"\n    rl.draw_text_ex(title_font, title_text, rl.Vector2(x, y), 64, 0, rl.WHITE)\n    y += 64 + spacing\n\n    # Description\n    desc_font = gui_app.font(FontWeight.NORMAL)\n    desc_text = \"Maximize your training data uploads to improve openpilot's driving models.\"\n    wrapped_desc = wrap_text(desc_font, desc_text, 40, int(w))\n\n    for line in wrapped_desc:\n      rl.draw_text_ex(desc_font, line, rl.Vector2(x, y), 40, 0, rl.WHITE)\n      y += 40\n\n    y += spacing\n\n    # Open button\n    button_height = 48 + 64  # font size + padding\n    button_rect = rl.Rectangle(x, y, w, button_height)\n    if gui_button(button_rect, \"Open\", button_style=ButtonStyle.PRIMARY):\n      if self._open_settings_callback:\n        self._open_settings_callback()\n\n  def _show_pairing(self):\n    if not self._pairing_dialog:\n      self._pairing_dialog = PairingDialog()\n    gui_app.set_modal_overlay(self._pairing_dialog, lambda result: setattr(self, '_pairing_dialog', None))\n\n  def __del__(self):\n    if self._pairing_dialog:\n      del self._pairing_dialog", "target": "setup widget"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/home.py:HomeLayoutState:0", "source": "class CLASSTOKEN(IntEnum):\n  HOME = 0\n  UPDATE = 1\n  ALERTS = 2", "target": "home layout state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/home.py:HomeLayout:1", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self.params = Params()\n\n    self.update_alert = UpdateAlert()\n    self.offroad_alert = OffroadAlert()\n\n    self.current_state = HomeLayoutState.HOME\n    self.last_refresh = 0\n    self.settings_callback: callable | None = None\n\n    self.update_available = False\n    self.alert_count = 0\n\n    self.header_rect = rl.Rectangle(0, 0, 0, 0)\n    self.content_rect = rl.Rectangle(0, 0, 0, 0)\n    self.left_column_rect = rl.Rectangle(0, 0, 0, 0)\n    self.right_column_rect = rl.Rectangle(0, 0, 0, 0)\n\n    self.update_notif_rect = rl.Rectangle(0, 0, 200, HEADER_HEIGHT - 10)\n    self.alert_notif_rect = rl.Rectangle(0, 0, 220, HEADER_HEIGHT - 10)\n\n    self._prime_widget = PrimeWidget()\n    self._setup_widget = SetupWidget()\n\n    self._exp_mode_button = ExperimentalModeButton()\n    self._setup_callbacks()\n\n  def _setup_callbacks(self):\n    self.update_alert.set_dismiss_callback(lambda: self._set_state(HomeLayoutState.HOME))\n    self.offroad_alert.set_dismiss_callback(lambda: self._set_state(HomeLayoutState.HOME))\n\n  def set_settings_callback(self, callback: Callable):\n    self.settings_callback = callback\n\n  def _set_state(self, state: HomeLayoutState):\n    self.current_state = state\n\n  def _render(self, rect: rl.Rectangle):\n    current_time = time.monotonic()\n    if current_time - self.last_refresh >= REFRESH_INTERVAL:\n      self._refresh()\n      self.last_refresh = current_time\n\n    self._handle_input()\n    self._render_header()\n\n    # Render content based on current state\n    if self.current_state == HomeLayoutState.HOME:\n      self._render_home_content()\n    elif self.current_state == HomeLayoutState.UPDATE:\n      self._render_update_view()\n    elif self.current_state == HomeLayoutState.ALERTS:\n      self._render_alerts_view()\n\n  def _update_layout_rects(self):\n    self.header_rect = rl.Rectangle(\n      self._rect.x + CONTENT_MARGIN, self._rect.y + CONTENT_MARGIN, self._rect.width - 2 * CONTENT_MARGIN, HEADER_HEIGHT\n    )\n\n    content_y = self._rect.y + CONTENT_MARGIN + HEADER_HEIGHT + SPACING\n    content_height = self._rect.height - CONTENT_MARGIN - HEADER_HEIGHT - SPACING - CONTENT_MARGIN\n\n    self.content_rect = rl.Rectangle(\n      self._rect.x + CONTENT_MARGIN, content_y, self._rect.width - 2 * CONTENT_MARGIN, content_height\n    )\n\n    left_width = self.content_rect.width - RIGHT_COLUMN_WIDTH - SPACING\n\n    self.left_column_rect = rl.Rectangle(self.content_rect.x, self.content_rect.y, left_width, self.content_rect.height)\n\n    self.right_column_rect = rl.Rectangle(\n      self.content_rect.x + left_width + SPACING, self.content_rect.y, RIGHT_COLUMN_WIDTH, self.content_rect.height\n    )\n\n    self.update_notif_rect.x = self.header_rect.x\n    self.update_notif_rect.y = self.header_rect.y + (self.header_rect.height - 60) // 2\n\n    notif_x = self.header_rect.x + (220 if self.update_available else 0)\n    self.alert_notif_rect.x = notif_x\n    self.alert_notif_rect.y = self.header_rect.y + (self.header_rect.height - 60) // 2\n\n  def _handle_input(self):\n    if not rl.is_mouse_button_pressed(rl.MouseButton.MOUSE_BUTTON_LEFT):\n      return\n\n    mouse_pos = rl.get_mouse_position()\n\n    if self.update_available and rl.check_collision_point_rec(mouse_pos, self.update_notif_rect):\n      self._set_state(HomeLayoutState.UPDATE)\n      return\n\n    if self.alert_count > 0 and rl.check_collision_point_rec(mouse_pos, self.alert_notif_rect):\n      self._set_state(HomeLayoutState.ALERTS)\n      return\n\n    # Content area input handling\n    if self.current_state == HomeLayoutState.UPDATE:\n      self.update_alert.handle_input(mouse_pos, True)\n    elif self.current_state == HomeLayoutState.ALERTS:\n      self.offroad_alert.handle_input(mouse_pos, True)\n\n  def _render_header(self):\n    font = gui_app.font(FontWeight.MEDIUM)\n\n    # Update notification button\n    if self.update_available:\n      # Highlight if currently viewing updates\n      highlight_color = rl.Color(255, 140, 40, 255) if self.current_state == HomeLayoutState.UPDATE else rl.Color(255, 102, 0, 255)\n      rl.draw_rectangle_rounded(self.update_notif_rect, 0.3, 10, highlight_color)\n\n      text = \"UPDATE\"\n      text_width = measure_text_cached(font, text, HEAD_BUTTON_FONT_SIZE).x\n      text_x = self.update_notif_rect.x + (self.update_notif_rect.width - text_width) // 2\n      text_y = self.update_notif_rect.y + (self.update_notif_rect.height - HEAD_BUTTON_FONT_SIZE) // 2\n      rl.draw_text_ex(font, text, rl.Vector2(int(text_x), int(text_y)), HEAD_BUTTON_FONT_SIZE, 0, rl.WHITE)\n\n    # Alert notification button\n    if self.alert_count > 0:\n      # Highlight if currently viewing alerts\n      highlight_color = rl.Color(255, 70, 70, 255) if self.current_state == HomeLayoutState.ALERTS else rl.Color(226, 44, 44, 255)\n      rl.draw_rectangle_rounded(self.alert_notif_rect, 0.3, 10, highlight_color)\n\n      alert_text = f\"{self.alert_count} ALERT{'S' if self.alert_count > 1 else ''}\"\n      text_width = measure_text_cached(font, alert_text, HEAD_BUTTON_FONT_SIZE).x\n      text_x = self.alert_notif_rect.x + (self.alert_notif_rect.width - text_width) // 2\n      text_y = self.alert_notif_rect.y + (self.alert_notif_rect.height - HEAD_BUTTON_FONT_SIZE) // 2\n      rl.draw_text_ex(font, alert_text, rl.Vector2(int(text_x), int(text_y)), HEAD_BUTTON_FONT_SIZE, 0, rl.WHITE)\n\n    # Version text (right aligned)\n    version_text = self._get_version_text()\n    text_width = measure_text_cached(gui_app.font(FontWeight.NORMAL), version_text, 48).x\n    version_x = self.header_rect.x + self.header_rect.width - text_width\n    version_y = self.header_rect.y + (self.header_rect.height - 48) // 2\n    rl.draw_text_ex(gui_app.font(FontWeight.NORMAL), version_text, rl.Vector2(int(version_x), int(version_y)), 48, 0, DEFAULT_TEXT_COLOR)\n\n  def _render_home_content(self):\n    self._render_left_column()\n    self._render_right_column()\n\n  def _render_update_view(self):\n    self.update_alert.render(self.content_rect)\n\n  def _render_alerts_view(self):\n    self.offroad_alert.render(self.content_rect)\n\n  def _render_left_column(self):\n    self._prime_widget.render(self.left_column_rect)\n\n  def _render_right_column(self):\n    exp_height = 125\n    exp_rect = rl.Rectangle(\n      self.right_column_rect.x, self.right_column_rect.y, self.right_column_rect.width, exp_height\n    )\n    self._exp_mode_button.render(exp_rect)\n\n    setup_rect = rl.Rectangle(\n      self.right_column_rect.x,\n      self.right_column_rect.y + exp_height + SPACING,\n      self.right_column_rect.width,\n      self.right_column_rect.height - exp_height - SPACING,\n    )\n    self._setup_widget.render(setup_rect)\n\n  def _refresh(self):\n    # TODO: implement _update_state with a timer\n    self.update_available = self.update_alert.refresh()\n    self.alert_count = self.offroad_alert.refresh()\n    self._update_state_priority(self.update_available, self.alert_count > 0)\n\n  def _update_state_priority(self, update_available: bool, alerts_present: bool):\n    current_state = self.current_state\n\n    if not update_available and not alerts_present:\n      self.current_state = HomeLayoutState.HOME\n    elif update_available and (current_state == HomeLayoutState.HOME or (not alerts_present and current_state == HomeLayoutState.ALERTS)):\n      self.current_state = HomeLayoutState.UPDATE\n    elif alerts_present and (current_state == HomeLayoutState.HOME or (not update_available and current_state == HomeLayoutState.UPDATE)):\n      self.current_state = HomeLayoutState.ALERTS\n\n  def _get_version_text(self) -> str:\n    brand = \"openpilot\"\n    description = self.params.get(\"UpdaterCurrentDescription\")\n    return f\"{brand} {description}\" if description else brand", "target": "home layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/sidebar.py:Colors:0", "source": "class CLASSTOKEN:\n  SIDEBAR_BG = rl.Color(57, 57, 57, 255)\n  WHITE = rl.WHITE\n  WHITE_DIM = rl.Color(255, 255, 255, 85)\n  GRAY = rl.Color(84, 84, 84, 255)\n\n  # Status colors\n  GOOD = rl.WHITE\n  WARNING = rl.Color(218, 202, 37, 255)\n  DANGER = rl.Color(201, 34, 49, 255)\n\n  # UI elements\n  METRIC_BORDER = rl.Color(255, 255, 255, 85)\n  BUTTON_NORMAL = rl.WHITE\n  BUTTON_PRESSED = rl.Color(255, 255, 255, 166)", "target": "colors"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/sidebar.py:MetricData:1", "source": "class CLASSTOKEN:\n  label: str\n  value: str\n  color: rl.Color\n\n  def update(self, label: str, value: str, color: rl.Color):\n    self.label = label\n    self.value = value\n    self.color = color", "target": "metric data"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/sidebar.py:Sidebar:2", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._net_type = NETWORK_TYPES.get(NetworkType.none)\n    self._net_strength = 0\n\n    self._temp_status = MetricData(\"TEMP\", \"GOOD\", Colors.GOOD)\n    self._panda_status = MetricData(\"VEHICLE\", \"ONLINE\", Colors.GOOD)\n    self._connect_status = MetricData(\"CONNECT\", \"OFFLINE\", Colors.WARNING)\n\n    self._home_img = gui_app.texture(\"images/button_home.png\", HOME_BTN.width, HOME_BTN.height)\n    self._flag_img = gui_app.texture(\"images/button_flag.png\", HOME_BTN.width, HOME_BTN.height)\n    self._settings_img = gui_app.texture(\"images/button_settings.png\", SETTINGS_BTN.width, SETTINGS_BTN.height)\n    self._font_regular = gui_app.font(FontWeight.NORMAL)\n    self._font_bold = gui_app.font(FontWeight.SEMI_BOLD)\n\n    # Callbacks\n    self._on_settings_click: Callable | None = None\n    self._on_flag_click: Callable | None = None\n\n  def set_callbacks(self, on_settings: Callable | None = None, on_flag: Callable | None = None):\n    self._on_settings_click = on_settings\n    self._on_flag_click = on_flag\n\n  def _render(self, rect: rl.Rectangle):\n    # Background\n    rl.draw_rectangle_rec(rect, Colors.SIDEBAR_BG)\n\n    self._draw_buttons(rect)\n    self._draw_network_indicator(rect)\n    self._draw_metrics(rect)\n\n  def _update_state(self):\n    sm = ui_state.sm\n    if not sm.updated['deviceState']:\n      return\n\n    device_state = sm['deviceState']\n\n    self._update_network_status(device_state)\n    self._update_temperature_status(device_state)\n    self._update_connection_status(device_state)\n    self._update_panda_status()\n\n  def _update_network_status(self, device_state):\n    self._net_type = NETWORK_TYPES.get(device_state.networkType.raw, \"Unknown\")\n    strength = device_state.networkStrength\n    self._net_strength = max(0, min(5, strength.raw + 1)) if strength > 0 else 0\n\n  def _update_temperature_status(self, device_state):\n    thermal_status = device_state.thermalStatus\n\n    if thermal_status == ThermalStatus.green:\n      self._temp_status.update(\"TEMP\", \"GOOD\", Colors.GOOD)\n    elif thermal_status == ThermalStatus.yellow:\n      self._temp_status.update(\"TEMP\", \"OK\", Colors.WARNING)\n    else:\n      self._temp_status.update(\"TEMP\", \"HIGH\", Colors.DANGER)\n\n  def _update_connection_status(self, device_state):\n    last_ping = device_state.lastAthenaPingTime\n    if last_ping == 0:\n      self._connect_status.update(\"CONNECT\", \"OFFLINE\", Colors.WARNING)\n    elif time.monotonic_ns() - last_ping < 80_000_000_000:  # 80 seconds in nanoseconds\n      self._connect_status.update(\"CONNECT\", \"ONLINE\", Colors.GOOD)\n    else:\n      self._connect_status.update(\"CONNECT\", \"ERROR\", Colors.DANGER)\n\n  def _update_panda_status(self):\n    if ui_state.panda_type == log.PandaState.PandaType.unknown:\n      self._panda_status.update(\"NO\", \"PANDA\", Colors.DANGER)\n    else:\n      self._panda_status.update(\"VEHICLE\", \"ONLINE\", Colors.GOOD)\n\n  def _handle_mouse_release(self, mouse_pos: MousePos):\n    if rl.check_collision_point_rec(mouse_pos, SETTINGS_BTN):\n      if self._on_settings_click:\n        self._on_settings_click()\n    elif rl.check_collision_point_rec(mouse_pos, HOME_BTN) and ui_state.started:\n      if self._on_flag_click:\n        self._on_flag_click()\n\n  def _draw_buttons(self, rect: rl.Rectangle):\n    mouse_pos = rl.get_mouse_position()\n    mouse_down = self.is_pressed and rl.is_mouse_button_down(rl.MouseButton.MOUSE_BUTTON_LEFT)\n\n    # Settings button\n    settings_down = mouse_down and rl.check_collision_point_rec(mouse_pos, SETTINGS_BTN)\n    tint = Colors.BUTTON_PRESSED if settings_down else Colors.BUTTON_NORMAL\n    rl.draw_texture(self._settings_img, int(SETTINGS_BTN.x), int(SETTINGS_BTN.y), tint)\n\n    # Home/Flag button\n    flag_pressed = mouse_down and rl.check_collision_point_rec(mouse_pos, HOME_BTN)\n    button_img = self._flag_img if ui_state.started else self._home_img\n\n    tint = Colors.BUTTON_PRESSED if (ui_state.started and flag_pressed) else Colors.BUTTON_NORMAL\n    rl.draw_texture(button_img, int(HOME_BTN.x), int(HOME_BTN.y), tint)\n\n  def _draw_network_indicator(self, rect: rl.Rectangle):\n    # Signal strength dots\n    x_start = rect.x + 58\n    y_pos = rect.y + 196\n    dot_size = 27\n    dot_spacing = 37\n\n    for i in range(5):\n      color = Colors.WHITE if i < self._net_strength else Colors.GRAY\n      x = int(x_start + i * dot_spacing + dot_size // 2)\n      y = int(y_pos + dot_size // 2)\n      rl.draw_circle(x, y, dot_size // 2, color)\n\n    # Network type text\n    text_y = rect.y + 247\n    text_pos = rl.Vector2(rect.x + 58, text_y)\n    rl.draw_text_ex(self._font_regular, self._net_type, text_pos, FONT_SIZE, 0, Colors.WHITE)\n\n  def _draw_metrics(self, rect: rl.Rectangle):\n    metrics = [(self._temp_status, 338), (self._panda_status, 496), (self._connect_status, 654)]\n\n    for metric, y_offset in metrics:\n      self._draw_metric(rect, metric, rect.y + y_offset)\n\n  def _draw_metric(self, rect: rl.Rectangle, metric: MetricData, y: float):\n    metric_rect = rl.Rectangle(rect.x + METRIC_MARGIN, y, METRIC_WIDTH, METRIC_HEIGHT)\n    # Draw colored left edge (clipped rounded rectangle)\n    edge_rect = rl.Rectangle(metric_rect.x + 4, metric_rect.y + 4, 100, 118)\n    rl.begin_scissor_mode(int(metric_rect.x + 4), int(metric_rect.y), 18, int(metric_rect.height))\n    rl.draw_rectangle_rounded(edge_rect, 0.18, 10, metric.color)\n    rl.end_scissor_mode()\n\n    # Draw border\n    rl.draw_rectangle_rounded_lines_ex(metric_rect, 0.15, 10, 2, Colors.METRIC_BORDER)\n\n    # Draw label and value\n    labels = [metric.label, metric.value]\n    text_y = metric_rect.y + (metric_rect.height / 2 - len(labels) * FONT_SIZE)\n    for text in labels:\n      text_size = measure_text_cached(self._font_bold, text, FONT_SIZE)\n      text_y += text_size.y\n      text_pos = rl.Vector2(\n        metric_rect.x + 22 + (metric_rect.width - 22 - text_size.x) / 2,\n        text_y\n      )\n      rl.draw_text_ex(self._font_bold, text, text_pos, FONT_SIZE, 0, Colors.WHITE)", "target": "sidebar"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/main.py:MainState:0", "source": "class CLASSTOKEN(IntEnum):\n  HOME = 0\n  SETTINGS = 1\n  ONROAD = 2", "target": "main state"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/main.py:MainLayout:1", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n\n    self._pm = messaging.PubMaster(['bookmarkButton'])\n\n    self._sidebar = Sidebar()\n    self._current_mode = MainState.HOME\n    self._prev_onroad = False\n\n    # Initialize layouts\n    self._layouts = {MainState.HOME: HomeLayout(), MainState.SETTINGS: SettingsLayout(), MainState.ONROAD: AugmentedRoadView()}\n\n    self._sidebar_rect = rl.Rectangle(0, 0, 0, 0)\n    self._content_rect = rl.Rectangle(0, 0, 0, 0)\n\n    # Set callbacks\n    self._setup_callbacks()\n\n  def _render(self, _):\n    self._handle_onroad_transition()\n    self._render_main_content()\n\n  def _setup_callbacks(self):\n    self._sidebar.set_callbacks(on_settings=self._on_settings_clicked,\n                                on_flag=self._on_bookmark_clicked)\n    self._layouts[MainState.HOME]._setup_widget.set_open_settings_callback(lambda: self.open_settings(PanelType.FIREHOSE))\n    self._layouts[MainState.SETTINGS].set_callbacks(on_close=self._set_mode_for_state)\n    self._layouts[MainState.ONROAD].set_callbacks(on_click=self._on_onroad_clicked)\n    device.add_interactive_timeout_callback(self._set_mode_for_state)\n\n  def _update_layout_rects(self):\n    self._sidebar_rect = rl.Rectangle(self._rect.x, self._rect.y, SIDEBAR_WIDTH, self._rect.height)\n\n    x_offset = SIDEBAR_WIDTH if self._sidebar.is_visible else 0\n    self._content_rect = rl.Rectangle(self._rect.y + x_offset, self._rect.y, self._rect.width - x_offset, self._rect.height)\n\n  def _handle_onroad_transition(self):\n    if ui_state.started != self._prev_onroad:\n      self._prev_onroad = ui_state.started\n\n      self._set_mode_for_state()\n\n  def _set_mode_for_state(self):\n    if ui_state.started:\n      # Don't hide sidebar from interactive timeout\n      if self._current_mode != MainState.ONROAD:\n        self._sidebar.set_visible(False)\n      self._set_current_layout(MainState.ONROAD)\n    else:\n      self._set_current_layout(MainState.HOME)\n      self._sidebar.set_visible(True)\n\n  def _set_current_layout(self, layout: MainState):\n    if layout != self._current_mode:\n      self._layouts[self._current_mode].hide_event()\n      self._current_mode = layout\n      self._layouts[self._current_mode].show_event()\n\n  def open_settings(self, panel_type: PanelType):\n    self._layouts[MainState.SETTINGS].set_current_panel(panel_type)\n    self._set_current_layout(MainState.SETTINGS)\n    self._sidebar.set_visible(False)\n\n  def _on_settings_clicked(self):\n    self.open_settings(PanelType.DEVICE)\n\n  def _on_bookmark_clicked(self):\n    user_bookmark = messaging.new_message('bookmarkButton')\n    user_bookmark.valid = True\n    self._pm.send('bookmarkButton', user_bookmark)\n\n  def _on_onroad_clicked(self):\n    self._sidebar.set_visible(not self._sidebar.is_visible)\n\n  def _render_main_content(self):\n    # Render sidebar\n    if self._sidebar.is_visible:\n      self._sidebar.render(self._sidebar_rect)\n\n    content_rect = self._content_rect if self._sidebar.is_visible else self._rect\n    self._layouts[self._current_mode].render(content_rect)", "target": "main layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/software.py:SoftwareLayout:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n\n    self._params = Params()\n    items = self._init_items()\n    self._scroller = Scroller(items, line_separator=True, spacing=0)\n\n  def _init_items(self):\n    items = [\n      text_item(\"Current Version\", \"\"),\n      button_item(\"Download\", \"CHECK\", callback=self._on_download_update),\n      button_item(\"Install Update\", \"INSTALL\", callback=self._on_install_update),\n      button_item(\"Target Branch\", \"SELECT\", callback=self._on_select_branch),\n      button_item(\"Uninstall\", \"UNINSTALL\", callback=self._on_uninstall),\n    ]\n    return items\n\n  def _render(self, rect):\n    self._scroller.render(rect)\n\n  def _on_download_update(self): pass\n  def _on_install_update(self): pass\n  def _on_select_branch(self): pass\n\n  def _on_uninstall(self):\n    def handle_uninstall_confirmation(result):\n      if result == DialogResult.CONFIRM:\n        self._params.put_bool(\"DoUninstall\", True)\n\n    gui_app.set_modal_overlay(\n      lambda: confirm_dialog(\"Are you sure you want to uninstall?\", \"Uninstall\"),\n      callback=handle_uninstall_confirmation,\n    )", "target": "software layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/toggles.py:TogglesLayout:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._params = Params()\n    items = [\n      toggle_item(\n        \"Enable openpilot\",\n        DESCRIPTIONS[\"OpenpilotEnabledToggle\"],\n        self._params.get_bool(\"OpenpilotEnabledToggle\"),\n        icon=\"chffr_wheel.png\",\n      ),\n      toggle_item(\n        \"Experimental Mode\",\n        initial_state=self._params.get_bool(\"ExperimentalMode\"),\n        icon=\"experimental_white.png\",\n      ),\n      toggle_item(\n        \"Disengage on Accelerator Pedal\",\n        DESCRIPTIONS[\"DisengageOnAccelerator\"],\n        self._params.get_bool(\"DisengageOnAccelerator\"),\n        icon=\"disengage_on_accelerator.png\",\n      ),\n      multiple_button_item(\n        \"Driving Personality\",\n        DESCRIPTIONS[\"LongitudinalPersonality\"],\n        buttons=[\"Aggressive\", \"Standard\", \"Relaxed\"],\n        button_width=255,\n        callback=self._set_longitudinal_personality,\n        selected_index=self._params.get(\"LongitudinalPersonality\", return_default=True),\n        icon=\"speed_limit.png\"\n      ),\n      toggle_item(\n        \"Enable Lane Departure Warnings\",\n        DESCRIPTIONS[\"IsLdwEnabled\"],\n        self._params.get_bool(\"IsLdwEnabled\"),\n        icon=\"warning.png\",\n      ),\n      toggle_item(\n        \"Always-On Driver Monitoring\",\n        DESCRIPTIONS[\"AlwaysOnDM\"],\n        self._params.get_bool(\"AlwaysOnDM\"),\n        icon=\"monitoring.png\",\n      ),\n      toggle_item(\n        \"Record and Upload Driver Camera\",\n        DESCRIPTIONS[\"RecordFront\"],\n        self._params.get_bool(\"RecordFront\"),\n        icon=\"monitoring.png\",\n      ),\n      toggle_item(\n        \"Record Microphone Audio\",\n        DESCRIPTIONS[\"RecordAudio\"],\n        self._params.get_bool(\"RecordAudio\"),\n        icon=\"microphone.png\",\n      ),\n      toggle_item(\n        \"Use Metric System\", DESCRIPTIONS[\"IsMetric\"], self._params.get_bool(\"IsMetric\"), icon=\"metric.png\"\n      ),\n    ]\n\n    self._scroller = Scroller(items, line_separator=True, spacing=0)\n\n  def _render(self, rect):\n    self._scroller.render(rect)\n\n  def _set_longitudinal_personality(self, button_index: int):\n    self._params.put(\"LongitudinalPersonality\", button_index)", "target": "toggles layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/firehose.py:FirehoseLayout:0", "source": "class CLASSTOKEN(Widget):\n  PARAM_KEY = \"ApiCache_FirehoseStats\"\n  GREEN = rl.Color(46, 204, 113, 255)\n  RED = rl.Color(231, 76, 60, 255)\n  GRAY = rl.Color(68, 68, 68, 255)\n  LIGHT_GRAY = rl.Color(228, 228, 228, 255)\n  UPDATE_INTERVAL = 30  # seconds\n\n  def __init__(self):\n    super().__init__()\n    self.params = Params()\n    self.segment_count = self._get_segment_count()\n    self.scroll_panel = GuiScrollPanel()\n\n    self.running = True\n    self.update_thread = threading.Thread(target=self._update_loop, daemon=True)\n    self.update_thread.start()\n    self.last_update_time = 0\n\n  def _get_segment_count(self) -> int:\n    stats = self.params.get(self.PARAM_KEY)\n    if not stats:\n      return 0\n    try:\n      return int(stats.get(\"firehose\", 0))\n    except Exception:\n      cloudlog.exception(f\"Failed to decode firehose stats: {stats}\")\n      return 0\n\n  def __del__(self):\n    self.running = False\n    if self.update_thread and self.update_thread.is_alive():\n      self.update_thread.join(timeout=1.0)\n\n  def _render(self, rect: rl.Rectangle):\n    # Calculate content dimensions\n    content_width = rect.width - 80\n    content_height = self._calculate_content_height(int(content_width))\n    content_rect = rl.Rectangle(rect.x, rect.y, rect.width, content_height)\n\n    # Handle scrolling and render with clipping\n    scroll_offset = self.scroll_panel.handle_scroll(rect, content_rect)\n    rl.begin_scissor_mode(int(rect.x), int(rect.y), int(rect.width), int(rect.height))\n    self._render_content(rect, scroll_offset)\n    rl.end_scissor_mode()\n\n  def _calculate_content_height(self, content_width: int) -> int:\n    height = 80  # Top margin\n\n    # Title\n    height += 100 + 40\n\n    # Description\n    desc_font = gui_app.font(FontWeight.NORMAL)\n    desc_lines = wrap_text(desc_font, DESCRIPTION, 45, content_width)\n    height += len(desc_lines) * 45 + 40\n\n    # Status section\n    height += 32  # Separator\n    status_text, _ = self._get_status()\n    status_lines = wrap_text(gui_app.font(FontWeight.BOLD), status_text, 60, content_width)\n    height += len(status_lines) * 60 + 20\n\n    # Contribution count (if available)\n    if self.segment_count > 0:\n      contrib_text = f\"{self.segment_count} segment(s) of your driving is in the training dataset so far.\"\n      contrib_lines = wrap_text(gui_app.font(FontWeight.BOLD), contrib_text, 52, content_width)\n      height += len(contrib_lines) * 52 + 20\n\n    # Instructions section\n    height += 32  # Separator\n    inst_lines = wrap_text(gui_app.font(FontWeight.NORMAL), INSTRUCTIONS, 40, content_width)\n    height += len(inst_lines) * 40 + 40  # Bottom margin\n\n    return height\n\n  def _render_content(self, rect: rl.Rectangle, scroll_offset: rl.Vector2):\n    x = int(rect.x + 40)\n    y = int(rect.y + 40 + scroll_offset.y)\n    w = int(rect.width - 80)\n\n    # Title\n    title_font = gui_app.font(FontWeight.MEDIUM)\n    rl.draw_text_ex(title_font, TITLE, rl.Vector2(x, y), 100, 0, rl.WHITE)\n    y += 140\n\n    # Description\n    y = self._draw_wrapped_text(x, y, w, DESCRIPTION, gui_app.font(FontWeight.NORMAL), 45, rl.WHITE)\n    y += 40\n\n    # Separator\n    rl.draw_rectangle(x, y, w, 2, self.GRAY)\n    y += 30\n\n    # Status\n    status_text, status_color = self._get_status()\n    y = self._draw_wrapped_text(x, y, w, status_text, gui_app.font(FontWeight.BOLD), 60, status_color)\n    y += 20\n\n    # Contribution count (if available)\n    if self.segment_count > 0:\n      contrib_text = f\"{self.segment_count} segment(s) of your driving is in the training dataset so far.\"\n      y = self._draw_wrapped_text(x, y, w, contrib_text, gui_app.font(FontWeight.BOLD), 52, rl.WHITE)\n      y += 20\n\n    # Separator\n    rl.draw_rectangle(x, y, w, 2, self.GRAY)\n    y += 30\n\n    # Instructions\n    self._draw_wrapped_text(x, y, w, INSTRUCTIONS, gui_app.font(FontWeight.NORMAL), 40, self.LIGHT_GRAY)\n\n  def _draw_wrapped_text(self, x, y, width, text, font, size, color):\n    wrapped = wrap_text(font, text, size, width)\n    for line in wrapped:\n      rl.draw_text_ex(font, line, rl.Vector2(x, y), size, 0, color)\n      y += size\n    return y\n\n  def _get_status(self) -> tuple[str, rl.Color]:\n    network_type = ui_state.sm[\"deviceState\"].networkType\n    network_metered = ui_state.sm[\"deviceState\"].networkMetered\n\n    if not network_metered and network_type != 0:  # Not metered and connected\n      return \"ACTIVE\", self.GREEN\n    else:\n      return \"INACTIVE: connect to an unmetered network\", self.RED\n\n  def _fetch_firehose_stats(self):\n    try:\n      dongle_id = self.params.get(\"DongleId\")\n      if not dongle_id or dongle_id == UNREGISTERED_DONGLE_ID:\n        return\n      identity_token = get_token(dongle_id)\n      response = api_get(f\"v1/devices/{dongle_id}/firehose_stats\", access_token=identity_token)\n      if response.status_code == 200:\n        data = response.json()\n        self.segment_count = data.get(\"firehose\", 0)\n        self.params.put(self.PARAM_KEY, data)\n    except Exception as e:\n      cloudlog.error(f\"Failed to fetch firehose stats: {e}\")\n\n  def _update_loop(self):\n    while self.running:\n      if not ui_state.started:\n        self._fetch_firehose_stats()\n      time.sleep(self.UPDATE_INTERVAL)", "target": "firehose layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/device.py:DeviceLayout:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n\n    self._params = Params()\n    self._select_language_dialog: MultiOptionDialog | None = None\n    self._driver_camera: DriverCameraDialog | None = None\n    self._pair_device_dialog: PairingDialog | None = None\n    self._fcc_dialog: HtmlRenderer | None = None\n\n    items = self._initialize_items()\n    self._scroller = Scroller(items, line_separator=True, spacing=0)\n\n  def _initialize_items(self):\n    dongle_id = self._params.get(\"DongleId\") or \"N/A\"\n    serial = self._params.get(\"HardwareSerial\") or \"N/A\"\n\n    items = [\n      text_item(\"Dongle ID\", dongle_id),\n      text_item(\"Serial\", serial),\n      button_item(\"Pair Device\", \"PAIR\", DESCRIPTIONS['pair_device'], callback=self._pair_device),\n      button_item(\"Driver Camera\", \"PREVIEW\", DESCRIPTIONS['driver_camera'], callback=self._show_driver_camera, enabled=ui_state.is_offroad),\n      button_item(\"Reset Calibration\", \"RESET\", DESCRIPTIONS['reset_calibration'], callback=self._reset_calibration_prompt),\n      regulatory_btn := button_item(\"Regulatory\", \"VIEW\", callback=self._on_regulatory),\n      button_item(\"Review Training Guide\", \"REVIEW\", DESCRIPTIONS['review_guide'], self._on_review_training_guide),\n      button_item(\"Change Language\", \"CHANGE\", callback=self._show_language_selection, enabled=ui_state.is_offroad),\n      dual_button_item(\"Reboot\", \"Power Off\", left_callback=self._reboot_prompt, right_callback=self._power_off_prompt),\n    ]\n    regulatory_btn.set_visible(TICI)\n    return items\n\n  def _render(self, rect):\n    self._scroller.render(rect)\n\n  def _show_language_selection(self):\n    try:\n      languages_file = os.path.join(BASEDIR, \"selfdrive/ui/translations/languages.json\")\n      with open(languages_file, encoding='utf-8') as f:\n        languages = json.load(f)\n\n      self._select_language_dialog = MultiOptionDialog(\"Select a language\", languages)\n      gui_app.set_modal_overlay(self._select_language_dialog, callback=self._handle_language_selection)\n    except FileNotFoundError:\n      pass\n\n  def _handle_language_selection(self, result: int):\n    if result == 1 and self._select_language_dialog:\n      selected_language = self._select_language_dialog.selection\n      self._params.put(\"LanguageSetting\", selected_language)\n\n    self._select_language_dialog = None\n\n  def _show_driver_camera(self):\n    if not self._driver_camera:\n      self._driver_camera = DriverCameraDialog()\n\n    gui_app.set_modal_overlay(self._driver_camera, callback=lambda result: setattr(self, '_driver_camera', None))\n\n  def _reset_calibration_prompt(self):\n    if ui_state.engaged:\n      gui_app.set_modal_overlay(lambda: alert_dialog(\"Disengage to Reset Calibration\"))\n      return\n\n    gui_app.set_modal_overlay(\n      lambda: confirm_dialog(\"Are you sure you want to reset calibration?\", \"Reset\"),\n      callback=self._reset_calibration,\n    )\n\n  def _reset_calibration(self, result: int):\n    if ui_state.engaged or result != DialogResult.CONFIRM:\n      return\n\n    self._params.remove(\"CalibrationParams\")\n    self._params.remove(\"LiveTorqueParameters\")\n    self._params.remove(\"LiveParameters\")\n    self._params.remove(\"LiveParametersV2\")\n    self._params.remove(\"LiveDelay\")\n    self._params.put_bool(\"OnroadCycleRequested\", True)\n\n  def _reboot_prompt(self):\n    if ui_state.engaged:\n      gui_app.set_modal_overlay(lambda: alert_dialog(\"Disengage to Reboot\"))\n      return\n\n    gui_app.set_modal_overlay(\n      lambda: confirm_dialog(\"Are you sure you want to reboot?\", \"Reboot\"),\n      callback=self._perform_reboot,\n    )\n\n  def _perform_reboot(self, result: int):\n    if not ui_state.engaged and result == DialogResult.CONFIRM:\n      self._params.put_bool_nonblocking(\"DoReboot\", True)\n\n  def _power_off_prompt(self):\n    if ui_state.engaged:\n      gui_app.set_modal_overlay(lambda: alert_dialog(\"Disengage to Power Off\"))\n      return\n\n    gui_app.set_modal_overlay(\n      lambda: confirm_dialog(\"Are you sure you want to power off?\", \"Power Off\"),\n      callback=self._perform_power_off,\n    )\n\n  def _perform_power_off(self, result: int):\n    if not ui_state.engaged and result == DialogResult.CONFIRM:\n      self._params.put_bool_nonblocking(\"DoShutdown\", True)\n\n  def _pair_device(self):\n    if not self._pair_device_dialog:\n      self._pair_device_dialog = PairingDialog()\n    gui_app.set_modal_overlay(self._pair_device_dialog, callback=lambda result: setattr(self, '_pair_device_dialog', None))\n\n  def _on_regulatory(self):\n    if not self._fcc_dialog:\n      self._fcc_dialog = HtmlRenderer(os.path.join(BASEDIR, \"selfdrive/assets/offroad/fcc.html\"))\n\n    gui_app.set_modal_overlay(self._fcc_dialog,\n      callback=lambda result: setattr(self, '_fcc_dialog', None),\n    )\n\n  def _on_review_training_guide(self): pass", "target": "device layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/developer.py:DeveloperLayout:0", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._params = Params()\n    items = [\n      toggle_item(\n        \"Enable ADB\",\n        description=DESCRIPTIONS[\"enable_adb\"],\n        initial_state=self._params.get_bool(\"AdbEnabled\"),\n        callback=self._on_enable_adb,\n      ),\n      ssh_key_item(\"SSH Key\", description=DESCRIPTIONS[\"ssh_key\"]),\n      toggle_item(\n        \"Joystick Debug Mode\",\n        description=DESCRIPTIONS[\"joystick_debug_mode\"],\n        initial_state=self._params.get_bool(\"JoystickDebugMode\"),\n        callback=self._on_joystick_debug_mode,\n      ),\n      toggle_item(\n        \"Longitudinal Maneuver Mode\",\n        description=\"\",\n        initial_state=self._params.get_bool(\"LongitudinalManeuverMode\"),\n        callback=self._on_long_maneuver_mode,\n      ),\n      toggle_item(\n        \"openpilot Longitudinal Control (Alpha)\",\n        description=\"\",\n        initial_state=self._params.get_bool(\"AlphaLongitudinalEnabled\"),\n        callback=self._on_alpha_long_enabled,\n      ),\n    ]\n\n    self._scroller = Scroller(items, line_separator=True, spacing=0)\n\n  def _render(self, rect):\n    self._scroller.render(rect)\n\n  def _on_enable_adb(self): pass\n  def _on_joystick_debug_mode(self): pass\n  def _on_long_maneuver_mode(self): pass\n  def _on_alpha_long_enabled(self): pass", "target": "developer layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/settings.py:PanelType:0", "source": "class CLASSTOKEN(IntEnum):\n  DEVICE = 0\n  NETWORK = 1\n  TOGGLES = 2\n  SOFTWARE = 3\n  FIREHOSE = 4\n  DEVELOPER = 5", "target": "panel type"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/settings.py:PanelInfo:1", "source": "class CLASSTOKEN:\n  name: str\n  instance: Widget\n  button_rect: rl.Rectangle = rl.Rectangle(0, 0, 0, 0)", "target": "panel info"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/layouts/settings/settings.py:SettingsLayout:2", "source": "class CLASSTOKEN(Widget):\n  def __init__(self):\n    super().__init__()\n    self._current_panel = PanelType.DEVICE\n\n    # Panel configuration\n    wifi_manager = WifiManager()\n    wifi_manager.set_active(False)\n\n    self._panels = {\n      PanelType.DEVICE: PanelInfo(\"Device\", DeviceLayout()),\n      PanelType.NETWORK: PanelInfo(\"Network\", WifiManagerUI(wifi_manager)),\n      PanelType.TOGGLES: PanelInfo(\"Toggles\", TogglesLayout()),\n      PanelType.SOFTWARE: PanelInfo(\"Software\", SoftwareLayout()),\n      PanelType.FIREHOSE: PanelInfo(\"Firehose\", FirehoseLayout()),\n      PanelType.DEVELOPER: PanelInfo(\"Developer\", DeveloperLayout()),\n    }\n\n    self._font_medium = gui_app.font(FontWeight.MEDIUM)\n\n    # Callbacks\n    self._close_callback: Callable | None = None\n\n  def set_callbacks(self, on_close: Callable):\n    self._close_callback = on_close\n\n  def _render(self, rect: rl.Rectangle):\n    # Calculate layout\n    sidebar_rect = rl.Rectangle(rect.x, rect.y, SIDEBAR_WIDTH, rect.height)\n    panel_rect = rl.Rectangle(rect.x + SIDEBAR_WIDTH, rect.y, rect.width - SIDEBAR_WIDTH, rect.height)\n\n    # Draw components\n    self._draw_sidebar(sidebar_rect)\n    self._draw_current_panel(panel_rect)\n\n  def _draw_sidebar(self, rect: rl.Rectangle):\n    rl.draw_rectangle_rec(rect, SIDEBAR_COLOR)\n\n    # Close button\n    close_btn_rect = rl.Rectangle(\n      rect.x + (rect.width - CLOSE_BTN_SIZE) / 2, rect.y + 60, CLOSE_BTN_SIZE, CLOSE_BTN_SIZE\n    )\n\n    pressed = (rl.is_mouse_button_down(rl.MouseButton.MOUSE_BUTTON_LEFT) and\n               rl.check_collision_point_rec(rl.get_mouse_position(), close_btn_rect))\n    close_color = CLOSE_BTN_PRESSED if pressed else CLOSE_BTN_COLOR\n    rl.draw_rectangle_rounded(close_btn_rect, 1.0, 20, close_color)\n\n    close_text_size = measure_text_cached(self._font_medium, SETTINGS_CLOSE_TEXT, 140)\n    close_text_pos = rl.Vector2(\n      close_btn_rect.x + (close_btn_rect.width - close_text_size.x) / 2,\n      close_btn_rect.y + (close_btn_rect.height - close_text_size.y) / 2 - SETTINGS_CLOSE_TEXT_Y_OFFSET,\n    )\n    rl.draw_text_ex(self._font_medium, SETTINGS_CLOSE_TEXT, close_text_pos, 140, 0, TEXT_SELECTED)\n\n    # Store close button rect for click detection\n    self._close_btn_rect = close_btn_rect\n\n    # Navigation buttons\n    y = rect.y + 300\n    for panel_type, panel_info in self._panels.items():\n      button_rect = rl.Rectangle(rect.x + 50, y, rect.width - 150, NAV_BTN_HEIGHT)\n\n      # Button styling\n      is_selected = panel_type == self._current_panel\n      text_color = TEXT_SELECTED if is_selected else TEXT_NORMAL\n      # Draw button text (right-aligned)\n      text_size = measure_text_cached(self._font_medium, panel_info.name, 65)\n      text_pos = rl.Vector2(\n        button_rect.x + button_rect.width - text_size.x, button_rect.y + (button_rect.height - text_size.y) / 2\n      )\n      rl.draw_text_ex(self._font_medium, panel_info.name, text_pos, 65, 0, text_color)\n\n      # Store button rect for click detection\n      panel_info.button_rect = button_rect\n\n      y += NAV_BTN_HEIGHT\n\n  def _draw_current_panel(self, rect: rl.Rectangle):\n    rl.draw_rectangle_rounded(\n      rl.Rectangle(rect.x + 10, rect.y + 10, rect.width - 20, rect.height - 20), 0.04, 30, PANEL_COLOR\n    )\n    content_rect = rl.Rectangle(rect.x + PANEL_MARGIN, rect.y + 25, rect.width - (PANEL_MARGIN * 2), rect.height - 50)\n    # rl.draw_rectangle_rounded(content_rect, 0.03, 30, PANEL_COLOR)\n    panel = self._panels[self._current_panel]\n    if panel.instance:\n      panel.instance.render(content_rect)\n\n  def _handle_mouse_release(self, mouse_pos: MousePos) -> bool:\n    # Check close button\n    if rl.check_collision_point_rec(mouse_pos, self._close_btn_rect):\n      if self._close_callback:\n        self._close_callback()\n      return True\n\n    # Check navigation buttons\n    for panel_type, panel_info in self._panels.items():\n      if rl.check_collision_point_rec(mouse_pos, panel_info.button_rect):\n        self.set_current_panel(panel_type)\n        return True\n\n    return False\n\n  def set_current_panel(self, panel_type: PanelType):\n    if panel_type != self._current_panel:\n      self._panels[self._current_panel].instance.hide_event()\n      self._current_panel = panel_type\n      self._panels[self._current_panel].instance.show_event()\n\n  def show_event(self):\n    super().show_event()\n    self._panels[self._current_panel].instance.show_event()\n\n  def hide_event(self):\n    super().hide_event()\n    self._panels[self._current_panel].instance.hide_event()", "target": "settings layout"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/test_updated.py:TestUpdated:0", "source": "class CLASSTOKEN:\n\n  def setup_method(self):\n    self.updated_proc = None\n\n    self.tmp_dir = tempfile.TemporaryDirectory()\n    org_dir = os.path.join(self.tmp_dir.name, \"commaai\")\n\n    self.basedir = os.path.join(org_dir, \"openpilot\")\n    self.git_remote_dir = os.path.join(org_dir, \"openpilot_remote\")\n    self.staging_dir = os.path.join(org_dir, \"safe_staging\")\n    for d in [org_dir, self.basedir, self.git_remote_dir, self.staging_dir]:\n      os.mkdir(d)\n\n    self.neos_version = os.path.join(org_dir, \"neos_version\")\n    self.neosupdate_dir = os.path.join(org_dir, \"neosupdate\")\n    with open(self.neos_version, \"w\") as f:\n      v = subprocess.check_output(r\"bash -c 'source launch_env.sh && echo $REQUIRED_NEOS_VERSION'\",\n                                  cwd=BASEDIR, shell=True, encoding='utf8').strip()\n      f.write(v)\n\n    self.upper_dir = os.path.join(self.staging_dir, \"upper\")\n    self.merged_dir = os.path.join(self.staging_dir, \"merged\")\n    self.finalized_dir = os.path.join(self.staging_dir, \"finalized\")\n\n    # setup local submodule remotes\n    submodules = subprocess.check_output(\"git submodule --quiet foreach 'echo $name'\",\n                                         shell=True, cwd=BASEDIR, encoding='utf8').split()\n    for s in submodules:\n      sub_path = os.path.join(org_dir, s.split(\"_repo\")[0])\n      self._run(f\"git clone {s} {sub_path}.git\", cwd=BASEDIR)\n\n    # setup two git repos, a remote and one we'll run updated in\n    self._run([\n      f\"git clone {BASEDIR} {self.git_remote_dir}\",\n      f\"git clone {self.git_remote_dir} {self.basedir}\",\n      f\"cd {self.basedir} && git submodule init && git submodule update\",\n      f\"cd {self.basedir} && scons -j{os.cpu_count()} cereal/ common/\"\n    ])\n\n    self.params = Params(os.path.join(self.basedir, \"persist/params\"))\n    self.params.clear_all()\n    os.sync()\n\n  def teardown_method(self):\n    try:\n      if self.updated_proc is not None:\n        self.updated_proc.terminate()\n        self.updated_proc.wait(30)\n    except Exception as e:\n      print(e)\n    self.tmp_dir.cleanup()\n\n\n  # *** test helpers ***\n\n\n  def _run(self, cmd, cwd=None):\n    if not isinstance(cmd, list):\n      cmd = (cmd,)\n\n    for c in cmd:\n      subprocess.check_output(c, cwd=cwd, shell=True)\n\n  def _get_updated_proc(self):\n    os.environ[\"PYTHONPATH\"] = self.basedir\n    os.environ[\"GIT_AUTHOR_NAME\"] = \"testy tester\"\n    os.environ[\"GIT_COMMITTER_NAME\"] = \"testy tester\"\n    os.environ[\"GIT_AUTHOR_EMAIL\"] = \"testy@tester.test\"\n    os.environ[\"GIT_COMMITTER_EMAIL\"] = \"testy@tester.test\"\n    os.environ[\"UPDATER_TEST_IP\"] = \"localhost\"\n    os.environ[\"UPDATER_LOCK_FILE\"] = os.path.join(self.tmp_dir.name, \"updater.lock\")\n    os.environ[\"UPDATER_STAGING_ROOT\"] = self.staging_dir\n    os.environ[\"UPDATER_NEOS_VERSION\"] = self.neos_version\n    os.environ[\"UPDATER_NEOSUPDATE_DIR\"] = self.neosupdate_dir\n    updated_path = os.path.join(self.basedir, \"system/updated.py\")\n    return subprocess.Popen(updated_path, env=os.environ)\n\n  def _start_updater(self, offroad=True, nosleep=False):\n    self.params.put_bool(\"IsOffroad\", offroad)\n    self.updated_proc = self._get_updated_proc()\n    if not nosleep:\n      time.sleep(1)\n\n  def _update_now(self):\n    self.updated_proc.send_signal(signal.SIGHUP)\n\n  # TODO: this should be implemented in params\n  def _read_param(self, key, timeout=1):\n    ret = None\n    start_time = time.monotonic()\n    while ret is None:\n      ret = self.params.get(key)\n      if time.monotonic() - start_time > timeout:\n        break\n      time.sleep(0.01)\n    return ret\n\n  def _wait_for_update(self, timeout=30, clear_param=False):\n    if clear_param:\n      self.params.remove(\"LastUpdateTime\")\n\n    self._update_now()\n    t = self._read_param(\"LastUpdateTime\", timeout=timeout)\n    if t is None:\n      raise Exception(\"timed out waiting for update to complete\")\n\n  def _make_commit(self):\n    all_dirs, all_files = [], []\n    for root, dirs, files in os.walk(self.git_remote_dir):\n      if \".git\" in root:\n        continue\n      for d in dirs:\n        all_dirs.append(os.path.join(root, d))\n      for f in files:\n        all_files.append(os.path.join(root, f))\n\n    # make a new dir and some new files\n    new_dir = os.path.join(self.git_remote_dir, \"this_is_a_new_dir\")\n    os.mkdir(new_dir)\n    for _ in range(random.randrange(5, 30)):\n      for d in (new_dir, random.choice(all_dirs)):\n        with tempfile.NamedTemporaryFile(dir=d, delete=False) as f:\n          f.write(os.urandom(random.randrange(1, 1000000)))\n\n    # modify some files\n    for f in random.sample(all_files, random.randrange(5, 50)):\n      with open(f, \"w+\") as ff:\n        txt = ff.readlines()\n        ff.seek(0)\n        for line in txt:\n          ff.write(line[::-1])\n\n    # remove some files\n    for f in random.sample(all_files, random.randrange(5, 50)):\n      os.remove(f)\n\n    # remove some dirs\n    for d in random.sample(all_dirs, random.randrange(1, 10)):\n      shutil.rmtree(d)\n\n    # commit the changes\n    self._run([\n      \"git add -A\",\n      \"git commit -m 'an update'\",\n    ], cwd=self.git_remote_dir)\n\n  def _check_update_state(self, update_available):\n    # make sure LastUpdateTime is recent\n    last_update_time = self._read_param(\"LastUpdateTime\")\n    td = datetime.datetime.now(datetime.UTC).replace(tzinfo=None) - last_update_time\n    assert td.total_seconds() < 10\n    self.params.remove(\"LastUpdateTime\")\n\n    # wait a bit for the rest of the params to be written\n    time.sleep(0.1)\n\n    # check params\n    update = self._read_param(\"UpdateAvailable\")\n    assert update == \"1\" == update_available, f\"UpdateAvailable: {repr(update)}\"\n    assert self._read_param(\"UpdateFailedCount\") == 0\n\n    # TODO: check that the finalized update actually matches remote\n    # check the .overlay_init and .overlay_consistent flags\n    assert os.path.isfile(os.path.join(self.basedir, \".overlay_init\"))\n    assert os.path.isfile(os.path.join(self.finalized_dir, \".overlay_consistent\")) == update_available\n\n\n  # *** test cases ***\n\n\n  # Run updated for 100 cycles with no update\n  def test_no_update(self):\n    self._start_updater()\n    for _ in range(100):\n      self._wait_for_update(clear_param=True)\n      self._check_update_state(False)\n\n  # Let the updater run with no update for a cycle, then write an update\n  def test_update(self):\n    self._start_updater()\n\n    # run for a cycle with no update\n    self._wait_for_update(clear_param=True)\n    self._check_update_state(False)\n\n    # write an update to our remote\n    self._make_commit()\n\n    # run for a cycle to get the update\n    self._wait_for_update(timeout=60, clear_param=True)\n    self._check_update_state(True)\n\n    # run another cycle with no update\n    self._wait_for_update(clear_param=True)\n    self._check_update_state(True)\n\n  # Let the updater run for 10 cycles, and write an update every cycle\n  @pytest.mark.skip(\"need to make this faster\")\n  def test_update_loop(self):\n    self._start_updater()\n\n    # run for a cycle with no update\n    self._wait_for_update(clear_param=True)\n    for _ in range(10):\n      time.sleep(0.5)\n      self._make_commit()\n      self._wait_for_update(timeout=90, clear_param=True)\n      self._check_update_state(True)\n\n  # Test overlay re-creation after tracking a new file in basedir's git\n  def test_overlay_reinit(self):\n    self._start_updater()\n\n    overlay_init_fn = os.path.join(self.basedir, \".overlay_init\")\n\n    # run for a cycle with no update\n    self._wait_for_update(clear_param=True)\n    self.params.remove(\"LastUpdateTime\")\n    first_mtime = os.path.getmtime(overlay_init_fn)\n\n    # touch a file in the basedir\n    self._run(\"touch new_file && git add new_file\", cwd=self.basedir)\n\n    # run another cycle, should have a new mtime\n    self._wait_for_update(clear_param=True)\n    second_mtime = os.path.getmtime(overlay_init_fn)\n    assert first_mtime != second_mtime\n\n    # run another cycle, mtime should be same as last cycle\n    self._wait_for_update(clear_param=True)\n    new_mtime = os.path.getmtime(overlay_init_fn)\n    assert second_mtime == new_mtime\n\n  # Make sure updated exits if another instance is running\n  def test_multiple_instances(self):\n    # start updated and let it run for a cycle\n    self._start_updater()\n    time.sleep(1)\n    self._wait_for_update(clear_param=True)\n\n    # start another instance\n    second_updated = self._get_updated_proc()\n    ret_code = second_updated.wait(timeout=5)\n    assert ret_code is not None\n\n\n  # *** test cases with NEOS updates ***\n\n\n  # Run updated with no update, make sure it clears the old NEOS update\n  def test_clear_neos_cache(self):\n    # make the dir and some junk files\n    os.mkdir(self.neosupdate_dir)\n    for _ in range(15):\n      with tempfile.NamedTemporaryFile(dir=self.neosupdate_dir, delete=False) as f:\n        f.write(os.urandom(random.randrange(1, 1000000)))\n\n    self._start_updater()\n    self._wait_for_update(clear_param=True)\n    self._check_update_state(False)\n    assert not os.path.isdir(self.neosupdate_dir)\n\n  # Let the updater run with no update for a cycle, then write an update\n  @pytest.mark.skip(\"TODO: only runs on device\")\n  def test_update_with_neos_update(self):\n    # bump the NEOS version and commit it\n    self._run([\n      \"echo 'export REQUIRED_NEOS_VERSION=3' >> launch_env.sh\",\n      \"git -c user.name='testy' -c user.email='testy@tester.test' \\\n       commit -am 'a neos update'\",\n    ], cwd=self.git_remote_dir)\n\n    # run for a cycle to get the update\n    self._start_updater()\n    self._wait_for_update(timeout=60, clear_param=True)\n    self._check_update_state(True)\n\n    # TODO: more comprehensive check\n    assert os.path.isdir(self.neosupdate_dir)", "target": "test updated"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/fuzzy_generation.py:FuzzyGenerator:0", "source": "class CLASSTOKEN:\n  def __init__(self, draw: DrawType, real_floats: bool):\n    self.draw = draw\n    self.native_type_map = CLASSTOKEN._get_native_type_map(real_floats)\n\n  def generate_native_type(self, field: str) -> st.SearchStrategy[bool | int | float | str | bytes]:\n    value_func = self.native_type_map.get(field)\n    if value_func is not None:\n      return value_func\n    else:\n      raise NotImplementedError(f'Invalid type: {field}')\n\n  def generate_field(self, field: capnp.lib.capnp._StructSchemaField) -> st.SearchStrategy:\n    def rec(field_type: capnp.lib.capnp._DynamicStructReader) -> st.SearchStrategy:\n      type_which = field_type.which()\n      if type_which == 'struct':\n        return self.generate_struct(field.schema.elementType if base_type == 'list' else field.schema)\n      elif type_which == 'list':\n        return st.lists(rec(field_type.list.elementType))\n      elif type_which == 'enum':\n        schema = field.schema.elementType if base_type == 'list' else field.schema\n        return st.sampled_from(list(schema.enumerants.keys()))\n      else:\n        return self.generate_native_type(type_which)\n\n    try:\n      if hasattr(field.proto, 'slot'):\n        slot_type =  field.proto.slot.type\n        base_type = slot_type.which()\n        return rec(slot_type)\n      else:\n        return self.generate_struct(field.schema)\n    except capnp.lib.capnp.KjException:\n      return self.generate_struct(field.schema)\n\n  def generate_struct(self, schema: capnp.lib.capnp._StructSchema, event: str = None) -> st.SearchStrategy[dict[str, Any]]:\n    single_fill: tuple[str, ...] = (event,) if event else (self.draw(st.sampled_from(schema.union_fields)),) if schema.union_fields else ()\n    fields_to_generate = schema.non_union_fields + single_fill\n    return st.fixed_dictionaries({field: self.generate_field(schema.fields[field]) for field in fields_to_generate if not field.endswith('DEPRECATED')})\n\n  @staticmethod\n  @cache\n  def _get_native_type_map(real_floats: bool) -> dict[str, st.SearchStrategy]:\n    return {\n      'bool': st.booleans(),\n      'int8': st.integers(min_value=-2**7, max_value=2**7-1),\n      'int16': st.integers(min_value=-2**15, max_value=2**15-1),\n      'int32': st.integers(min_value=-2**31, max_value=2**31-1),\n      'int64': st.integers(min_value=-2**63, max_value=2**63-1),\n      'uint8': st.integers(min_value=0, max_value=2**8-1),\n      'uint16': st.integers(min_value=0, max_value=2**16-1),\n      'uint32': st.integers(min_value=0, max_value=2**32-1),\n      'uint64': st.integers(min_value=0, max_value=2**64-1),\n      'float32': st.floats(width=32, allow_nan=not real_floats, allow_infinity=not real_floats),\n      'float64': st.floats(width=64, allow_nan=not real_floats, allow_infinity=not real_floats),\n      'text': st.text(max_size=1000),\n      'data': st.binary(max_size=1000),\n      'anyPointer': st.text(),  # Note: No need to define a separate function for anyPointer\n    }\n\n  @classmethod\n  def get_random_msg(cls, draw: DrawType, struct: capnp.lib.capnp._StructModule, real_floats: bool = False) -> dict[str, Any]:\n    fg = cls(draw, real_floats=real_floats)\n    data: dict[str, Any] = draw(fg.generate_struct(struct.schema))\n    return data\n\n  @classmethod\n  def get_random_event_msg(cls, draw: DrawType, events: list[str], real_floats: bool = False) -> list[dict[str, Any]]:\n    fg = cls(draw, real_floats=real_floats)\n    return [draw(fg.generate_struct(log.Event.schema, e)) for e in sorted(events)]", "target": "fuzzy generator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/test_onroad.py:TestOnroad:0", "source": "class CLASSTOKEN:\n\n  @classmethod\n  def setup_class(cls):\n    if \"DEBUG\" in os.environ:\n      segs = filter(lambda x: os.path.exists(os.path.join(x, \"rlog.zst\")), Path(Paths.log_root()).iterdir())\n      segs = sorted(segs, key=lambda x: x.stat().st_mtime)\n      cls.lr = list(LogReader(os.path.join(segs[-1], \"rlog.zst\")))\n      cls.ts = msgs_to_time_series(cls.lr)\n      return\n\n    # setup env\n    params = Params()\n    params.remove(\"CurrentRoute\")\n    params.put_bool(\"RecordFront\", True)\n    set_params_enabled()\n    os.environ['REPLAY'] = '1'\n    os.environ['TESTING_CLOSET'] = '1'\n    if os.path.exists(Paths.log_root()):\n      shutil.rmtree(Paths.log_root())\n\n    # start manager and run openpilot for TEST_DURATION\n    proc = None\n    try:\n      manager_path = os.path.join(BASEDIR, \"system/manager/manager.py\")\n      cls.manager_st = time.monotonic()\n      proc = subprocess.Popen([\"python\", manager_path])\n\n      sm = messaging.SubMaster(['carState'])\n      with Timeout(30, \"controls didn't start\"):\n        while not sm.seen['carState']:\n          sm.update(1000)\n\n      route = params.get(\"CurrentRoute\")\n      assert route is not None\n\n      segs = list(Path(Paths.log_root()).glob(f\"{route}--*\"))\n      assert len(segs) == 1\n\n      time.sleep(TEST_DURATION)\n    finally:\n      if proc is not None:\n        proc.terminate()\n        if proc.wait(60) is None:\n          proc.kill()\n\n    cls.lr = list(LogReader(os.path.join(str(segs[0]), \"rlog.zst\")))\n    st = time.monotonic()\n    cls.ts = msgs_to_time_series(cls.lr)\n    print(\"msgs to time series\", time.monotonic() - st)\n    log_path = segs[0]\n\n    cls.log_sizes = {}\n    for f in log_path.iterdir():\n      assert f.is_file()\n      cls.log_sizes[f] = f.stat().st_size / 1e6\n\n    cls.msgs = defaultdict(list)\n    for m in cls.lr:\n      cls.msgs[m.which()].append(m)\n\n  def test_service_frequencies(self, subtests):\n    for s, msgs in self.msgs.items():\n      if s in ('initData', 'sentinel'):\n        continue\n\n      # skip gps services for now\n      if s in ('ubloxGnss', 'ubloxRaw', 'gnssMeasurements', 'gpsLocation', 'gpsLocationExternal', 'qcomGnss'):\n        continue\n\n      with subtests.test(service=s):\n        assert len(msgs) >= math.floor(SERVICE_LIST[s].frequency*int(TEST_DURATION*0.8))\n\n  def test_manager_starting_time(self):\n    st = self.ts['managerState']['t'][0]\n    assert (st - self.manager_st) < 12.5, f\"manager.py took {st - self.manager_st}s to publish the first 'managerState' msg\"\n\n  def test_cloudlog_size(self):\n    msgs = self.msgs['logMessage']\n\n    total_size = sum(len(m.as_builder().to_bytes()) for m in msgs)\n    assert total_size < 3.5e5\n\n    cnt = Counter(json.loads(m.logMessage)['filename'] for m in msgs)\n    big_logs = [f for f, n in cnt.most_common(3) if n / sum(cnt.values()) > 30.]\n    assert len(big_logs) == 0, f\"Log spam: {big_logs}\"\n\n  def test_log_sizes(self, subtests):\n    # TODO: this isn't super stable between different devices\n    for f, sz in self.log_sizes.items():\n      rate = LOGS_SIZE[f.name]/60.\n      minn = rate * TEST_DURATION * 0.5\n      maxx = rate * TEST_DURATION * 1.5\n      with subtests.test(file=f.name):\n        assert minn < sz <  maxx\n\n  def test_ui_timings(self):\n    result = \"\\n\"\n    result += \"------------------------------------------------\\n\"\n    result += \"-------------- UI Draw Timing ------------------\\n\"\n    result += \"------------------------------------------------\\n\"\n\n    ts = self.ts['uiDebug']['drawTimeMillis']\n    result += f\"min  {min(ts):.2f}ms\\n\"\n    result += f\"max  {max(ts):.2f}ms\\n\"\n    result += f\"std  {np.std(ts):.2f}ms\\n\"\n    result += f\"mean {np.mean(ts):.2f}ms\\n\"\n    result += \"------------------------------------------------\\n\"\n    print(result)\n\n    assert max(ts) < 250.\n    assert np.mean(ts) < 10.\n    #self.assertLess(np.std(ts), 5.)\n\n    # some slow frames are expected since camerad/modeld can preempt ui\n    veryslow = [x for x in ts if x > 40.]\n    assert len(veryslow) < 5, f\"Too many slow frame draw times: {veryslow}\"\n\n  def test_cpu_usage(self, subtests):\n    print(\"\\n------------------------------------------------\")\n    print(\"------------------ CPU Usage -------------------\")\n    print(\"------------------------------------------------\")\n\n    plogs_by_proc = defaultdict(list)\n    for pl in self.msgs['procLog']:\n      for x in pl.procLog.procs:\n        if len(x.cmdline) > 0:\n          n = list(x.cmdline)[0]\n          plogs_by_proc[n].append(x)\n\n    cpu_ok = True\n    dt = (self.msgs['procLog'][-1].logMonoTime - self.msgs['procLog'][0].logMonoTime) / 1e9\n    header = ['process', 'usage', 'expected', 'max allowed', 'test result']\n    rows = []\n    for proc_name, expected in PROCS.items():\n\n      error = \"\"\n      usage = 0.\n      x = plogs_by_proc[proc_name]\n      if len(x) > 2:\n        cpu_time = cputime_total(x[-1]) - cputime_total(x[0])\n        usage = cpu_time / dt * 100.\n\n        max_allowed = max(expected * 1.8, expected + 5.0)\n        if usage > max_allowed:\n          error = \"❌ USING MORE CPU THAN EXPECTED ❌\"\n          cpu_ok = False\n\n      else:\n        error = \"❌ NO METRICS FOUND ❌\"\n        cpu_ok = False\n\n      rows.append([proc_name, usage, expected, max_allowed, error or \"✅\"])\n    print(tabulate(rows, header, tablefmt=\"simple_grid\", stralign=\"center\", numalign=\"center\", floatfmt=\".2f\"))\n\n    # Ensure there's no missing procs\n    all_procs = {p.name for p in self.msgs['managerState'][0].managerState.processes if p.shouldBeRunning}\n    for p in all_procs:\n      with subtests.test(proc=p):\n        assert any(p in pp for pp in PROCS.keys()), f\"Expected CPU usage missing for {p}\"\n\n    # total CPU check\n    procs_tot = sum([(max(x) if isinstance(x, tuple) else x) for x in PROCS.values()])\n    with subtests.test(name=\"total CPU\"):\n      assert procs_tot < MAX_TOTAL_CPU, \"Total CPU budget exceeded\"\n    print(\"------------------------------------------------\")\n    print(f\"Total allocated CPU usage is {procs_tot}%, budget is {MAX_TOTAL_CPU}%, {MAX_TOTAL_CPU-procs_tot:.1f}% left\")\n    print(\"------------------------------------------------\")\n\n    assert cpu_ok\n\n  def test_memory_usage(self):\n    print(\"\\n------------------------------------------------\")\n    print(\"--------------- Memory Usage -------------------\")\n    print(\"------------------------------------------------\")\n    offset = int(SERVICE_LIST['deviceState'].frequency * LOG_OFFSET)\n    mems = [m.deviceState.memoryUsagePercent for m in self.msgs['deviceState'][offset:]]\n    print(\"Memory usage: \", mems)\n\n    # check for big leaks. note that memory usage is\n    # expected to go up while the MSGQ buffers fill up\n    assert np.average(mems) <= 65, \"Average memory usage above 65%\"\n    assert np.max(np.diff(mems)) <= 4, \"Max memory increase too high\"\n    assert np.average(np.diff(mems)) <= 1, \"Average memory increase too high\"\n\n  def test_camera_frame_timings(self, subtests):\n    # test timing within a single camera\n    result = \"\\n\"\n    result += \"------------------------------------------------\\n\"\n    result += \"-----------------  SOF Timing ------------------\\n\"\n    result += \"------------------------------------------------\\n\"\n    for name in ['roadCameraState', 'wideRoadCameraState', 'driverCameraState']:\n      ts = self.ts[name]['timestampSof']\n      d_ms = np.diff(ts) / 1e6\n      d50 = np.abs(d_ms-50)\n      result += f\"{name} sof delta vs 50ms: min  {min(d50):.2f}ms\\n\"\n      result += f\"{name} sof delta vs 50ms: max  {max(d50):.2f}ms\\n\"\n      result += f\"{name} sof delta vs 50ms: mean {d50.mean():.2f}ms\\n\"\n      with subtests.test(camera=name):\n        assert max(d50) < 5.0, f\"high SOF delta vs 50ms: {max(d50)}\"\n    result += \"------------------------------------------------\\n\"\n    print(result)\n\n  def test_camera_sync(self, subtests):\n    cam_states = ['roadCameraState', 'wideRoadCameraState', 'driverCameraState']\n    encode_cams = ['roadEncodeIdx', 'wideRoadEncodeIdx', 'driverEncodeIdx']\n    for cams in (cam_states, encode_cams):\n      with subtests.test(cams=cams):\n        # sanity checks within a single cam\n        for cam in cams:\n          with subtests.test(test=\"frame_skips\", camera=cam):\n            assert set(np.diff(self.ts[cam]['frameId'])) == {1, }, \"Frame ID skips\"\n\n            # EOF > SOF\n            eof_sof_diff = self.ts[cam]['timestampEof'] - self.ts[cam]['timestampSof']\n            assert np.all(eof_sof_diff > 0)\n            assert np.all(eof_sof_diff < 50*1e6)\n\n        first_fid = {min(self.ts[c]['frameId']) for c in cams}\n        assert len(first_fid) == 1, \"Cameras don't start on same frame ID\"\n        if cam.endswith('CameraState'):\n          # camerad guarantees that all cams start on frame ID 0\n          # (note loggerd also needs to start up fast enough to catch it)\n          assert next(iter(first_fid)) < 100, \"Cameras start on frame ID too high\"\n\n        # we don't do a full segment rotation, so these might not match exactly\n        last_fid = {max(self.ts[c]['frameId']) for c in cams}\n        assert max(last_fid) - min(last_fid) < 10\n\n        start, end = min(first_fid), min(last_fid)\n        for i in range(end-start):\n          ts = {c: round(self.ts[c]['timestampSof'][i]/1e6, 1) for c in cams}\n          diff = (max(ts.values()) - min(ts.values()))\n          assert diff < 2, f\"Cameras not synced properly: frame_id={start+i}, {diff=:.1f}ms, {ts=}\"\n\n  def test_camera_encoder_matches(self, subtests):\n    # sanity check that the frame metadata is consistent with the encoded frames\n    pairs = [('roadCameraState', 'roadEncodeIdx'),\n             ('wideRoadCameraState', 'wideRoadEncodeIdx'),\n             ('driverCameraState', 'driverEncodeIdx')]\n    for cam, enc in pairs:\n      with subtests.test(camera=cam, encoder=enc):\n        cam_frames = {fid: (sof, eof) for fid, sof, eof in zip(\n          self.ts[cam]['frameId'],\n          self.ts[cam]['timestampSof'],\n          self.ts[cam]['timestampEof'],\n          strict=True,\n        )}\n        for i, fid in enumerate(self.ts[enc]['frameId']):\n          cam_sof, cam_eof = cam_frames[fid]\n          enc_sof, enc_eof = self.ts[enc]['timestampSof'][i], self.ts[enc]['timestampEof'][i]\n          assert enc_sof == cam_sof, f\"SOF mismatch: frameId={fid}, enc_sof={enc_sof}, cam_sof={cam_sof}\"\n          assert enc_eof == cam_eof, f\"EOF mismatch: frameId={fid}, enc_eof={enc_eof}, cam_eof={cam_eof}\"\n\n  def test_mpc_execution_timings(self):\n    result = \"\\n\"\n    result += \"------------------------------------------------\\n\"\n    result += \"-----------------  MPC Timing ------------------\\n\"\n    result += \"------------------------------------------------\\n\"\n\n    cfgs = [(\"longitudinalPlan\", 0.05, 0.05),]\n    for (s, instant_max, avg_max) in cfgs:\n      ts = [getattr(m, s).solverExecutionTime for m in self.msgs[s]]\n      assert max(ts) < instant_max, f\"high '{s}' execution time: {max(ts)}\"\n      assert np.mean(ts) < avg_max, f\"high avg '{s}' execution time: {np.mean(ts)}\"\n      result += f\"'{s}' execution time: min  {min(ts):.5f}s\\n\"\n      result += f\"'{s}' execution time: max  {max(ts):.5f}s\\n\"\n      result += f\"'{s}' execution time: mean {np.mean(ts):.5f}s\\n\"\n    result += \"------------------------------------------------\\n\"\n    print(result)\n\n  def test_model_execution_timings(self, subtests):\n    result = \"\\n\"\n    result += \"------------------------------------------------\\n\"\n    result += \"----------------- Model Timing -----------------\\n\"\n    result += \"------------------------------------------------\\n\"\n    cfgs = [\n      # since multiple processes use the GPU and can preempt each other,\n      # these numbers are not fully self-contained.\n      (\"modelV2\", 0.06, 0.040),\n\n      # can miss cycles here and there, just important the avg frequency is 20Hz\n      (\"driverStateV2\", 0.3, 0.05),\n    ]\n    for (s, instant_max, avg_max) in cfgs:\n      ts = [getattr(m, s).modelExecutionTime for m in self.msgs[s]]\n      # TODO some init can happen in first iteration\n      ts = ts[1:]\n      result += f\"'{s}' execution time: min  {min(ts):.5f}s\\n\"\n      result += f\"'{s}' execution time: max {max(ts):.5f}s\\n\"\n      result += f\"'{s}' execution time: mean {np.mean(ts):.5f}s\\n\"\n      with subtests.test(s):\n        assert max(ts) < instant_max, f\"high '{s}' execution time: {max(ts)}\"\n        assert np.mean(ts) < avg_max, f\"high avg '{s}' execution time: {np.mean(ts)}\"\n    result += \"------------------------------------------------\\n\"\n    print(result)\n\n  def test_timings(self):\n    passed = True\n    print(\"\\n------------------------------------------------\")\n    print(\"----------------- Service Timings --------------\")\n    print(\"------------------------------------------------\")\n\n    header = ['service', 'max', 'min', 'mean', 'expected mean', 'rsd', 'max allowed rsd', 'test result']\n    rows = []\n    for s, (maxmin, rsd) in TIMINGS.items():\n      offset = int(SERVICE_LIST[s].frequency * LOG_OFFSET)\n      msgs = [m.logMonoTime for m in self.msgs[s][offset:]]\n      if not len(msgs):\n        raise Exception(f\"missing {s}\")\n\n      ts = np.diff(msgs) / 1e9\n      dt = 1 / SERVICE_LIST[s].frequency\n\n      errors = []\n      if not np.allclose(np.mean(ts), dt, rtol=0.03, atol=0):\n        errors.append(\"❌ FAILED MEAN TIMING CHECK ❌\")\n      if not np.allclose([np.max(ts), np.min(ts)], dt, rtol=maxmin, atol=0):\n        errors.append(\"❌ FAILED MAX/MIN TIMING CHECK ❌\")\n      if (np.std(ts)/dt) > rsd:\n        errors.append(\"❌ FAILED RSD TIMING CHECK ❌\")\n      passed = not errors and passed\n      rows.append([s, *(np.array([np.max(ts), np.min(ts), np.mean(ts), dt])*1e3), np.std(ts)/dt, rsd, \"\\n\".join(errors) or \"✅\"])\n\n    print(tabulate(rows, header, tablefmt=\"simple_grid\", stralign=\"center\", numalign=\"center\", floatfmt=\".2f\"))\n    assert passed\n\n  @release_only\n  def test_startup(self):\n    startup_alert = self.ts['selfdriveState']['alertText1'][0]\n    expected = EVENTS[log.OnroadEvent.EventName.startup][ET.PERMANENT].alert_text_1\n    assert startup_alert == expected, \"wrong startup alert\"\n\n  def test_engagable(self):\n    no_entries = Counter()\n    for m in self.msgs['onroadEvents']:\n      for evt in m.onroadEvents:\n        if evt.noEntry:\n          no_entries[evt.name] += 1\n\n    offset = int(SERVICE_LIST['selfdriveState'].frequency * LOG_OFFSET)\n    eng = [m.selfdriveState.engageable for m in self.msgs['selfdriveState'][offset:]]\n    assert all(eng), \\\n           f\"Not engageable for whole segment:\\n- selfdriveState.engageable: {Counter(eng)}\\n- No entry events: {no_entries}\"", "target": "test onroad"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/helpers.py:Handler:0", "source": "  class CLASSTOKEN(http.server.SimpleHTTPRequestHandler):\n    API_NO_RESPONSE = False\n    API_BAD_RESPONSE = False\n\n    def do_GET(self):\n      if self.API_NO_RESPONSE:\n        return\n\n      if self.API_BAD_RESPONSE:\n        self.send_response(500, \"\")\n        return\n      super().do_GET()\n\n    def __init__(self, *args, **kwargs):\n      super().__init__(*args, directory=str(directory), **kwargs)", "target": "handler"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:LauncherWithCapture:0", "source": "class CLASSTOKEN:\n  def __init__(self, capture: ProcessOutputCapture, launcher: Callable):\n    self.capture = capture\n    self.launcher = launcher\n\n  def __call__(self, *args, **kwargs):\n    self.capture.link_with_current_proc()\n    self.launcher(*args, **kwargs)", "target": "launcher with capture"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:ReplayContext:1", "source": "class CLASSTOKEN:\n  def __init__(self, cfg):\n    self.proc_name = cfg.proc_name\n    self.pubs = cfg.pubs\n    self.main_pub = cfg.main_pub\n    self.main_pub_drained = cfg.main_pub_drained\n    assert len(self.pubs) != 0 or self.main_pub is not None\n\n  def __enter__(self):\n    self.open_context()\n\n    return self\n\n  def __exit__(self, exc_type, exc_obj, exc_tb):\n    self.close_context()\n\n  def open_context(self):\n    messaging.toggle_fake_events(True)\n    messaging.set_fake_prefix(self.proc_name)\n\n    if self.main_pub is None:\n      self.events = {}\n      for pub in self.pubs:\n        self.events[pub] = messaging.fake_event_handle(pub, enable=True)\n    else:\n      self.events = {self.main_pub: messaging.fake_event_handle(self.main_pub, enable=True)}\n\n  def close_context(self):\n    del self.events\n\n    messaging.toggle_fake_events(False)\n    messaging.delete_fake_prefix()\n\n  @property\n  def all_recv_called_events(self):\n    return [man.recv_called_event for man in self.events.values()]\n\n  @property\n  def all_recv_ready_events(self):\n    return [man.recv_ready_event for man in self.events.values()]\n\n  def send_sync(self, pm, endpoint, dat):\n    self.events[endpoint].recv_called_event.wait()\n    self.events[endpoint].recv_called_event.clear()\n    pm.send(endpoint, dat)\n    self.events[endpoint].recv_ready_event.set()\n\n  def unlock_sockets(self):\n    expected_sets = len(self.events)\n    while expected_sets > 0:\n      index = messaging.wait_for_one_event(self.all_recv_called_events)\n      self.all_recv_called_events[index].clear()\n      self.all_recv_ready_events[index].set()\n      expected_sets -= 1\n\n  def wait_for_recv_called(self):\n    messaging.wait_for_one_event(self.all_recv_called_events)\n\n  def wait_for_next_recv(self, trigger_empty_recv):\n    index = messaging.wait_for_one_event(self.all_recv_called_events)\n    if self.main_pub is not None and self.main_pub_drained and trigger_empty_recv:\n      self.all_recv_called_events[index].clear()\n      self.all_recv_ready_events[index].set()\n      self.all_recv_called_events[index].wait()", "target": "replay context"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:ProcessConfig:2", "source": "class CLASSTOKEN:\n  proc_name: str\n  pubs: list[str]\n  subs: list[str]\n  ignore: list[str]\n  config_callback: Callable | None = None\n  init_callback: Callable | None = None\n  should_recv_callback: Callable | None = None\n  tolerance: float | None = None\n  processing_time: float = 0.001\n  timeout: int = 30\n  simulation: bool = True\n  # Set to service process receives on first\n  main_pub: str | None = None\n  main_pub_drained: bool = False\n  vision_pubs: list[str] = field(default_factory=list)\n  ignore_alive_pubs: list[str] = field(default_factory=list)\n\n  def __post_init__(self):\n    # If the process is polling a service, we can just lock that one to speed up replay\n    if self.main_pub is None and isinstance(self.should_recv_callback, MessageBasedRcvCallback):\n      self.main_pub = self.should_recv_callback.trigger_msg_type", "target": "process config"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:ProcessContainer:3", "source": "class CLASSTOKEN:\n  def __init__(self, cfg: ProcessConfig):\n    self.prefix = OpenpilotPrefix(create_dirs_on_enter=False, clean_dirs_on_exit=False)\n    self.cfg = copy.deepcopy(cfg)\n    self.process = copy.deepcopy(managed_processes[cfg.proc_name])\n    self.msg_queue: list[capnp._DynamicStructReader] = []\n    self.cnt = 0\n    self.pm: messaging.PubMaster | None = None\n    self.sockets: list[messaging.SubSocket] | None = None\n    self.rc: ReplayContext | None = None\n    self.vipc_server: VisionIpcServer | None = None\n    self.environ_config: dict[str, Any] | None = None\n    self.capture: ProcessOutputCapture | None = None\n\n  @property\n  def has_empty_queue(self) -> bool:\n    return len(self.msg_queue) == 0\n\n  @property\n  def pubs(self) -> list[str]:\n    return self.cfg.pubs\n\n  @property\n  def subs(self) -> list[str]:\n    return self.cfg.subs\n\n  def _clean_env(self):\n    for k in self.environ_config.keys():\n      if k in os.environ:\n        del os.environ[k]\n\n    for k in [\"PROC_NAME\", \"SIMULATION\"]:\n      if k in os.environ:\n        del os.environ[k]\n\n  def _setup_env(self, params_config: dict[str, Any], environ_config: dict[str, Any]):\n    for k, v in environ_config.items():\n      if len(v) != 0:\n        os.environ[k] = v\n      elif k in os.environ:\n        del os.environ[k]\n\n    os.environ[\"PROC_NAME\"] = self.cfg.proc_name\n    if self.cfg.simulation:\n      os.environ[\"SIMULATION\"] = \"1\"\n    elif \"SIMULATION\" in os.environ:\n      del os.environ[\"SIMULATION\"]\n\n    params = Params()\n    for k, v in params_config.items():\n      if isinstance(v, bool):\n        params.put_bool(k, v)\n      else:\n        params.put(k, v)\n\n    self.environ_config = environ_config\n\n  def _setup_vision_ipc(self, all_msgs: LogIterable, frs: dict[str, Any]):\n    assert len(self.cfg.vision_pubs) != 0\n\n    vipc_server = VisionIpcServer(\"camerad\")\n    streams_metas = available_streams(all_msgs)\n    for meta in streams_metas:\n      if meta.camera_state in self.cfg.vision_pubs:\n        assert frs[meta.camera_state].pix_fmt == 'nv12'\n        frame_size = (frs[meta.camera_state].w, frs[meta.camera_state].h)\n        vipc_server.create_buffers(meta.stream, 2, *frame_size)\n    vipc_server.start_listener()\n\n    self.vipc_server = vipc_server\n    self.cfg.vision_pubs = [meta.camera_state for meta in streams_metas if meta.camera_state in self.cfg.vision_pubs]\n\n  def _start_process(self):\n    if self.capture is not None:\n      self.process.launcher = LauncherWithCapture(self.capture, self.process.launcher)\n    self.process.prepare()\n    self.process.start()\n\n  def start(\n    self, params_config: dict[str, Any], environ_config: dict[str, Any],\n    all_msgs: LogIterable, frs: dict[str, FrameReader] | None,\n    fingerprint: str | None, capture_output: bool\n  ):\n    with self.prefix as p:\n      self.prefix.create_dirs()\n      self._setup_env(params_config, environ_config)\n\n      if self.cfg.config_callback is not None:\n        params = Params()\n        self.cfg.config_callback(params, self.cfg, all_msgs)\n\n      self.rc = ReplayContext(self.cfg)\n      self.rc.open_context()\n\n      self.pm = messaging.PubMaster(self.cfg.pubs)\n      self.sockets = [messaging.sub_sock(s, timeout=100) for s in self.cfg.subs]\n\n      if len(self.cfg.vision_pubs) != 0:\n        assert frs is not None\n        self._setup_vision_ipc(all_msgs, frs)\n        assert self.vipc_server is not None\n\n      if capture_output:\n        self.capture = ProcessOutputCapture(self.cfg.proc_name, p.prefix)\n\n      self._start_process()\n\n      if self.cfg.init_callback is not None:\n        self.cfg.init_callback(self.rc, self.pm, all_msgs, fingerprint)\n\n  def stop(self):\n    with self.prefix:\n      self.process.signal(signal.SIGKILL)\n      self.process.stop()\n      self.rc.close_context()\n      self.prefix.clean_dirs()\n      self._clean_env()\n\n  def get_output_msgs(self, start_time: int):\n    assert self.rc and self.sockets\n\n    output_msgs = []\n    self.rc.wait_for_recv_called()\n    for socket in self.sockets:\n      ms = messaging.drain_sock(socket)\n      for m in ms:\n        m = m.as_builder()\n        m.logMonoTime = start_time + int(self.cfg.processing_time * 1e9)\n        output_msgs.append(m.as_reader())\n    return output_msgs\n\n  def run_step(self, msg: capnp._DynamicStructReader, frs: dict[str, FrameReader] | None) -> list[capnp._DynamicStructReader]:\n    assert self.rc and self.pm and self.sockets and self.process.proc\n\n    output_msgs = []\n    end_of_cycle = True\n    if self.cfg.should_recv_callback is not None:\n      end_of_cycle = self.cfg.should_recv_callback(msg, self.cfg, self.cnt)\n\n    self.msg_queue.append(msg)\n    if end_of_cycle:\n      with self.prefix, Timeout(self.cfg.timeout, error_msg=f\"timed out testing process {repr(self.cfg.proc_name)}\"):\n        # call recv to let sub-sockets reconnect, after we know the process is ready\n        if self.cnt == 0:\n          for s in self.sockets:\n            messaging.recv_one_or_none(s)\n\n        # certain processes use drain_sock. need to cause empty recv to break from this loop\n        trigger_empty_recv = False\n        if self.cfg.main_pub and self.cfg.main_pub_drained:\n          trigger_empty_recv = any(m.which() == self.cfg.main_pub for m in self.msg_queue)\n\n        # get output msgs from previous inputs\n        output_msgs = self.get_output_msgs(msg.logMonoTime)\n\n        for m in self.msg_queue:\n          self.pm.send(m.which(), m.as_builder())\n          # send frames if needed\n          if self.vipc_server is not None and m.which() in self.cfg.vision_pubs:\n            camera_state = getattr(m, m.which())\n            camera_meta = meta_from_camera_state(m.which())\n            assert frs is not None\n            img = frs[m.which()].get(camera_state.frameId)\n            self.vipc_server.send(camera_meta.stream, img.flatten().tobytes(),\n                                  camera_state.frameId, camera_state.timestampSof, camera_state.timestampEof)\n        self.msg_queue = []\n\n        self.rc.unlock_sockets()\n        if trigger_empty_recv:\n          self.rc.unlock_sockets()\n        self.cnt += 1\n    assert self.process.proc.is_alive()\n\n    return output_msgs", "target": "process container"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:ModeldCameraSyncRcvCallback:4", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.road_present = False\n    self.wide_road_present = False\n    self.is_dual_camera = True\n\n  def __call__(self, msg, cfg, frame):\n    self.is_dual_camera = len(cfg.vision_pubs) == 2\n    if msg.which() == \"roadCameraState\":\n      self.road_present = True\n    elif msg.which() == \"wideRoadCameraState\":\n      self.wide_road_present = True\n\n    if self.road_present and self.wide_road_present:\n      self.road_present, self.wide_road_present = False, False\n      return True\n    elif self.road_present and not self.is_dual_camera:\n      self.road_present = False\n      return True\n    else:\n      return False", "target": "modeld camera sync rcv callback"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/process_replay.py:MessageBasedRcvCallback:5", "source": "class CLASSTOKEN:\n  def __init__(self, trigger_msg_type: str, first_frame: bool = False):\n    self.trigger_msg_type = trigger_msg_type\n    self.first_frame = first_frame\n\n  def __call__(self, msg, cfg, frame):\n    # publish on first frame or trigger msg\n    return ((frame - 1) == 0 and self.first_frame) or msg.which() == self.trigger_msg_type", "target": "message based rcv callback"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/test_regen.py:TestRegen:0", "source": "class CLASSTOKEN:\n  @parameterized.expand(TESTED_SEGMENTS)\n  def test_engaged(self, case_name, segment):\n    route, sidx = segment.rsplit(\"--\", 1)\n    lr, frs = ci_setup_data_readers(route, sidx)\n    output_logs = regen_segment(lr, frs, disable_tqdm=True)\n\n    engaged = check_openpilot_enabled(output_logs)\n    assert engaged, f\"openpilot not engaged in {case_name}\"", "target": "test regen"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/test_fuzzy.py:TestFuzzProcesses:0", "source": "class CLASSTOKEN:\n\n  # TODO: make this faster and increase examples\n  @parameterized.expand(TEST_CASES)\n  @given(st.data())\n  @settings(phases=[Phase.generate, Phase.target], max_examples=MAX_EXAMPLES, deadline=1000,\n            suppress_health_check=[HealthCheck.too_slow, HealthCheck.data_too_large])\n  def test_fuzz_process(self, proc_name, cfg, data):\n    msgs = FuzzyGenerator.get_random_event_msg(data.draw, events=cfg.pubs, real_floats=True)\n    lr = [log.Event.new_message(**m).as_reader() for m in msgs]\n    cfg.timeout = 5\n    pr.replay_process(cfg, lr, fingerprint=TOYOTA.TOYOTA_COROLLA_TSS2, disable_progress=True)", "target": "test fuzz processes"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/capture.py:FdRedirect:0", "source": "class CLASSTOKEN:\n  def __init__(self, file_prefix: str, fd: int):\n    fname = os.path.join(\"/tmp\", f\"{file_prefix}.{fd}\")\n    if os.path.exists(fname):\n      os.unlink(fname)\n    self.dest_fd = os.open(fname, os.O_WRONLY | os.O_CREAT)\n    self.dest_fname = fname\n    self.source_fd = fd\n    os.set_inheritable(self.dest_fd, True)\n\n  def __del__(self):\n    os.close(self.dest_fd)\n\n  def purge(self) -> None:\n    os.unlink(self.dest_fname)\n\n  def read(self) -> bytes:\n    with open(self.dest_fname, \"rb\") as f:\n      return f.read() or b\"\"\n\n  def link(self) -> None:\n    os.dup2(self.dest_fd, self.source_fd)", "target": "fd redirect"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/capture.py:ProcessOutputCapture:1", "source": "class CLASSTOKEN:\n  def __init__(self, proc_name: str, prefix: str):\n    prefix = f\"{proc_name}_{prefix}\"\n    self.stdout_redirect = FdRedirect(prefix, 1)\n    self.stderr_redirect = FdRedirect(prefix, 2)\n\n  def __del__(self):\n    self.stdout_redirect.purge()\n    self.stderr_redirect.purge()\n\n  @no_type_check # ipython classes have incompatible signatures\n  def link_with_current_proc(self) -> None:\n    try:\n      # prevent ipykernel from redirecting stdout/stderr of python subprocesses\n      from ipykernel.iostream import OutStream\n      if isinstance(sys.stdout, OutStream):\n        sys.stdout = sys.__stdout__\n      if isinstance(sys.stderr, OutStream):\n        sys.stderr = sys.__stderr__\n    except ImportError:\n      pass\n\n    # link stdout/stderr to the fifo\n    self.stdout_redirect.link()\n    self.stderr_redirect.link()\n\n  def read_outerr(self) -> tuple[str, str]:\n    out_str = self.stdout_redirect.read().decode()\n    err_str = self.stderr_redirect.read().decode()\n    return out_str, err_str", "target": "process output capture"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/longitudinal_maneuvers/test_longitudinal.py:TestLongitudinalControl:0", "source": "class CLASSTOKEN:\n  e2e: bool\n  force_decel: bool\n\n  def test_maneuver(self, subtests):\n    for maneuver in create_maneuvers({\"e2e\": self.e2e, \"force_decel\": self.force_decel}):\n      with subtests.test(title=maneuver.title, e2e=maneuver.e2e, force_decel=maneuver.force_decel):\n        print(maneuver.title, f'in {\"e2e\" if maneuver.e2e else \"acc\"} mode')\n        valid, _ = maneuver.evaluate()\n        assert valid", "target": "test longitudinal control"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/longitudinal_maneuvers/maneuver.py:Maneuver:0", "source": "class CLASSTOKEN:\n  def __init__(self, title, duration, **kwargs):\n    # Was tempted to make a builder class\n    self.distance_lead = kwargs.get(\"initial_distance_lead\", 200.0)\n    self.speed = kwargs.get(\"initial_speed\", 0.0)\n    self.lead_relevancy = kwargs.get(\"lead_relevancy\", 0)\n\n    self.breakpoints = kwargs.get(\"breakpoints\", [0.0, duration])\n    self.speed_lead_values = kwargs.get(\"speed_lead_values\", [0.0 for i in range(len(self.breakpoints))])\n    self.prob_lead_values = kwargs.get(\"prob_lead_values\", [1.0 for i in range(len(self.breakpoints))])\n    self.prob_throttle_values = kwargs.get(\"prob_throttle_values\", [1.0 for i in range(len(self.breakpoints))])\n    self.cruise_values = kwargs.get(\"cruise_values\", [50.0 for i in range(len(self.breakpoints))])\n    self.pitch_values = kwargs.get(\"pitch_values\", [0.0 for i in range(len(self.breakpoints))])\n\n    self.only_lead2 = kwargs.get(\"only_lead2\", False)\n    self.only_radar = kwargs.get(\"only_radar\", False)\n    self.ensure_start = kwargs.get(\"ensure_start\", False)\n    self.ensure_slowdown = kwargs.get(\"ensure_slowdown\", False)\n    self.enabled = kwargs.get(\"enabled\", True)\n    self.e2e = kwargs.get(\"e2e\", False)\n    self.personality = kwargs.get(\"personality\", 0)\n    self.force_decel = kwargs.get(\"force_decel\", False)\n\n    self.duration = duration\n    self.title = title\n\n  def evaluate(self):\n    plant = Plant(\n      lead_relevancy=self.lead_relevancy,\n      speed=self.speed,\n      distance_lead=self.distance_lead,\n      enabled=self.enabled,\n      only_lead2=self.only_lead2,\n      only_radar=self.only_radar,\n      e2e=self.e2e,\n      personality=self.personality,\n      force_decel=self.force_decel,\n    )\n\n    valid = True\n    logs = []\n    while plant.current_time < self.duration:\n      speed_lead = np.interp(plant.current_time, self.breakpoints, self.speed_lead_values)\n      prob_lead = np.interp(plant.current_time, self.breakpoints, self.prob_lead_values)\n      cruise = np.interp(plant.current_time, self.breakpoints, self.cruise_values)\n      pitch = np.interp(plant.current_time, self.breakpoints, self.pitch_values)\n      prob_throttle = np.interp(plant.current_time, self.breakpoints, self.prob_throttle_values)\n      log = plant.step(speed_lead, prob_lead, cruise, pitch, prob_throttle)\n\n      d_rel = log['distance_lead'] - log['distance'] if self.lead_relevancy else 200.\n      v_rel = speed_lead - log['speed'] if self.lead_relevancy else 0.\n      log['d_rel'] = d_rel\n      log['v_rel'] = v_rel\n      logs.append(np.array([plant.current_time,\n                            log['distance'],\n                            log['distance_lead'],\n                            log['speed'],\n                            speed_lead,\n                            log['acceleration']]))\n\n      if d_rel < .4 and (self.only_radar or prob_lead > 0.5):\n        print(\"Crashed!!!!\")\n        valid = False\n\n      if self.ensure_start and log['v_rel'] > 0 and log['acceleration'] < 1e-3:\n        print('LongitudinalPlanner not starting!')\n        valid = False\n\n    if self.ensure_slowdown and log['speed'] > 5.5:\n      print('LongitudinalPlanner not slowing down!')\n      valid = False\n\n    if self.force_decel and log['speed'] > 1e-1 and log['acceleration'] > -0.04:\n      print('Not stopping with force decel')\n      valid = False\n\n\n    print(\"maneuver end\", valid)\n    return valid, np.array(logs)", "target": "maneuver"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/longitudinal_maneuvers/plant.py:Plant:0", "source": "class CLASSTOKEN:\n  messaging_initialized = False\n\n  def __init__(self, lead_relevancy=False, speed=0.0, distance_lead=2.0,\n               enabled=True, only_lead2=False, only_radar=False, e2e=False, personality=0, force_decel=False):\n    self.rate = 1. / DT_MDL\n\n    if not CLASSTOKEN.messaging_initialized:\n      CLASSTOKEN.radar = messaging.pub_sock('radarState')\n      CLASSTOKEN.controls_state = messaging.pub_sock('controlsState')\n      CLASSTOKEN.selfdrive_state = messaging.pub_sock('selfdriveState')\n      CLASSTOKEN.car_state = messaging.pub_sock('carState')\n      CLASSTOKEN.plan = messaging.sub_sock('longitudinalPlan')\n      CLASSTOKEN.messaging_initialized = True\n\n    self.v_lead_prev = 0.0\n\n    self.distance = 0.\n    self.speed = speed\n    self.should_stop = False\n    self.acceleration = 0.0\n\n    # lead car\n    self.lead_relevancy = lead_relevancy\n    self.distance_lead = distance_lead\n    self.enabled = enabled\n    self.only_lead2 = only_lead2\n    self.only_radar = only_radar\n    self.e2e = e2e\n    self.personality = personality\n    self.force_decel = force_decel\n\n    self.rk = Ratekeeper(self.rate, print_delay_threshold=100.0)\n    self.ts = 1. / self.rate\n    time.sleep(0.1)\n    self.sm = messaging.SubMaster(['longitudinalPlan'])\n\n    from opendbc.car.honda.values import CAR\n    from opendbc.car.honda.interface import CarInterface\n\n    self.planner = LongitudinalPlanner(CarInterface.get_non_essential_params(CAR.HONDA_CIVIC), init_v=self.speed)\n\n  @property\n  def current_time(self):\n    return float(self.rk.frame) / self.rate\n\n  def step(self, v_lead=0.0, prob_lead=1.0, v_cruise=50., pitch=0.0, prob_throttle=1.0):\n    # ******** publish a fake model going straight and fake calibration ********\n    # note that this is worst case for MPC, since model will delay long mpc by one time step\n    radar = messaging.new_message('radarState')\n    control = messaging.new_message('controlsState')\n    ss = messaging.new_message('selfdriveState')\n    car_state = messaging.new_message('carState')\n    lp = messaging.new_message('liveParameters')\n    car_control = messaging.new_message('carControl')\n    model = messaging.new_message('modelV2')\n    a_lead = (v_lead - self.v_lead_prev)/self.ts\n    self.v_lead_prev = v_lead\n\n    if self.lead_relevancy:\n      d_rel = np.maximum(0., self.distance_lead - self.distance)\n      v_rel = v_lead - self.speed\n      if self.only_radar:\n        status = True\n      elif prob_lead > .5:\n        status = True\n      else:\n        status = False\n    else:\n      d_rel = 200.\n      v_rel = 0.\n      prob_lead = 0.0\n      status = False\n\n    lead = log.RadarState.LeadData.new_message()\n    lead.dRel = float(d_rel)\n    lead.yRel = 0.0\n    lead.vRel = float(v_rel)\n    lead.aRel = float(a_lead - self.acceleration)\n    lead.vLead = float(v_lead)\n    lead.vLeadK = float(v_lead)\n    lead.aLeadK = float(a_lead)\n    # TODO use real radard logic for this\n    lead.aLeadTau = float(_LEAD_ACCEL_TAU)\n    lead.status = status\n    lead.modelProb = float(prob_lead)\n    if not self.only_lead2:\n      radar.radarState.leadOne = lead\n    radar.radarState.leadTwo = lead\n\n    # Simulate model predicting slightly faster speed\n    # this is to ensure lead policy is effective when model\n    # does not predict slowdown in e2e mode\n    position = log.XYZTData.new_message()\n    position.x = [float(x) for x in (self.speed + 0.5) * np.array(ModelConstants.T_IDXS)]\n    model.modelV2.position = position\n    model.modelV2.action.desiredAcceleration = float(self.acceleration + 0.1)\n    velocity = log.XYZTData.new_message()\n    velocity.x = [float(x) for x in (self.speed + 0.5) * np.ones_like(ModelConstants.T_IDXS)]\n    velocity.x[0] = float(self.speed) # always start at current speed\n    model.modelV2.velocity = velocity\n    acceleration = log.XYZTData.new_message()\n    acceleration.x = [float(x) for x in np.zeros_like(ModelConstants.T_IDXS)]\n    model.modelV2.acceleration = acceleration\n    model.modelV2.meta.disengagePredictions.gasPressProbs = [float(prob_throttle) for _ in range(6)]\n\n    control.controlsState.longControlState = LongCtrlState.pid if self.enabled else LongCtrlState.off\n    ss.selfdriveState.experimentalMode = self.e2e\n    ss.selfdriveState.personality = self.personality\n    control.controlsState.forceDecel = self.force_decel\n    car_state.carState.vEgo = float(self.speed)\n    car_state.carState.standstill = bool(self.speed < 0.01)\n    car_state.carState.vCruise = float(v_cruise * 3.6)\n    car_control.carControl.orientationNED = [0., float(pitch), 0.]\n\n    # ******** get controlsState messages for plotting ***\n    sm = {'radarState': radar.radarState,\n          'carState': car_state.carState,\n          'carControl': car_control.carControl,\n          'controlsState': control.controlsState,\n          'selfdriveState': ss.selfdriveState,\n          'liveParameters': lp.liveParameters,\n          'modelV2': model.modelV2}\n    self.planner.update(sm)\n    self.acceleration = self.planner.output_a_target\n    self.speed = self.speed + self.acceleration * self.ts\n    self.should_stop = self.planner.output_should_stop\n    fcw = self.planner.fcw\n    self.distance_lead = self.distance_lead + v_lead * self.ts\n\n    # ******** run the car ********\n    #print(self.distance, speed)\n    if self.speed <= 0:\n      self.speed = 0\n      self.acceleration = 0\n    self.distance = self.distance + self.speed * self.ts\n\n    # *** radar model ***\n    if self.lead_relevancy:\n      d_rel = np.maximum(0., self.distance_lead - self.distance)\n      v_rel = v_lead - self.speed\n    else:\n      d_rel = 200.\n      v_rel = 0.\n\n    # print at 5hz\n    # if (self.rk.frame % (self.rate // 5)) == 0:\n    #   print(\"%2.2f sec   %6.2f m  %6.2f m/s  %6.2f m/s2   lead_rel: %6.2f m  %6.2f m/s\"\n    #         % (self.current_time, self.distance, self.speed, self.acceleration, d_rel, v_rel))\n\n\n    # ******** update prevs ********\n    self.rk.monitor_time()\n\n    return {\n      \"distance\": self.distance,\n      \"speed\": self.speed,\n      \"acceleration\": self.acceleration,\n      \"should_stop\": self.should_stop,\n      \"distance_lead\": self.distance_lead,\n      \"fcw\": fcw,\n    }", "target": "plant"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/alertmanager.py:AlertEntry:0", "source": "class CLASSTOKEN:\n  alert: Alert | None = None\n  start_frame: int = -1\n  end_frame: int = -1\n  added_frame: int = -1\n\n  def active(self, frame: int) -> bool:\n    return frame <= self.end_frame\n\n  def just_added(self, frame: int) -> bool:\n    return self.active(frame) and frame == (self.added_frame + 1)", "target": "alert entry"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/alertmanager.py:AlertManager:1", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.alerts: dict[str, AlertEntry] = defaultdict(AlertEntry)\n    self.current_alert = EmptyAlert\n\n  def add_many(self, frame: int, alerts: list[Alert]) -> None:\n    for alert in alerts:\n      entry = self.alerts[alert.alert_type]\n      entry.alert = alert\n      if not entry.just_added(frame):\n        entry.start_frame = frame\n      min_end_frame = entry.start_frame + alert.duration\n      entry.end_frame = max(frame + 1, min_end_frame)\n      entry.added_frame = frame\n\n  def process_alerts(self, frame: int, clear_event_types: set):\n    ae = AlertEntry()\n    for v in self.alerts.values():\n      if not v.alert:\n        continue\n\n      if v.alert.event_type in clear_event_types:\n        v.end_frame = -1\n\n      # sort by priority first and then by start_frame\n      greater = ae.alert is None or (v.alert.priority, v.start_frame) > (ae.alert.priority, ae.start_frame)\n      if v.active(frame) and greater:\n        ae = v\n\n    self.current_alert = ae.alert if ae.alert is not None else EmptyAlert", "target": "alert manager"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/selfdrived.py:SelfdriveD:0", "source": "class CLASSTOKEN:\n  def __init__(self, CP=None):\n    self.params = Params()\n\n    # Ensure the current branch is cached, otherwise the first cycle lags\n    build_metadata = get_build_metadata()\n\n    if CP is None:\n      cloudlog.info(\"selfdrived is waiting for CarParams\")\n      self.CP = messaging.log_from_bytes(self.params.get(\"CarParams\", block=True), car.CarParams)\n      cloudlog.info(\"selfdrived got CarParams\")\n    else:\n      self.CP = CP\n\n    self.car_events = CarSpecificEvents(self.CP)\n\n    self.pose_calibrator = PoseCalibrator()\n    self.calibrated_pose: Pose | None = None\n    self.excessive_actuation_check = ExcessiveActuationCheck()\n    self.excessive_actuation = self.params.get(\"Offroad_ExcessiveActuation\") is not None\n\n    # Setup sockets\n    self.pm = messaging.PubMaster(['selfdriveState', 'onroadEvents'])\n\n    self.gps_location_service = get_gps_location_service(self.params)\n    self.gps_packets = [self.gps_location_service]\n    self.sensor_packets = [\"accelerometer\", \"gyroscope\"]\n    self.camera_packets = [\"roadCameraState\", \"driverCameraState\", \"wideRoadCameraState\"]\n\n    # TODO: de-couple selfdrived with card/conflate on carState without introducing controls mismatches\n    self.car_state_sock = messaging.sub_sock('carState', timeout=20)\n\n    ignore = self.sensor_packets + self.gps_packets + ['alertDebug']\n    if SIMULATION:\n      ignore += ['driverCameraState', 'managerState']\n    if REPLAY:\n      # no vipc in replay will make them ignored anyways\n      ignore += ['roadCameraState', 'wideRoadCameraState']\n    self.sm = messaging.SubMaster(['deviceState', 'pandaStates', 'peripheralState', 'modelV2', 'liveCalibration',\n                                   'carOutput', 'driverMonitoringState', 'longitudinalPlan', 'livePose', 'liveDelay',\n                                   'managerState', 'liveParameters', 'radarState', 'liveTorqueParameters',\n                                   'controlsState', 'carControl', 'driverAssistance', 'alertDebug', 'userBookmark', 'audioFeedback'] + \\\n                                   self.camera_packets + self.sensor_packets + self.gps_packets,\n                                  ignore_alive=ignore, ignore_avg_freq=ignore,\n                                  ignore_valid=ignore, frequency=int(1/DT_CTRL))\n\n    # read params\n    self.is_metric = self.params.get_bool(\"IsMetric\")\n    self.is_ldw_enabled = self.params.get_bool(\"IsLdwEnabled\")\n    self.disengage_on_accelerator = self.params.get_bool(\"DisengageOnAccelerator\")\n\n    car_recognized = self.CP.brand != 'mock'\n\n    # cleanup old params\n    if not self.CP.alphaLongitudinalAvailable:\n      self.params.remove(\"AlphaLongitudinalEnabled\")\n    if not self.CP.openpilotLongitudinalControl:\n      self.params.remove(\"ExperimentalMode\")\n\n    self.CS_prev = car.CarState.new_message()\n    self.AM = AlertManager()\n    self.events = Events()\n\n    self.initialized = False\n    self.enabled = False\n    self.active = False\n    self.mismatch_counter = 0\n    self.cruise_mismatch_counter = 0\n    self.last_steering_pressed_frame = 0\n    self.distance_traveled = 0\n    self.last_functional_fan_frame = 0\n    self.events_prev = []\n    self.logged_comm_issue = None\n    self.not_running_prev = None\n    self.experimental_mode = False\n    self.personality = self.params.get(\"LongitudinalPersonality\", return_default=True)\n    self.recalibrating_seen = False\n    self.state_machine = StateMachine()\n    self.rk = Ratekeeper(100, print_delay_threshold=None)\n\n    # Determine startup event\n    self.startup_event = EventName.startup if build_metadata.openpilot.comma_remote and build_metadata.tested_channel else EventName.startupMaster\n    if not car_recognized:\n      self.startup_event = EventName.startupNoCar\n    elif car_recognized and self.CP.passive:\n      self.startup_event = EventName.startupNoControl\n    elif self.CP.secOcRequired and not self.CP.secOcKeyAvailable:\n      self.startup_event = EventName.startupNoSecOcKey\n\n    if not car_recognized:\n      self.events.add(EventName.carUnrecognized, static=True)\n      set_offroad_alert(\"Offroad_CarUnrecognized\", True)\n    elif self.CP.passive:\n      self.events.add(EventName.dashcamMode, static=True)\n\n  def update_events(self, CS):\n    \"\"\"Compute onroadEvents from carState\"\"\"\n\n    self.events.clear()\n\n    if self.sm['controlsState'].lateralControlState.which() == 'debugState':\n      self.events.add(EventName.joystickDebug)\n      self.startup_event = None\n\n    if self.sm.recv_frame['alertDebug'] > 0:\n      self.events.add(EventName.longitudinalManeuver)\n      self.startup_event = None\n\n    # Add startup event\n    if self.startup_event is not None:\n      self.events.add(self.startup_event)\n      self.startup_event = None\n\n    # Don't add any more events if not initialized\n    if not self.initialized:\n      self.events.add(EventName.selfdriveInitializing)\n      return\n\n    # Check for user bookmark press (bookmark button or end of LKAS button feedback)\n    if self.sm.updated['userBookmark']:\n      self.events.add(EventName.userBookmark)\n\n    if self.sm.updated['audioFeedback']:\n      self.events.add(EventName.audioFeedback)\n\n    # Don't add any more events while in dashcam mode\n    if self.CP.passive:\n      return\n\n    # Block resume if cruise never previously enabled\n    resume_pressed = any(be.type in (ButtonType.accelCruise, ButtonType.resumeCruise) for be in CS.buttonEvents)\n    if not self.CP.pcmCruise and CS.vCruise > 250 and resume_pressed:\n      self.events.add(EventName.resumeBlocked)\n\n    if not self.CP.notCar:\n      self.events.add_from_msg(self.sm['driverMonitoringState'].events)\n\n    # Add car events, ignore if CAN isn't valid\n    if CS.canValid:\n      car_events = self.car_events.update(CS, self.CS_prev, self.sm['carControl']).to_msg()\n      self.events.add_from_msg(car_events)\n\n      if self.CP.notCar:\n        # wait for everything to init first\n        if self.sm.frame > int(5. / DT_CTRL) and self.initialized:\n          # body always wants to enable\n          self.events.add(EventName.pcmEnable)\n\n      # Disable on rising edge of accelerator or brake. Also disable on brake when speed > 0\n      if (CS.gasPressed and not self.CS_prev.gasPressed and self.disengage_on_accelerator) or \\\n        (CS.brakePressed and (not self.CS_prev.brakePressed or not CS.standstill)) or \\\n        (CS.regenBraking and (not self.CS_prev.regenBraking or not CS.standstill)):\n        self.events.add(EventName.pedalPressed)\n\n    # Create events for temperature, disk space, and memory\n    if self.sm['deviceState'].thermalStatus >= ThermalStatus.red:\n      self.events.add(EventName.overheat)\n    if self.sm['deviceState'].freeSpacePercent < 7 and not SIMULATION:\n      self.events.add(EventName.outOfSpace)\n    if self.sm['deviceState'].memoryUsagePercent > 90 and not SIMULATION:\n      self.events.add(EventName.lowMemory)\n\n    # Alert if fan isn't spinning for 5 seconds\n    if self.sm['peripheralState'].pandaType != log.PandaState.PandaType.unknown:\n      if self.sm['peripheralState'].fanSpeedRpm < 500 and self.sm['deviceState'].fanSpeedPercentDesired > 50:\n        # allow enough time for the fan controller in the panda to recover from stalls\n        if (self.sm.frame - self.last_functional_fan_frame) * DT_CTRL > 15.0:\n          self.events.add(EventName.fanMalfunction)\n      else:\n        self.last_functional_fan_frame = self.sm.frame\n\n    # Handle calibration status\n    cal_status = self.sm['liveCalibration'].calStatus\n    if cal_status != log.LiveCalibrationData.Status.calibrated:\n      if cal_status == log.LiveCalibrationData.Status.uncalibrated:\n        self.events.add(EventName.calibrationIncomplete)\n      elif cal_status == log.LiveCalibrationData.Status.recalibrating:\n        if not self.recalibrating_seen:\n          set_offroad_alert(\"Offroad_Recalibration\", True)\n        self.recalibrating_seen = True\n        self.events.add(EventName.calibrationRecalibrating)\n      else:\n        self.events.add(EventName.calibrationInvalid)\n\n    # Lane departure warning\n    if self.is_ldw_enabled and self.sm.valid['driverAssistance']:\n      if self.sm['driverAssistance'].leftLaneDeparture or self.sm['driverAssistance'].rightLaneDeparture:\n        self.events.add(EventName.ldw)\n\n    # ******************************************************************************************\n    #  NOTE: To fork maintainers.\n    #  Disabling or nerfing safety features will get you and your users banned from our servers.\n    #  We recommend that you do not change these numbers from the defaults.\n    if self.sm.updated['liveCalibration']:\n      self.pose_calibrator.feed_live_calib(self.sm['liveCalibration'])\n    if self.sm.updated['livePose']:\n      device_pose = Pose.from_live_pose(self.sm['livePose'])\n      self.calibrated_pose = self.pose_calibrator.build_calibrated_pose(device_pose)\n\n    if self.calibrated_pose is not None:\n      excessive_actuation = self.excessive_actuation_check.update(self.sm, CS, self.calibrated_pose)\n      if not self.excessive_actuation and excessive_actuation is not None:\n        set_offroad_alert(\"Offroad_ExcessiveActuation\", True, extra_text=str(excessive_actuation))\n        self.excessive_actuation = True\n\n    if self.excessive_actuation:\n      self.events.add(EventName.excessiveActuation)\n    # ******************************************************************************************\n\n    # Handle lane change\n    if self.sm['modelV2'].meta.laneChangeState == LaneChangeState.preLaneChange:\n      direction = self.sm['modelV2'].meta.laneChangeDirection\n      if (CS.leftBlindspot and direction == LaneChangeDirection.left) or \\\n         (CS.rightBlindspot and direction == LaneChangeDirection.right):\n        self.events.add(EventName.laneChangeBlocked)\n      else:\n        if direction == LaneChangeDirection.left:\n          self.events.add(EventName.preLaneChangeLeft)\n        else:\n          self.events.add(EventName.preLaneChangeRight)\n    elif self.sm['modelV2'].meta.laneChangeState in (LaneChangeState.laneChangeStarting,\n                                                    LaneChangeState.laneChangeFinishing):\n      self.events.add(EventName.laneChange)\n\n    for i, pandaState in enumerate(self.sm['pandaStates']):\n      # All pandas must match the list of safetyConfigs, and if outside this list, must be silent or noOutput\n      if i < len(self.CP.safetyConfigs):\n        safety_mismatch = pandaState.safetyModel != self.CP.safetyConfigs[i].safetyModel or \\\n                          pandaState.safetyParam != self.CP.safetyConfigs[i].safetyParam or \\\n                          pandaState.alternativeExperience != self.CP.alternativeExperience\n      else:\n        safety_mismatch = pandaState.safetyModel not in IGNORED_SAFETY_MODES\n\n      # safety mismatch allows some time for pandad to set the safety mode and publish it back from panda\n      if (safety_mismatch and self.sm.frame*DT_CTRL > 10.) or pandaState.safetyRxChecksInvalid or self.mismatch_counter >= 200:\n        self.events.add(EventName.controlsMismatch)\n\n      if log.PandaState.FaultType.relayMalfunction in pandaState.faults:\n        self.events.add(EventName.relayMalfunction)\n\n    # Handle HW and system malfunctions\n    # Order is very intentional here. Be careful when modifying this.\n    # All events here should at least have NO_ENTRY and SOFT_DISABLE.\n    num_events = len(self.events)\n\n    not_running = {p.name for p in self.sm['managerState'].processes if not p.running and p.shouldBeRunning}\n    if self.sm.recv_frame['managerState'] and len(not_running):\n      if not_running != self.not_running_prev:\n        cloudlog.event(\"process_not_running\", not_running=not_running, error=True)\n      self.not_running_prev = not_running\n    if self.sm.recv_frame['managerState'] and not_running:\n      self.events.add(EventName.processNotRunning)\n    else:\n      if not SIMULATION and not self.rk.lagging:\n        if not self.sm.all_alive(self.camera_packets):\n          self.events.add(EventName.cameraMalfunction)\n        elif not self.sm.all_freq_ok(self.camera_packets):\n          self.events.add(EventName.cameraFrameRate)\n    if not REPLAY and self.rk.lagging:\n      self.events.add(EventName.selfdrivedLagging)\n    if self.sm['radarState'].radarErrors.canError:\n      self.events.add(EventName.canError)\n    elif self.sm['radarState'].radarErrors.radarUnavailableTemporary:\n      self.events.add(EventName.radarTempUnavailable)\n    elif any(self.sm['radarState'].radarErrors.to_dict().values()):\n      self.events.add(EventName.radarFault)\n    if not self.sm.valid['pandaStates']:\n      self.events.add(EventName.usbError)\n    if CS.canTimeout:\n      self.events.add(EventName.canBusMissing)\n    elif not CS.canValid:\n      self.events.add(EventName.canError)\n\n    # generic catch-all. ideally, a more specific event should be added above instead\n    has_disable_events = self.events.contains(ET.NO_ENTRY) and (self.events.contains(ET.SOFT_DISABLE) or self.events.contains(ET.IMMEDIATE_DISABLE))\n    no_system_errors = (not has_disable_events) or (len(self.events) == num_events)\n    if not self.sm.all_checks() and no_system_errors:\n      if not self.sm.all_alive():\n        self.events.add(EventName.commIssue)\n      elif not self.sm.all_freq_ok():\n        self.events.add(EventName.commIssueAvgFreq)\n      else:\n        self.events.add(EventName.commIssue)\n\n      logs = {\n        'invalid': [s for s, valid in self.sm.valid.items() if not valid],\n        'not_alive': [s for s, alive in self.sm.alive.items() if not alive],\n        'not_freq_ok': [s for s, freq_ok in self.sm.freq_ok.items() if not freq_ok],\n      }\n      if logs != self.logged_comm_issue:\n        cloudlog.event(\"commIssue\", error=True, **logs)\n        self.logged_comm_issue = logs\n    else:\n      self.logged_comm_issue = None\n\n    if not self.CP.notCar:\n      if not self.sm['livePose'].posenetOK:\n        self.events.add(EventName.posenetInvalid)\n      if not self.sm['livePose'].inputsOK:\n        self.events.add(EventName.locationdTemporaryError)\n      if not self.sm['liveParameters'].valid and cal_status == log.LiveCalibrationData.Status.calibrated and not TESTING_CLOSET and (not SIMULATION or REPLAY):\n        self.events.add(EventName.paramsdTemporaryError)\n\n    # conservative HW alert. if the data or frequency are off, locationd will throw an error\n    if any((self.sm.frame - self.sm.recv_frame[s])*DT_CTRL > 10. for s in self.sensor_packets):\n      self.events.add(EventName.sensorDataInvalid)\n\n    if not REPLAY:\n      # Check for mismatch between openpilot and car's PCM\n      cruise_mismatch = CS.cruiseState.enabled and (not self.enabled or not self.CP.pcmCruise)\n      self.cruise_mismatch_counter = self.cruise_mismatch_counter + 1 if cruise_mismatch else 0\n      if self.cruise_mismatch_counter > int(6. / DT_CTRL):\n        self.events.add(EventName.cruiseMismatch)\n\n    # Send a \"steering required alert\" if saturation count has reached the limit\n    if CS.steeringPressed:\n      self.last_steering_pressed_frame = self.sm.frame\n    recent_steer_pressed = (self.sm.frame - self.last_steering_pressed_frame)*DT_CTRL < 2.0\n    controlstate = self.sm['controlsState']\n    lac = getattr(controlstate.lateralControlState, controlstate.lateralControlState.which())\n    if lac.active and not recent_steer_pressed and not self.CP.notCar:\n      clipped_speed = max(CS.vEgo, 0.3)\n      actual_lateral_accel = controlstate.curvature * (clipped_speed**2)\n      desired_lateral_accel = self.sm['modelV2'].action.desiredCurvature * (clipped_speed**2)\n      undershooting = abs(desired_lateral_accel) / abs(1e-3 + actual_lateral_accel) > 1.2\n      turning = abs(desired_lateral_accel) > 1.0\n      # TODO: lac.saturated includes speed and other checks, should be pulled out\n      if undershooting and turning and lac.saturated:\n        self.events.add(EventName.steerSaturated)\n\n    # Check for FCW\n    stock_long_is_braking = self.enabled and not self.CP.openpilotLongitudinalControl and CS.aEgo < -1.25\n    model_fcw = self.sm['modelV2'].meta.hardBrakePredicted and not CS.brakePressed and not stock_long_is_braking\n    planner_fcw = self.sm['longitudinalPlan'].fcw and self.enabled\n    if (planner_fcw or model_fcw) and not self.CP.notCar:\n      self.events.add(EventName.fcw)\n\n    # GPS checks\n    gps_ok = self.sm.recv_frame[self.gps_location_service] > 0 and (self.sm.frame - self.sm.recv_frame[self.gps_location_service]) * DT_CTRL < 2.0\n    if not gps_ok and self.sm['livePose'].inputsOK and (self.distance_traveled > 1500):\n      self.events.add(EventName.noGps)\n    if gps_ok:\n      self.distance_traveled = 0\n    self.distance_traveled += abs(CS.vEgo) * DT_CTRL\n\n    # TODO: fix simulator\n    if not SIMULATION or REPLAY:\n      if self.sm['modelV2'].frameDropPerc > 20:\n        self.events.add(EventName.modeldLagging)\n\n    # Decrement personality on distance button press\n    if self.CP.openpilotLongitudinalControl:\n      if any(not be.pressed and be.type == ButtonType.gapAdjustCruise for be in CS.buttonEvents):\n        self.personality = (self.personality - 1) % 3\n        self.params.put_nonblocking('LongitudinalPersonality', self.personality)\n        self.events.add(EventName.personalityChanged)\n\n  def data_sample(self):\n    _car_state = messaging.recv_one(self.car_state_sock)\n    CS = _car_state.carState if _car_state else self.CS_prev\n\n    self.sm.update(0)\n\n    if not self.initialized:\n      all_valid = CS.canValid and self.sm.all_checks()\n      timed_out = self.sm.frame * DT_CTRL > 6.\n      if all_valid or timed_out or (SIMULATION and not REPLAY):\n        available_streams = VisionIpcClient.available_streams(\"camerad\", block=False)\n        if VisionStreamType.VISION_STREAM_ROAD not in available_streams:\n          self.sm.ignore_alive.append('roadCameraState')\n          self.sm.ignore_valid.append('roadCameraState')\n        if VisionStreamType.VISION_STREAM_WIDE_ROAD not in available_streams:\n          self.sm.ignore_alive.append('wideRoadCameraState')\n          self.sm.ignore_valid.append('wideRoadCameraState')\n\n        if REPLAY and any(ps.controlsAllowed for ps in self.sm['pandaStates']):\n          self.state_machine.state = State.enabled\n\n        self.initialized = True\n        cloudlog.event(\n          \"selfdrived.initialized\",\n          dt=self.sm.frame*DT_CTRL,\n          timeout=timed_out,\n          canValid=CS.canValid,\n          invalid=[s for s, valid in self.sm.valid.items() if not valid],\n          not_alive=[s for s, alive in self.sm.alive.items() if not alive],\n          not_freq_ok=[s for s, freq_ok in self.sm.freq_ok.items() if not freq_ok],\n          error=True,\n        )\n\n    # When the panda and selfdrived do not agree on controls_allowed\n    # we want to disengage openpilot. However the status from the panda goes through\n    # another socket other than the CAN messages and one can arrive earlier than the other.\n    # Therefore we allow a mismatch for two samples, then we trigger the disengagement.\n    if not self.enabled:\n      self.mismatch_counter = 0\n\n    # All pandas not in silent mode must have controlsAllowed when openpilot is enabled\n    if self.enabled and any(not ps.controlsAllowed for ps in self.sm['pandaStates']\n           if ps.safetyModel not in IGNORED_SAFETY_MODES):\n      self.mismatch_counter += 1\n\n    return CS\n\n  def update_alerts(self, CS):\n    clear_event_types = set()\n    if ET.WARNING not in self.state_machine.current_alert_types:\n      clear_event_types.add(ET.WARNING)\n    if self.enabled:\n      clear_event_types.add(ET.NO_ENTRY)\n\n    pers = LONGITUDINAL_PERSONALITY_MAP[self.personality]\n    alerts = self.events.create_alerts(self.state_machine.current_alert_types, [self.CP, CS, self.sm, self.is_metric,\n                                                                                self.state_machine.soft_disable_timer, pers])\n    self.AM.add_many(self.sm.frame, alerts)\n    self.AM.process_alerts(self.sm.frame, clear_event_types)\n\n  def publish_selfdriveState(self, CS):\n    # selfdriveState\n    ss_msg = messaging.new_message('selfdriveState')\n    ss_msg.valid = True\n    ss = ss_msg.selfdriveState\n    ss.enabled = self.enabled\n    ss.active = self.active\n    ss.state = self.state_machine.state\n    ss.engageable = not self.events.contains(ET.NO_ENTRY)\n    ss.experimentalMode = self.experimental_mode\n    ss.personality = self.personality\n\n    ss.alertText1 = self.AM.current_alert.alert_text_1\n    ss.alertText2 = self.AM.current_alert.alert_text_2\n    ss.alertSize = self.AM.current_alert.alert_size\n    ss.alertStatus = self.AM.current_alert.alert_status\n    ss.alertType = self.AM.current_alert.alert_type\n    ss.alertSound = self.AM.current_alert.audible_alert\n    ss.alertHudVisual = self.AM.current_alert.visual_alert\n\n    self.pm.send('selfdriveState', ss_msg)\n\n    # onroadEvents - logged every second or on change\n    if (self.sm.frame % int(1. / DT_CTRL) == 0) or (self.events.names != self.events_prev):\n      ce_send = messaging.new_message('onroadEvents', len(self.events))\n      ce_send.valid = True\n      ce_send.onroadEvents = self.events.to_msg()\n      self.pm.send('onroadEvents', ce_send)\n    self.events_prev = self.events.names.copy()\n\n  def step(self):\n    CS = self.data_sample()\n    self.update_events(CS)\n    if not self.CP.passive and self.initialized:\n      self.enabled, self.active = self.state_machine.update(self.events)\n    self.update_alerts(CS)\n\n    self.publish_selfdriveState(CS)\n\n    self.CS_prev = CS\n\n  def params_thread(self, evt):\n    while not evt.is_set():\n      self.is_metric = self.params.get_bool(\"IsMetric\")\n      self.is_ldw_enabled = self.params.get_bool(\"IsLdwEnabled\")\n      self.disengage_on_accelerator = self.params.get_bool(\"DisengageOnAccelerator\")\n      self.experimental_mode = self.params.get_bool(\"ExperimentalMode\") and self.CP.openpilotLongitudinalControl\n      self.personality = self.params.get(\"LongitudinalPersonality\", return_default=True)\n      time.sleep(0.1)\n\n  def run(self):\n    e = threading.Event()\n    t = threading.Thread(target=self.params_thread, args=(e, ))\n    try:\n      t.start()\n      while True:\n        self.step()\n        self.rk.monitor_time()\n    finally:\n      e.set()\n      t.join()", "target": "selfdrive d"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:Priority:0", "source": "class CLASSTOKEN(IntEnum):\n  LOWEST = 0\n  LOWER = 1\n  LOW = 2\n  MID = 3\n  HIGH = 4\n  HIGHEST = 5", "target": "priority"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:ET:1", "source": "class CLASSTOKEN:\n  ENABLE = 'enable'\n  PRE_ENABLE = 'preEnable'\n  OVERRIDE_LATERAL = 'overrideLateral'\n  OVERRIDE_LONGITUDINAL = 'overrideLongitudinal'\n  NO_ENTRY = 'noEntry'\n  WARNING = 'warning'\n  USER_DISABLE = 'userDisable'\n  SOFT_DISABLE = 'softDisable'\n  IMMEDIATE_DISABLE = 'immediateDisable'\n  PERMANENT = 'permanent'", "target": "et"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:Events:2", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.events: list[int] = []\n    self.static_events: list[int] = []\n    self.event_counters = dict.fromkeys(EVENTS.keys(), 0)\n\n  @property\n  def names(self) -> list[int]:\n    return self.events\n\n  def __len__(self) -> int:\n    return len(self.events)\n\n  def add(self, event_name: int, static: bool=False) -> None:\n    if static:\n      bisect.insort(self.static_events, event_name)\n    bisect.insort(self.events, event_name)\n\n  def clear(self) -> None:\n    self.event_counters = {k: (v + 1 if k in self.events else 0) for k, v in self.event_counters.items()}\n    self.events = self.static_events.copy()\n\n  def contains(self, event_type: str) -> bool:\n    return any(event_type in EVENTS.get(e, {}) for e in self.events)\n\n  def create_alerts(self, event_types: list[str], callback_args=None):\n    if callback_args is None:\n      callback_args = []\n\n    ret = []\n    for e in self.events:\n      types = EVENTS[e].keys()\n      for et in event_types:\n        if et in types:\n          alert = EVENTS[e][et]\n          if not isinstance(alert, Alert):\n            alert = alert(*callback_args)\n\n          if DT_CTRL * (self.event_counters[e] + 1) >= alert.creation_delay:\n            alert.alert_type = f\"{EVENT_NAME[e]}/{et}\"\n            alert.event_type = et\n            ret.append(alert)\n    return ret\n\n  def add_from_msg(self, events):\n    for e in events:\n      bisect.insort(self.events, e.name.raw)\n\n  def to_msg(self):\n    ret = []\n    for event_name in self.events:\n      event = log.OnroadEvent.new_message()\n      event.name = event_name\n      for event_type in EVENTS.get(event_name, {}):\n        setattr(event, event_type, True)\n      ret.append(event)\n    return ret", "target": "events"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:Alert:3", "source": "class CLASSTOKEN:\n  def __init__(self,\n               alert_text_1: str,\n               alert_text_2: str,\n               alert_status: log.SelfdriveState.AlertStatus,\n               alert_size: log.SelfdriveState.AlertSize,\n               priority: Priority,\n               visual_alert: car.CarControl.HUDControl.VisualAlert,\n               audible_alert: car.CarControl.HUDControl.AudibleAlert,\n               duration: float,\n               creation_delay: float = 0.):\n\n    self.alert_text_1 = alert_text_1\n    self.alert_text_2 = alert_text_2\n    self.alert_status = alert_status\n    self.alert_size = alert_size\n    self.priority = priority\n    self.visual_alert = visual_alert\n    self.audible_alert = audible_alert\n\n    self.duration = int(duration / DT_CTRL)\n\n    self.creation_delay = creation_delay\n\n    self.alert_type = \"\"\n    self.event_type: str | None = None\n\n  def __str__(self) -> str:\n    return f\"{self.alert_text_1}/{self.alert_text_2} {self.priority} {self.visual_alert} {self.audible_alert}\"\n\n  def __gt__(self, alert2) -> bool:\n    if not isinstance(alert2, CLASSTOKEN):\n      return False\n    return self.priority > alert2.priority", "target": "alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:NoEntryAlert:4", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_2: str,\n               alert_text_1: str = \"openpilot Unavailable\",\n               visual_alert: car.CarControl.HUDControl.VisualAlert=VisualAlert.none):\n    super().__init__(alert_text_1, alert_text_2, AlertStatus.normal,\n                     AlertSize.mid, Priority.LOW, visual_alert,\n                     AudibleAlert.refuse, 3.)", "target": "no entry alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:SoftDisableAlert:5", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.userPrompt, AlertSize.full,\n                     Priority.MID, VisualAlert.steerRequired,\n                     AudibleAlert.warningSoft, 2.),", "target": "soft disable alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:UserSoftDisableAlert:6", "source": "class CLASSTOKEN(SoftDisableAlert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(alert_text_2),\n    self.alert_text_1 = \"openpilot will disengage\"", "target": "user soft disable alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:ImmediateDisableAlert:7", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.critical, AlertSize.full,\n                     Priority.HIGHEST, VisualAlert.steerRequired,\n                     AudibleAlert.warningImmediate, 4.),", "target": "immediate disable alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:EngagementAlert:8", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, audible_alert: car.CarControl.HUDControl.AudibleAlert):\n    super().__init__(\"\", \"\",\n                     AlertStatus.normal, AlertSize.none,\n                     Priority.MID, VisualAlert.none,\n                     audible_alert, .2),", "target": "engagement alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:NormalPermanentAlert:9", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_1: str, alert_text_2: str = \"\", duration: float = 0.2, priority: Priority = Priority.LOWER, creation_delay: float = 0.):\n    super().__init__(alert_text_1, alert_text_2,\n                     AlertStatus.normal, AlertSize.mid if len(alert_text_2) else AlertSize.small,\n                     priority, VisualAlert.none, AudibleAlert.none, duration, creation_delay=creation_delay),", "target": "normal permanent alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:StartupAlert:10", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_1: str, alert_text_2: str = \"Always keep hands on wheel and eyes on road\", alert_status=AlertStatus.normal):\n    super().__init__(alert_text_1, alert_text_2,\n                     alert_status, AlertSize.mid,\n                     Priority.LOWER, VisualAlert.none, AudibleAlert.none, 5.),", "target": "startup alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/state.py:StateMachine:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.current_alert_types = [ET.PERMANENT]\n    self.state = State.disabled\n    self.soft_disable_timer = 0\n\n  def update(self, events: Events):\n    # decrement the soft disable timer at every step, as it's reset on\n    # entrance in SOFT_DISABLING state\n    self.soft_disable_timer = max(0, self.soft_disable_timer - 1)\n\n    self.current_alert_types = [ET.PERMANENT]\n\n    # ENABLED, SOFT DISABLING, PRE ENABLING, OVERRIDING\n    if self.state != State.disabled:\n      # user and immediate disable always have priority in a non-disabled state\n      if events.contains(ET.USER_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.USER_DISABLE)\n\n      elif events.contains(ET.IMMEDIATE_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.IMMEDIATE_DISABLE)\n\n      else:\n        # ENABLED\n        if self.state == State.enabled:\n          if events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n        # SOFT DISABLING\n        elif self.state == State.softDisabling:\n          if not events.contains(ET.SOFT_DISABLE):\n            # no more soft disabling condition, so go back to ENABLED\n            self.state = State.enabled\n\n          elif self.soft_disable_timer > 0:\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif self.soft_disable_timer <= 0:\n            self.state = State.disabled\n\n        # PRE ENABLING\n        elif self.state == State.preEnabled:\n          if not events.contains(ET.PRE_ENABLE):\n            self.state = State.enabled\n          else:\n            self.current_alert_types.append(ET.PRE_ENABLE)\n\n        # OVERRIDING\n        elif self.state == State.overriding:\n          if events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n          elif not (events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL)):\n            self.state = State.enabled\n          else:\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n    # DISABLED\n    elif self.state == State.disabled:\n      if events.contains(ET.ENABLE):\n        if events.contains(ET.NO_ENTRY):\n          self.current_alert_types.append(ET.NO_ENTRY)\n\n        else:\n          if events.contains(ET.PRE_ENABLE):\n            self.state = State.preEnabled\n          elif events.contains(ET.OVERRIDE_LATERAL) or events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n          else:\n            self.state = State.enabled\n          self.current_alert_types.append(ET.ENABLE)\n\n    # Check if openpilot is engaged and actuators are enabled\n    enabled = self.state in ENABLED_STATES\n    active = self.state in ACTIVE_STATES\n    if active:\n      self.current_alert_types.append(ET.WARNING)\n    return enabled, active", "target": "state machine"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/helpers.py:ExcessiveActuationType:0", "source": "class CLASSTOKEN(StrEnum):\n  LONGITUDINAL = auto()\n  LATERAL = auto()", "target": "excessive actuation type"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/helpers.py:ExcessiveActuationCheck:1", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self._excessive_counter = 0\n    self._engaged_counter = 0\n\n  def update(self, sm: messaging.SubMaster, CS: car.CarState, calibrated_pose: Pose) -> ExcessiveActuationType | None:\n    # CS.aEgo can be noisy to bumps in the road, transitioning from standstill, losing traction, etc.\n    # longitudinal\n    accel_calibrated = calibrated_pose.acceleration.x\n    excessive_long_actuation = sm['carControl'].longActive and (accel_calibrated > ACCEL_MAX * 2 or accel_calibrated < ACCEL_MIN * 2)\n\n    # lateral\n    yaw_rate = calibrated_pose.angular_velocity.yaw\n    roll = sm['liveParameters'].roll\n    roll_compensated_lateral_accel = (CS.vEgo * yaw_rate) - (math.sin(roll) * ACCELERATION_DUE_TO_GRAVITY)\n\n    # Prevent false positives after overriding\n    excessive_lat_actuation = False\n    self._engaged_counter = self._engaged_counter + 1 if sm['carControl'].latActive and not CS.steeringPressed else 0\n    if self._engaged_counter > MIN_LATERAL_ENGAGE_BUFFER:\n      if abs(roll_compensated_lateral_accel) > ISO_LATERAL_ACCEL * 2:\n        excessive_lat_actuation = True\n\n    # livePose acceleration can be noisy due to bad mounting or aliased livePose measurements\n    livepose_valid = abs(CS.aEgo - accel_calibrated) < 2\n    self._excessive_counter = self._excessive_counter + 1 if livepose_valid and (excessive_long_actuation or excessive_lat_actuation) else 0\n\n    excessive_type = None\n    if self._excessive_counter > MIN_EXCESSIVE_ACTUATION_COUNT:\n      if excessive_long_actuation:\n        excessive_type = ExcessiveActuationType.LONGITUDINAL\n      else:\n        excessive_type = ExcessiveActuationType.LATERAL\n\n    return excessive_type", "target": "excessive actuation check"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/tests/test_alertmanager.py:TestAlertManager:0", "source": "class CLASSTOKEN:\n\n  def test_duration(self):\n    \"\"\"\n      Enforce that an alert lasts for max(alert duration, duration the alert is added)\n    \"\"\"\n    for duration in range(1, 100):\n      alert = None\n      while not isinstance(alert, Alert):\n        event = random.choice([e for e in EVENTS.values() if len(e)])\n        alert = random.choice(list(event.values()))\n\n      alert.duration = duration\n\n      # check two cases:\n      # - alert is added to AM for <= the alert's duration\n      # - alert is added to AM for > alert's duration\n      for greater in (True, False):\n        if greater:\n          add_duration = duration + random.randint(1, 10)\n        else:\n          add_duration = random.randint(1, duration)\n        show_duration = max(duration, add_duration)\n\n        AM = AlertManager()\n        for frame in range(duration+10):\n          if frame < add_duration:\n            AM.add_many(frame, [alert, ])\n          AM.process_alerts(frame, set())\n\n          shown = AM.current_alert != EmptyAlert\n          should_show = frame <= show_duration\n          assert shown == should_show, f\"{frame=} {add_duration=} {duration=}\"\n\n      # check one case:\n      # - if alert is re-added to AM before it ends the duration is extended\n      if duration > 1:\n        AM = AlertManager()\n        show_duration = duration * 2\n        for frame in range(duration * 2 + 10):\n          if frame == 0:\n            AM.add_many(frame, [alert, ])\n\n          if frame == duration:\n            # add alert one frame before it ends\n            assert AM.current_alert == alert\n            AM.add_many(frame, [alert, ])\n          AM.process_alerts(frame, set())\n\n          shown = AM.current_alert != EmptyAlert\n          should_show = frame <= show_duration\n          assert shown == should_show, f\"{frame=} {duration=}\"", "target": "test alert manager"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/tests/test_state_machine.py:TestStateMachine:0", "source": "class CLASSTOKEN:\n  def setup_method(self):\n    self.events = Events()\n    self.state_machine = StateMachine()\n    self.state_machine.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n\n  def test_immediate_disable(self):\n    for state in ALL_STATES:\n      for et in MAINTAIN_STATES[state]:\n        self.events.add(make_event([et, ET.IMMEDIATE_DISABLE]))\n        self.state_machine.state = state\n        self.state_machine.update(self.events)\n        assert State.disabled == self.state_machine.state\n        self.events.clear()\n\n  def test_user_disable(self):\n    for state in ALL_STATES:\n      for et in MAINTAIN_STATES[state]:\n        self.events.add(make_event([et, ET.USER_DISABLE]))\n        self.state_machine.state = state\n        self.state_machine.update(self.events)\n        assert State.disabled == self.state_machine.state\n        self.events.clear()\n\n  def test_soft_disable(self):\n    for state in ALL_STATES:\n      if state == State.preEnabled:  # preEnabled considers NO_ENTRY instead\n        continue\n      for et in MAINTAIN_STATES[state]:\n        self.events.add(make_event([et, ET.SOFT_DISABLE]))\n        self.state_machine.state = state\n        self.state_machine.update(self.events)\n        assert self.state_machine.state == State.disabled if state == State.disabled else State.softDisabling\n        self.events.clear()\n\n  def test_soft_disable_timer(self):\n    self.state_machine.state = State.enabled\n    self.events.add(make_event([ET.SOFT_DISABLE]))\n    self.state_machine.update(self.events)\n    for _ in range(int(SOFT_DISABLE_TIME / DT_CTRL)):\n      assert self.state_machine.state == State.softDisabling\n      self.state_machine.update(self.events)\n\n    assert self.state_machine.state == State.disabled\n\n  def test_no_entry(self):\n    # Make sure noEntry keeps us disabled\n    for et in ENABLE_EVENT_TYPES:\n      self.events.add(make_event([ET.NO_ENTRY, et]))\n      self.state_machine.update(self.events)\n      assert self.state_machine.state == State.disabled\n      self.events.clear()\n\n  def test_no_entry_pre_enable(self):\n    # preEnabled with noEntry event\n    self.state_machine.state = State.preEnabled\n    self.events.add(make_event([ET.NO_ENTRY, ET.PRE_ENABLE]))\n    self.state_machine.update(self.events)\n    assert self.state_machine.state == State.preEnabled\n\n  def test_maintain_states(self):\n    # Given current state's event type, we should maintain state\n    for state in ALL_STATES:\n      for et in MAINTAIN_STATES[state]:\n        self.state_machine.state = state\n        self.events.add(make_event([et]))\n        self.state_machine.update(self.events)\n        assert self.state_machine.state == state\n        self.events.clear()", "target": "test state machine"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/tests/test_alerts.py:TestAlerts:0", "source": "class CLASSTOKEN:\n\n  @classmethod\n  def setup_class(cls):\n    with open(OFFROAD_ALERTS_PATH) as f:\n      cls.offroad_alerts = json.loads(f.read())\n\n      # Create fake objects for callback\n      cls.CS = car.CarState.new_message()\n      cls.CP = car.CarParams.new_message()\n      cfg = [c for c in CONFIGS if c.proc_name == 'selfdrived'][0]\n      cls.sm = SubMaster(cfg.pubs)\n\n  def test_events_defined(self):\n    # Ensure all events in capnp schema are defined in events.py\n    events = log.OnroadEvent.EventName.schema.enumerants\n\n    for name, e in events.items():\n      if not name.endswith(\"DEPRECATED\"):\n        fail_msg = f\"{name} @{e} not in EVENTS\"\n        assert e in EVENTS.keys(), fail_msg\n\n  # ensure alert text doesn't exceed allowed width\n  def test_alert_text_length(self):\n    font_path = os.path.join(BASEDIR, \"selfdrive/assets/fonts\")\n    regular_font_path = os.path.join(font_path, \"Inter-SemiBold.ttf\")\n    bold_font_path = os.path.join(font_path, \"Inter-Bold.ttf\")\n    semibold_font_path = os.path.join(font_path, \"Inter-SemiBold.ttf\")\n\n    max_text_width = 2160 - 300  # full screen width is usable, minus sidebar\n    draw = ImageDraw.Draw(Image.new('RGB', (0, 0)))\n\n    fonts = {\n      AlertSize.small: [ImageFont.truetype(semibold_font_path, 74)],\n      AlertSize.mid: [ImageFont.truetype(bold_font_path, 88),\n                      ImageFont.truetype(regular_font_path, 66)],\n    }\n\n    for alert in ALERTS:\n      if not isinstance(alert, Alert):\n        alert = alert(self.CP, self.CS, self.sm, metric=False, soft_disable_time=100, personality=log.LongitudinalPersonality.standard)\n\n      # for full size alerts, both text fields wrap the text,\n      # so it's unlikely that they  would go past the max width\n      if alert.alert_size in (AlertSize.none, AlertSize.full):\n        continue\n\n      for i, txt in enumerate([alert.alert_text_1, alert.alert_text_2]):\n        if i >= len(fonts[alert.alert_size]):\n          break\n\n        font = fonts[alert.alert_size][i]\n        left, _, right, _ = draw.textbbox((0, 0), txt, font)\n        width = right - left\n        msg = f\"type: {alert.alert_type} msg: {txt}\"\n        assert width <= max_text_width, msg\n\n  def test_alert_sanity_check(self):\n    for event_types in EVENTS.values():\n      for event_type, a in event_types.items():\n        # TODO: add callback alerts\n        if not isinstance(a, Alert):\n          continue\n\n        if a.alert_size == AlertSize.none:\n          assert len(a.alert_text_1) == 0\n          assert len(a.alert_text_2) == 0\n        elif a.alert_size == AlertSize.small:\n          assert len(a.alert_text_1) > 0\n          assert len(a.alert_text_2) == 0\n        elif a.alert_size == AlertSize.mid:\n          assert len(a.alert_text_1) > 0\n          assert len(a.alert_text_2) > 0\n        else:\n          assert len(a.alert_text_1) > 0\n\n        assert a.duration >= 0.\n\n        if event_type not in (ET.WARNING, ET.PERMANENT, ET.PRE_ENABLE):\n          assert a.creation_delay == 0.\n\n  def test_offroad_alerts(self):\n    params = Params()\n    for a in self.offroad_alerts:\n      # set the alert\n      alert = copy.copy(self.offroad_alerts[a])\n      set_offroad_alert(a, True)\n      alert['extra'] = ''\n      assert alert == params.get(a)\n\n      # then delete it\n      set_offroad_alert(a, False)\n      assert params.get(a) is None\n\n  def test_offroad_alerts_extra_text(self):\n    params = Params()\n    for i in range(50):\n      # set the alert\n      a = random.choice(list(self.offroad_alerts))\n      alert = self.offroad_alerts[a]\n      set_offroad_alert(a, True, extra_text=\"a\"*i)\n\n      written_alert = params.get(a)\n      assert \"a\"*i == written_alert['extra']\n      assert alert[\"text\"] == written_alert['text']", "target": "test alerts"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/test_monitoring.py:TestMonitoring:0", "source": "class CLASSTOKEN:\n  def _run_seq(self, msgs, interaction, engaged, standstill):\n    DM = DriverMonitoring()\n    events = []\n    for idx in range(len(msgs)):\n      DM._update_states(msgs[idx], [0, 0, 0], 0, engaged[idx])\n      # cal_rpy and car_speed don't matter here\n\n      # evaluate events at 10Hz for tests\n      DM._update_events(interaction[idx], engaged[idx], standstill[idx], 0, 0)\n      events.append(DM.current_events)\n    assert len(events) == len(msgs), f\"got {len(events)} for {len(msgs)} driverState input msgs\"\n    return events, DM\n\n  def _assert_no_events(self, events):\n    assert all(not len(e) for e in events)\n\n  # engaged, driver is attentive all the time\n  def test_fully_aware_driver(self):\n    events, _ = self._run_seq(always_attentive, always_false, always_true, always_false)\n    self._assert_no_events(events)\n\n  # engaged, driver is distracted and does nothing\n  def test_fully_distracted_driver(self):\n    events, d_status = self._run_seq(always_distracted, always_false, always_true, always_false)\n    assert len(events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL)/2/DT_DMON)]) == 0\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL + \\\n                    ((d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL-d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == \\\n                    EventName.preDriverDistracted\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL + \\\n                    ((d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((d_status.settings._DISTRACTED_TIME + \\\n                    ((TEST_TIMESPAN-10-d_status.settings._DISTRACTED_TIME)/2))/DT_DMON)].names[0] == EventName.driverDistracted\n    assert isinstance(d_status.awareness, float)\n\n  # engaged, no face detected the whole time, no action\n  def test_fully_invisible_driver(self):\n    events, d_status = self._run_seq(always_no_face, always_false, always_true, always_false)\n    assert len(events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL)/2/DT_DMON)]) == 0\n    assert events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL + \\\n                      ((d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL-d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == \\\n                      EventName.preDriverUnresponsive\n    assert events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL + \\\n                      ((d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert events[int((d_status.settings._AWARENESS_TIME + \\\n                      ((TEST_TIMESPAN-10-d_status.settings._AWARENESS_TIME)/2))/DT_DMON)].names[0] == EventName.driverUnresponsive\n\n  # engaged, down to orange, driver pays attention, back to normal; then down to orange, driver touches wheel\n  #  - should have short orange recovery time and no green afterwards; wheel touch only recovers when paying attention\n  def test_normal_driver(self):\n    ds_vector = [msg_DISTRACTED] * int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON) + \\\n                [msg_ATTENTIVE] * int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON) + \\\n                [msg_DISTRACTED] * int((DISTRACTED_SECONDS_TO_ORANGE+2)/DT_DMON) + \\\n                [msg_ATTENTIVE] * (int(TEST_TIMESPAN/DT_DMON)-int((DISTRACTED_SECONDS_TO_ORANGE*3+2)/DT_DMON))\n    interaction_vector = [car_interaction_NOT_DETECTED] * int(DISTRACTED_SECONDS_TO_ORANGE*3/DT_DMON) + \\\n                         [car_interaction_DETECTED] * (int(TEST_TIMESPAN/DT_DMON)-int(DISTRACTED_SECONDS_TO_ORANGE*3/DT_DMON))\n    events, _ = self._run_seq(ds_vector, interaction_vector, always_true, always_false)\n    assert len(events[int(DISTRACTED_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert len(events[int(DISTRACTED_SECONDS_TO_ORANGE*1.5/DT_DMON)]) == 0\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE*3-0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE*3+0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert len(events[int((DISTRACTED_SECONDS_TO_ORANGE*3+2.5)/DT_DMON)]) == 0\n\n  # engaged, down to orange, driver dodges camera, then comes back still distracted, down to red, \\\n  #                          driver dodges, and then touches wheel to no avail, disengages and reengages\n  #  - orange/red alert should remain after disappearance, and only disengaging clears red\n  def test_biggest_comma_fan(self):\n    _invisible_time = 2  # seconds\n    ds_vector = always_distracted[:]\n    interaction_vector = always_false[:]\n    op_vector = always_true[:]\n    ds_vector[int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON):int((DISTRACTED_SECONDS_TO_ORANGE+_invisible_time)/DT_DMON)] \\\n                                                        = [msg_NO_FACE_DETECTED] * int(_invisible_time/DT_DMON)\n    ds_vector[int((DISTRACTED_SECONDS_TO_RED+_invisible_time)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time)/DT_DMON)] \\\n                                                        = [msg_NO_FACE_DETECTED] * int(_invisible_time/DT_DMON)\n    interaction_vector[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+0.5)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+1.5)/DT_DMON)] \\\n                                                        = [True] * int(1/DT_DMON)\n    op_vector[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+2.5)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+3)/DT_DMON)] \\\n                                                        = [False] * int(0.5/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, op_vector, always_false)\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE+0.5*_invisible_time)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_RED+1.5*_invisible_time)/DT_DMON)].names[0] == EventName.driverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+1.5)/DT_DMON)].names[0] == EventName.driverDistracted\n    assert len(events[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+3.5)/DT_DMON)]) == 0\n\n  # engaged, invisible driver, down to orange, driver touches wheel; then down to orange again, driver appears\n  #  - both actions should clear the alert, but momentary appearance should not\n  def test_sometimes_transparent_commuter(self):\n    _visible_time = np.random.choice([0.5, 10])\n    ds_vector = always_no_face[:]*2\n    interaction_vector = always_false[:]*2\n    ds_vector[int((2*INVISIBLE_SECONDS_TO_ORANGE+1)/DT_DMON):int((2*INVISIBLE_SECONDS_TO_ORANGE+1+_visible_time)/DT_DMON)] = \\\n                                                                                             [msg_ATTENTIVE] * int(_visible_time/DT_DMON)\n    interaction_vector[int((INVISIBLE_SECONDS_TO_ORANGE)/DT_DMON):int((INVISIBLE_SECONDS_TO_ORANGE+1)/DT_DMON)] = [True] * int(1/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, 2*always_true, 2*always_false)\n    assert len(events[int(INVISIBLE_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((INVISIBLE_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert len(events[int((INVISIBLE_SECONDS_TO_ORANGE+0.1)/DT_DMON)]) == 0\n    if _visible_time == 0.5:\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1+0.1+_visible_time)/DT_DMON)].names[0] == EventName.preDriverUnresponsive\n    elif _visible_time == 10:\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n      assert len(events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1+0.1+_visible_time)/DT_DMON)]) == 0\n\n  # engaged, invisible driver, down to red, driver appears and then touches wheel, then disengages/reengages\n  #  - only disengage will clear the alert\n  def test_last_second_responder(self):\n    _visible_time = 2  # seconds\n    ds_vector = always_no_face[:]\n    interaction_vector = always_false[:]\n    op_vector = always_true[:]\n    ds_vector[int(INVISIBLE_SECONDS_TO_RED/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time)/DT_DMON)] = [msg_ATTENTIVE] * int(_visible_time/DT_DMON)\n    interaction_vector[int((INVISIBLE_SECONDS_TO_RED+_visible_time)/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time+1)/DT_DMON)] = [True] * int(1/DT_DMON)\n    op_vector[int((INVISIBLE_SECONDS_TO_RED+_visible_time+1)/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time+0.5)/DT_DMON)] = [False] * int(0.5/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, op_vector, always_false)\n    assert len(events[int(INVISIBLE_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((INVISIBLE_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED-0.1)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED+0.5*_visible_time)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED+_visible_time+0.5)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert len(events[int((INVISIBLE_SECONDS_TO_RED+_visible_time+1+0.1)/DT_DMON)]) == 0\n\n  # disengaged, always distracted driver\n  #  - dm should stay quiet when not engaged\n  def test_pure_dashcam_user(self):\n    events, _ = self._run_seq(always_distracted, always_false, always_false, always_false)\n    assert sum(len(event) for event in events) == 0\n\n  # engaged, car stops at traffic light, down to orange, no action, then car starts moving\n  #  - should only reach green when stopped, but continues counting down on launch\n  def test_long_traffic_light_victim(self):\n    _redlight_time = 60  # seconds\n    standstill_vector = always_true[:]\n    standstill_vector[int(_redlight_time/DT_DMON):] = [False] * int((TEST_TIMESPAN-_redlight_time)/DT_DMON)\n    events, d_status = self._run_seq(always_distracted, always_false, always_true, standstill_vector)\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL+1)/DT_DMON)].names[0] == \\\n                                                                                                                    EventName.preDriverDistracted\n    assert events[int((_redlight_time-0.1)/DT_DMON)].names[0] == EventName.preDriverDistracted\n    assert events[int((_redlight_time+0.5)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n\n  # engaged, model is somehow uncertain and driver is distracted\n  #  - should fall back to wheel touch after uncertain alert\n  def test_somehow_indecisive_model(self):\n    ds_vector = [msg_DISTRACTED_BUT_SOMEHOW_UNCERTAIN] * int(TEST_TIMESPAN/DT_DMON)\n    interaction_vector = always_false[:]\n    events, d_status = self._run_seq(ds_vector, interaction_vector, always_true, always_false)\n    assert EventName.preDriverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_ORANGE-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME-0.1)/DT_DMON)].names\n    assert EventName.promptDriverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_ORANGE-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME+0.1)/DT_DMON)].names\n    assert EventName.driverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_RED-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME+0.1)/DT_DMON)].names", "target": "test monitoring"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DRIVER_MONITOR_SETTINGS:0", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self._DT_DMON = DT_DMON\n    # ref (page15-16): https://eur-lex.europa.eu/legal-content/EN/TXT/PDF/?uri=CELEX:42018X1947&rid=2\n    self._AWARENESS_TIME = 30. # passive wheeltouch total timeout\n    self._AWARENESS_PRE_TIME_TILL_TERMINAL = 15.\n    self._AWARENESS_PROMPT_TIME_TILL_TERMINAL = 6.\n    self._DISTRACTED_TIME = 11. # active monitoring total timeout\n    self._DISTRACTED_PRE_TIME_TILL_TERMINAL = 8.\n    self._DISTRACTED_PROMPT_TIME_TILL_TERMINAL = 6.\n\n    self._FACE_THRESHOLD = 0.7\n    self._EYE_THRESHOLD = 0.65\n    self._SG_THRESHOLD = 0.9\n    self._BLINK_THRESHOLD = 0.865\n\n    self._EE_THRESH11 = 0.4\n    self._EE_THRESH12 = 15.0\n    self._EE_MAX_OFFSET1 = 0.06\n    self._EE_MIN_OFFSET1 = 0.025\n    self._EE_THRESH21 = 0.01\n    self._EE_THRESH22 = 0.35\n\n    self._POSE_PITCH_THRESHOLD = 0.3133\n    self._POSE_PITCH_THRESHOLD_SLACK = 0.3237\n    self._POSE_PITCH_THRESHOLD_STRICT = self._POSE_PITCH_THRESHOLD\n    self._POSE_YAW_THRESHOLD = 0.4020\n    self._POSE_YAW_THRESHOLD_SLACK = 0.5042\n    self._POSE_YAW_THRESHOLD_STRICT = self._POSE_YAW_THRESHOLD\n    self._PITCH_NATURAL_OFFSET = 0.029 # initial value before offset is learned\n    self._PITCH_NATURAL_THRESHOLD = 0.449\n    self._YAW_NATURAL_OFFSET = 0.097 # initial value before offset is learned\n    self._PITCH_MAX_OFFSET = 0.124\n    self._PITCH_MIN_OFFSET = -0.0881\n    self._YAW_MAX_OFFSET = 0.289\n    self._YAW_MIN_OFFSET = -0.0246\n\n    self._POSESTD_THRESHOLD = 0.3\n    self._HI_STD_FALLBACK_TIME = int(10  / self._DT_DMON)  # fall back to wheel touch if model is uncertain for 10s\n    self._DISTRACTED_FILTER_TS = 0.25  # 0.6Hz\n    self._ALWAYS_ON_ALERT_MIN_SPEED = 11\n\n    self._POSE_CALIB_MIN_SPEED = 13  # 30 mph\n    self._POSE_OFFSET_MIN_COUNT = int(60 / self._DT_DMON)  # valid data counts before calibration completes, 1min cumulative\n    self._POSE_OFFSET_MAX_COUNT = int(360 / self._DT_DMON)  # stop deweighting new data after 6 min, aka \"short term memory\"\n\n    self._WHEELPOS_CALIB_MIN_SPEED = 11\n    self._WHEELPOS_THRESHOLD = 0.5\n    self._WHEELPOS_FILTER_MIN_COUNT = int(15 / self._DT_DMON) # allow 15 seconds to converge wheel side\n\n    self._RECOVERY_FACTOR_MAX = 5.  # relative to minus step change\n    self._RECOVERY_FACTOR_MIN = 1.25  # relative to minus step change\n\n    self._MAX_TERMINAL_ALERTS = 3  # not allowed to engage after 3 terminal alerts\n    self._MAX_TERMINAL_DURATION = int(30 / self._DT_DMON)  # not allowed to engage after 30s of terminal alerts", "target": "driver monitor settings"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DistractedType:1", "source": "class CLASSTOKEN:\n  NOT_DISTRACTED = 0\n  DISTRACTED_POSE = 1 << 0\n  DISTRACTED_BLINK = 1 << 1\n  DISTRACTED_E2E = 1 << 2", "target": "distracted type"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DriverPose:2", "source": "class CLASSTOKEN:\n  def __init__(self, max_trackable):\n    self.yaw = 0.\n    self.pitch = 0.\n    self.roll = 0.\n    self.yaw_std = 0.\n    self.pitch_std = 0.\n    self.roll_std = 0.\n    self.pitch_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.yaw_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.calibrated = False\n    self.low_std = True\n    self.cfactor_pitch = 1.\n    self.cfactor_yaw = 1.", "target": "driver pose"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DriverBlink:3", "source": "class CLASSTOKEN:\n  def __init__(self):\n    self.left = 0.\n    self.right = 0.", "target": "driver blink"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/helpers.py:DriverMonitoring:4", "source": "class CLASSTOKEN:\n  def __init__(self, rhd_saved=False, settings=None, always_on=False):\n    if settings is None:\n      settings = DRIVER_MONITOR_SETTINGS()\n    # init policy settings\n    self.settings = settings\n\n    # init driver status\n    self.wheelpos_learner = RunningStatFilter()\n    self.pose = DriverPose(self.settings._POSE_OFFSET_MAX_COUNT)\n    self.blink = DriverBlink()\n    self.eev1 = 0.\n    self.eev2 = 1.\n    self.ee1_offseter = RunningStatFilter(max_trackable=self.settings._POSE_OFFSET_MAX_COUNT)\n    self.ee2_offseter = RunningStatFilter(max_trackable=self.settings._POSE_OFFSET_MAX_COUNT)\n    self.ee1_calibrated = False\n    self.ee2_calibrated = False\n\n    self.always_on = always_on\n    self.distracted_types = []\n    self.driver_distracted = False\n    self.driver_distraction_filter = FirstOrderFilter(0., self.settings._DISTRACTED_FILTER_TS, self.settings._DT_DMON)\n    self.wheel_on_right = False\n    self.wheel_on_right_last = None\n    self.wheel_on_right_default = rhd_saved\n    self.face_detected = False\n    self.terminal_alert_cnt = 0\n    self.terminal_time = 0\n    self.step_change = 0.\n    self.active_monitoring_mode = True\n    self.is_model_uncertain = False\n    self.hi_stds = 0\n    self.threshold_pre = self.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n    self.threshold_prompt = self.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n\n    self.params = Params()\n    self.too_distracted = self.params.get_bool(\"DriverTooDistracted\")\n\n    self._reset_awareness()\n    self._set_timers(active_monitoring=True)\n    self._reset_events()\n\n  def _reset_awareness(self):\n    self.awareness = 1.\n    self.awareness_active = 1.\n    self.awareness_passive = 1.\n\n  def _reset_events(self):\n    self.current_events = Events()\n\n  def _set_timers(self, active_monitoring):\n    if self.active_monitoring_mode and self.awareness <= self.threshold_prompt:\n      if active_monitoring:\n        self.step_change = self.settings._DT_DMON / self.settings._DISTRACTED_TIME\n      else:\n        self.step_change = 0.\n      return  # no exploit after orange alert\n    elif self.awareness <= 0.:\n      return\n\n    if active_monitoring:\n      # when falling back from passive mode to active mode, reset awareness to avoid false alert\n      if not self.active_monitoring_mode:\n        self.awareness_passive = self.awareness\n        self.awareness = self.awareness_active\n\n      self.threshold_pre = self.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n      self.threshold_prompt = self.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n      self.step_change = self.settings._DT_DMON / self.settings._DISTRACTED_TIME\n      self.active_monitoring_mode = True\n    else:\n      if self.active_monitoring_mode:\n        self.awareness_active = self.awareness\n        self.awareness = self.awareness_passive\n\n      self.threshold_pre = self.settings._AWARENESS_PRE_TIME_TILL_TERMINAL / self.settings._AWARENESS_TIME\n      self.threshold_prompt = self.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL / self.settings._AWARENESS_TIME\n      self.step_change = self.settings._DT_DMON / self.settings._AWARENESS_TIME\n      self.active_monitoring_mode = False\n\n  def _set_policy(self, model_data, car_speed):\n    bp = model_data.meta.disengagePredictions.brakeDisengageProbs[0] # brake disengage prob in next 2s\n    k1 = max(-0.00156*((car_speed-16)**2)+0.6, 0.2)\n    bp_normal = max(min(bp / k1, 0.5),0)\n    self.pose.cfactor_pitch = np.interp(bp_normal, [0, 0.5],\n                                           [self.settings._POSE_PITCH_THRESHOLD_SLACK,\n                                            self.settings._POSE_PITCH_THRESHOLD_STRICT]) / self.settings._POSE_PITCH_THRESHOLD\n    self.pose.cfactor_yaw = np.interp(bp_normal, [0, 0.5],\n                                           [self.settings._POSE_YAW_THRESHOLD_SLACK,\n                                            self.settings._POSE_YAW_THRESHOLD_STRICT]) / self.settings._POSE_YAW_THRESHOLD\n\n  def _get_distracted_types(self):\n    distracted_types = []\n\n    if not self.pose.calibrated:\n      pitch_error = self.pose.pitch - self.settings._PITCH_NATURAL_OFFSET\n      yaw_error = self.pose.yaw - self.settings._YAW_NATURAL_OFFSET\n    else:\n      pitch_error = self.pose.pitch - min(max(self.pose.pitch_offseter.filtered_stat.mean(),\n                                                       self.settings._PITCH_MIN_OFFSET), self.settings._PITCH_MAX_OFFSET)\n      yaw_error = self.pose.yaw - min(max(self.pose.yaw_offseter.filtered_stat.mean(),\n                                                    self.settings._YAW_MIN_OFFSET), self.settings._YAW_MAX_OFFSET)\n    pitch_error = 0 if pitch_error > 0 else abs(pitch_error) # no positive pitch limit\n    yaw_error = abs(yaw_error)\n    if pitch_error > (self.settings._POSE_PITCH_THRESHOLD*self.pose.cfactor_pitch if self.pose.calibrated else self.settings._PITCH_NATURAL_THRESHOLD) or \\\n       yaw_error > self.settings._POSE_YAW_THRESHOLD*self.pose.cfactor_yaw:\n      distracted_types.append(DistractedType.DISTRACTED_POSE)\n\n    if (self.blink.left + self.blink.right)*0.5 > self.settings._BLINK_THRESHOLD:\n      distracted_types.append(DistractedType.DISTRACTED_BLINK)\n\n    if self.ee1_calibrated:\n      ee1_dist = self.eev1 > max(min(self.ee1_offseter.filtered_stat.M, self.settings._EE_MAX_OFFSET1), self.settings._EE_MIN_OFFSET1) \\\n                              * self.settings._EE_THRESH12\n    else:\n      ee1_dist = self.eev1 > self.settings._EE_THRESH11\n    if ee1_dist:\n      distracted_types.append(DistractedType.DISTRACTED_E2E)\n\n    return distracted_types\n\n  def _update_states(self, driver_state, cal_rpy, car_speed, op_engaged):\n    rhd_pred = driver_state.wheelOnRightProb\n    # calibrates only when there's movement and either face detected\n    if car_speed > self.settings._WHEELPOS_CALIB_MIN_SPEED and (driver_state.leftDriverData.faceProb > self.settings._FACE_THRESHOLD or\n                                          driver_state.rightDriverData.faceProb > self.settings._FACE_THRESHOLD):\n      self.wheelpos_learner.push_and_update(rhd_pred)\n    if self.wheelpos_learner.filtered_stat.n > self.settings._WHEELPOS_FILTER_MIN_COUNT:\n      self.wheel_on_right = self.wheelpos_learner.filtered_stat.M > self.settings._WHEELPOS_THRESHOLD\n    else:\n      self.wheel_on_right = self.wheel_on_right_default # use default/saved if calibration is unfinished\n    # make sure no switching when engaged\n    if op_engaged and self.wheel_on_right_last is not None and self.wheel_on_right_last != self.wheel_on_right:\n      self.wheel_on_right = self.wheel_on_right_last\n    driver_data = driver_state.rightDriverData if self.wheel_on_right else driver_state.leftDriverData\n    if not all(len(x) > 0 for x in (driver_data.faceOrientation, driver_data.facePosition,\n                                    driver_data.faceOrientationStd, driver_data.facePositionStd,\n                                    driver_data.readyProb, driver_data.notReadyProb)):\n      return\n\n    self.face_detected = driver_data.faceProb > self.settings._FACE_THRESHOLD\n    self.pose.roll, self.pose.pitch, self.pose.yaw = face_orientation_from_net(driver_data.faceOrientation, driver_data.facePosition, cal_rpy)\n    if self.wheel_on_right:\n      self.pose.yaw *= -1\n    self.wheel_on_right_last = self.wheel_on_right\n    self.pose.pitch_std = driver_data.faceOrientationStd[0]\n    self.pose.yaw_std = driver_data.faceOrientationStd[1]\n    model_std_max = max(self.pose.pitch_std, self.pose.yaw_std)\n    self.pose.low_std = model_std_max < self.settings._POSESTD_THRESHOLD\n    self.blink.left = driver_data.leftBlinkProb * (driver_data.leftEyeProb > self.settings._EYE_THRESHOLD) \\\n                                                                  * (driver_data.sunglassesProb < self.settings._SG_THRESHOLD)\n    self.blink.right = driver_data.rightBlinkProb * (driver_data.rightEyeProb > self.settings._EYE_THRESHOLD) \\\n                                                                  * (driver_data.sunglassesProb < self.settings._SG_THRESHOLD)\n    self.eev1 = driver_data.notReadyProb[0]\n    self.eev2 = driver_data.readyProb[0]\n\n    self.distracted_types = self._get_distracted_types()\n    self.driver_distracted = (DistractedType.DISTRACTED_E2E in self.distracted_types or DistractedType.DISTRACTED_POSE in self.distracted_types\n                                or DistractedType.DISTRACTED_BLINK in self.distracted_types) \\\n                              and driver_data.faceProb > self.settings._FACE_THRESHOLD and self.pose.low_std\n    self.driver_distraction_filter.update(self.driver_distracted)\n\n    # update offseter\n    # only update when driver is actively driving the car above a certain speed\n    if self.face_detected and car_speed > self.settings._POSE_CALIB_MIN_SPEED and self.pose.low_std and (not op_engaged or not self.driver_distracted):\n      self.pose.pitch_offseter.push_and_update(self.pose.pitch)\n      self.pose.yaw_offseter.push_and_update(self.pose.yaw)\n      self.ee1_offseter.push_and_update(self.eev1)\n      self.ee2_offseter.push_and_update(self.eev2)\n\n    self.pose.calibrated = self.pose.pitch_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT and \\\n                                       self.pose.yaw_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n    self.ee1_calibrated = self.ee1_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n    self.ee2_calibrated = self.ee2_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n\n    self.is_model_uncertain = self.hi_stds > self.settings._HI_STD_FALLBACK_TIME\n    self._set_timers(self.face_detected and not self.is_model_uncertain)\n    if self.face_detected and not self.pose.low_std and not self.driver_distracted:\n      self.hi_stds += 1\n    elif self.face_detected and self.pose.low_std:\n      self.hi_stds = 0\n\n  def _update_events(self, driver_engaged, op_engaged, standstill, wrong_gear, car_speed):\n    self._reset_events()\n    # Block engaging until ignition cycle after max number or time of distractions\n    if self.terminal_alert_cnt >= self.settings._MAX_TERMINAL_ALERTS or \\\n       self.terminal_time >= self.settings._MAX_TERMINAL_DURATION:\n      if not self.too_distracted:\n        self.params.put_bool_nonblocking(\"DriverTooDistracted\", True)\n      self.too_distracted = True\n\n    # Always-on distraction lockout is temporary\n    if self.too_distracted or (self.always_on and self.awareness <= self.threshold_prompt):\n      self.current_events.add(EventName.tooDistracted)\n\n    always_on_valid = self.always_on and not wrong_gear\n    if (driver_engaged and self.awareness > 0 and not self.active_monitoring_mode) or \\\n       (not always_on_valid and not op_engaged) or \\\n       (always_on_valid and not op_engaged and self.awareness <= 0):\n      # always reset on disengage with normal mode; disengage resets only on red if always on\n      self._reset_awareness()\n      return\n\n    driver_attentive = self.driver_distraction_filter.x < 0.37\n    awareness_prev = self.awareness\n\n    if (driver_attentive and self.face_detected and self.pose.low_std and self.awareness > 0):\n      if driver_engaged:\n        self._reset_awareness()\n        return\n      # only restore awareness when paying attention and alert is not red\n      self.awareness = min(self.awareness + ((self.settings._RECOVERY_FACTOR_MAX-self.settings._RECOVERY_FACTOR_MIN)*\n                                             (1.-self.awareness)+self.settings._RECOVERY_FACTOR_MIN)*self.step_change, 1.)\n      if self.awareness == 1.:\n        self.awareness_passive = min(self.awareness_passive + self.step_change, 1.)\n      # don't display alert banner when awareness is recovering and has cleared orange\n      if self.awareness > self.threshold_prompt:\n        return\n\n    _reaching_audible = self.awareness - self.step_change <= self.threshold_prompt\n    _reaching_terminal = self.awareness - self.step_change <= 0\n    standstill_orange_exemption = standstill and _reaching_audible\n    always_on_red_exemption = always_on_valid and not op_engaged and _reaching_terminal\n    always_on_lowspeed_exemption = always_on_valid and not op_engaged and car_speed < self.settings._ALWAYS_ON_ALERT_MIN_SPEED\n\n    certainly_distracted = self.driver_distraction_filter.x > 0.63 and self.driver_distracted and self.face_detected\n    maybe_distracted = self.hi_stds > self.settings._HI_STD_FALLBACK_TIME or not self.face_detected\n\n    if certainly_distracted or maybe_distracted:\n      # should always be counting if distracted unless at standstill (lowspeed for always-on) and reaching orange\n      # also will not be reaching 0 if DM is active when not engaged\n      if not (standstill_orange_exemption or always_on_red_exemption or (always_on_lowspeed_exemption and _reaching_audible)):\n        self.awareness = max(self.awareness - self.step_change, -0.1)\n\n    alert = None\n    if self.awareness <= 0.:\n      # terminal red alert: disengagement required\n      alert = EventName.driverDistracted if self.active_monitoring_mode else EventName.driverUnresponsive\n      self.terminal_time += 1\n      if awareness_prev > 0.:\n        self.terminal_alert_cnt += 1\n    elif self.awareness <= self.threshold_prompt:\n      # prompt orange alert\n      alert = EventName.promptDriverDistracted if self.active_monitoring_mode else EventName.promptDriverUnresponsive\n    elif self.awareness <= self.threshold_pre and not always_on_lowspeed_exemption:\n      # pre green alert\n      alert = EventName.preDriverDistracted if self.active_monitoring_mode else EventName.preDriverUnresponsive\n\n    if alert is not None:\n      self.current_events.add(alert)\n\n\n  def get_state_packet(self, valid=True):\n    # build driverMonitoringState packet\n    dat = messaging.new_message('driverMonitoringState', valid=valid)\n    dat.driverMonitoringState = {\n      \"events\": self.current_events.to_msg(),\n      \"faceDetected\": self.face_detected,\n      \"isDistracted\": self.driver_distracted,\n      \"distractedType\": sum(self.distracted_types),\n      \"awarenessStatus\": self.awareness,\n      \"posePitchOffset\": self.pose.pitch_offseter.filtered_stat.mean(),\n      \"posePitchValidCount\": self.pose.pitch_offseter.filtered_stat.n,\n      \"poseYawOffset\": self.pose.yaw_offseter.filtered_stat.mean(),\n      \"poseYawValidCount\": self.pose.yaw_offseter.filtered_stat.n,\n      \"stepChange\": self.step_change,\n      \"awarenessActive\": self.awareness_active,\n      \"awarenessPassive\": self.awareness_passive,\n      \"isLowStd\": self.pose.low_std,\n      \"hiStdCount\": self.hi_stds,\n      \"isActiveMode\": self.active_monitoring_mode,\n      \"isRHD\": self.wheel_on_right,\n    }\n    return dat\n\n  def run_step(self, sm):\n    # Set strictness\n    self._set_policy(\n      model_data=sm['modelV2'],\n      car_speed=sm['carState'].vEgo\n    )\n\n    # Parse data from dmonitoringmodeld\n    self._update_states(\n      driver_state=sm['driverStateV2'],\n      cal_rpy=sm['liveCalibration'].rpyCalib,\n      car_speed=sm['carState'].vEgo,\n      op_engaged=sm['selfdriveState'].enabled\n    )\n\n    # Update distraction events\n    self._update_events(\n      driver_engaged=sm['carState'].steeringPressed or sm['carState'].gasPressed,\n      op_engaged=sm['selfdriveState'].enabled,\n      standstill=sm['carState'].standstill,\n      wrong_gear=sm['carState'].gearShifter in [car.CarState.GearShifter.reverse, car.CarState.GearShifter.park],\n      car_speed=sm['carState'].vEgo\n    )", "target": "driver monitoring"}
