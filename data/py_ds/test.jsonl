{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/helpers.py:Handler:0", "source": "  class CLASSTOKEN(http.server.SimpleHTTPRequestHandler):\n    API_NO_RESPONSE = False\n    API_BAD_RESPONSE = False\n\n    def do_GET(self):\n      if self.API_NO_RESPONSE:\n        return\n\n      if self.API_BAD_RESPONSE:\n        self.send_response(500, \"\")\n        return\n      super().do_GET()\n\n    def __init__(self, *args, **kwargs):\n      super().__init__(*args, directory=str(directory), **kwargs)", "target": "handler"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_cruise_speed.py:TestVCruiseHelper:1", "source": "class CLASSTOKEN:\n  def setup_method(self):\n    self.CP = car.CarParams(pcmCruise=self.pcm_cruise)\n    self.v_cruise_helper = VCruiseHelper(self.CP)\n    self.reset_cruise_speed_state()\n\n  def reset_cruise_speed_state(self):\n    # Two resets previous cruise speed\n    for _ in range(2):\n      self.v_cruise_helper.update_v_cruise(car.CarState(cruiseState={\"available\": False}), enabled=False, is_metric=False)\n\n  def enable(self, v_ego, experimental_mode):\n    # Simulates user pressing set with a current speed\n    self.v_cruise_helper.initialize_v_cruise(car.CarState(vEgo=v_ego), experimental_mode)\n\n  def test_adjust_speed(self):\n    \"\"\"\n    Asserts speed changes on falling edges of buttons.\n    \"\"\"\n\n    self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n    for btn in (ButtonType.accelCruise, ButtonType.decelCruise):\n      for pressed in (True, False):\n        CS = car.CarState(cruiseState={\"available\": True})\n        CS.buttonEvents = [ButtonEvent(type=btn, pressed=pressed)]\n\n        self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n        assert pressed == (self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last)\n\n  def test_rising_edge_enable(self):\n    \"\"\"\n    Some car interfaces may enable on rising edge of a button,\n    ensure we don't adjust speed if enabled changes mid-press.\n    \"\"\"\n\n    # NOTE: enabled is always one frame behind the result from button press in controlsd\n    for enabled, pressed in ((False, False),\n                             (False, True),\n                             (True, False)):\n      CS = car.CarState(cruiseState={\"available\": True})\n      CS.buttonEvents = [ButtonEvent(type=ButtonType.decelCruise, pressed=pressed)]\n      self.v_cruise_helper.update_v_cruise(CS, enabled=enabled, is_metric=False)\n      if pressed:\n        self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n      # Expected diff on enabling. Speed should not change on falling edge of pressed\n      assert not pressed == self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last\n\n  def test_resume_in_standstill(self):\n    \"\"\"\n    Asserts we don't increment set speed if user presses resume/accel to exit cruise standstill.\n    \"\"\"\n\n    self.enable(0, False)\n\n    for standstill in (True, False):\n      for pressed in (True, False):\n        CS = car.CarState(cruiseState={\"available\": True, \"standstill\": standstill})\n        CS.buttonEvents = [ButtonEvent(type=ButtonType.accelCruise, pressed=pressed)]\n        self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n\n        # speed should only update if not at standstill and button falling edge\n        should_equal = standstill or pressed\n        assert should_equal == (self.v_cruise_helper.v_cruise_kph == self.v_cruise_helper.v_cruise_kph_last)\n\n  def test_set_gas_pressed(self):\n    \"\"\"\n    Asserts pressing set while enabled with gas pressed sets\n    the speed to the maximum of vEgo and current cruise speed.\n    \"\"\"\n\n    for v_ego in np.linspace(0, 100, 101):\n      self.reset_cruise_speed_state()\n      self.enable(V_CRUISE_INITIAL * CV.KPH_TO_MS, False)\n\n      # first decrement speed, then perform gas pressed logic\n      expected_v_cruise_kph = self.v_cruise_helper.v_cruise_kph - IMPERIAL_INCREMENT\n      expected_v_cruise_kph = max(expected_v_cruise_kph, v_ego * CV.MS_TO_KPH)  # clip to min of vEgo\n      expected_v_cruise_kph = float(np.clip(round(expected_v_cruise_kph, 1), V_CRUISE_MIN, V_CRUISE_MAX))\n\n      CS = car.CarState(vEgo=float(v_ego), gasPressed=True, cruiseState={\"available\": True})\n      CS.buttonEvents = [ButtonEvent(type=ButtonType.decelCruise, pressed=False)]\n      self.v_cruise_helper.update_v_cruise(CS, enabled=True, is_metric=False)\n\n      # TODO: fix skipping first run due to enabled on rising edge exception\n      if v_ego == 0.0:\n        continue\n      assert expected_v_cruise_kph == self.v_cruise_helper.v_cruise_kph\n\n  def test_initialize_v_cruise(self):\n    \"\"\"\n    Asserts allowed cruise speeds on enabling with SET.\n    \"\"\"\n\n    for experimental_mode in (True, False):\n      for v_ego in np.linspace(0, 100, 101):\n        self.reset_cruise_speed_state()\n        assert not self.v_cruise_helper.v_cruise_initialized\n\n        self.enable(float(v_ego), experimental_mode)\n        assert V_CRUISE_INITIAL <= self.v_cruise_helper.v_cruise_kph <= V_CRUISE_MAX\n        assert self.v_cruise_helper.v_cruise_initialized", "target": "test v cruise helper"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/card.py:Car:0", "source": "class CLASSTOKEN:\n  CI: CarInterfaceBase\n  RI: RadarInterfaceBase\n  CP: car.CarParams\n\n  def __init__(self, CI=None, RI=None) -> None:\n    self.can_sock = messaging.sub_sock('can', timeout=20)\n    self.sm = messaging.SubMaster(['pandaStates', 'carControl', 'onroadEvents'])\n    self.pm = messaging.PubMaster(['sendcan', 'carState', 'carParams', 'carOutput', 'liveTracks'])\n\n    self.can_rcv_cum_timeout_counter = 0\n\n    self.CC_prev = car.CarControl.new_message()\n    self.CS_prev = car.CarState.new_message()\n    self.initialized_prev = False\n\n    self.last_actuators_output = structs.CarControl.Actuators()\n\n    self.params = Params()\n\n    self.can_callbacks = can_comm_callbacks(self.can_sock, self.pm.sock['sendcan'])\n\n    is_release = self.params.get_bool(\"IsReleaseBranch\")\n\n    if CI is None:\n      # wait for one pandaState and one CAN packet\n      print(\"Waiting for CAN messages...\")\n      while True:\n        can = messaging.recv_one_retry(self.can_sock)\n        if len(can.can) > 0:\n          break\n\n      alpha_long_allowed = self.params.get_bool(\"AlphaLongitudinalEnabled\")\n      num_pandas = len(messaging.recv_one_retry(self.sm.sock['pandaStates']).pandaStates)\n\n      cached_params = None\n      cached_params_raw = self.params.get(\"CarParamsCache\")\n      if cached_params_raw is not None:\n        with car.CarParams.from_bytes(cached_params_raw) as _cached_params:\n          cached_params = _cached_params\n\n      self.CI = get_car(*self.can_callbacks, obd_callback(self.params), alpha_long_allowed, is_release, num_pandas, cached_params)\n      self.RI = interfaces[self.CI.CP.carFingerprint].RadarInterface(self.CI.CP)\n      self.CP = self.CI.CP\n\n      # continue onto next fingerprinting step in pandad\n      self.params.put_bool(\"FirmwareQueryDone\", True)\n    else:\n      self.CI, self.CP = CI, CI.CP\n      self.RI = RI\n\n    self.CP.alternativeExperience = 0\n    openpilot_enabled_toggle = self.params.get_bool(\"OpenpilotEnabledToggle\")\n    controller_available = self.CI.CC is not None and openpilot_enabled_toggle and not self.CP.dashcamOnly\n    self.CP.passive = not controller_available or self.CP.dashcamOnly\n    if self.CP.passive:\n      safety_config = structs.CarParams.SafetyConfig()\n      safety_config.safetyModel = structs.CarParams.SafetyModel.noOutput\n      self.CP.safetyConfigs = [safety_config]\n\n    if self.CP.secOcRequired and not is_release:\n      # Copy user key if available\n      try:\n        with open(\"/cache/params/SecOCKey\") as f:\n          user_key = f.readline().strip()\n          if len(user_key) == 32:\n            self.params.put(\"SecOCKey\", user_key)\n      except Exception:\n        pass\n\n      secoc_key = self.params.get(\"SecOCKey\")\n      if secoc_key is not None:\n        saved_secoc_key = bytes.fromhex(secoc_key.strip())\n        if len(saved_secoc_key) == 16:\n          self.CP.secOcKeyAvailable = True\n          self.CI.CS.secoc_key = saved_secoc_key\n          if controller_available:\n            self.CI.CC.secoc_key = saved_secoc_key\n        else:\n          cloudlog.warning(\"Saved SecOC key is invalid\")\n\n    # Write previous route's CarParams\n    prev_cp = self.params.get(\"CarParamsPersistent\")\n    if prev_cp is not None:\n      self.params.put(\"CarParamsPrevRoute\", prev_cp)\n\n    # Write CarParams for controls and radard\n    cp_bytes = self.CP.to_bytes()\n    self.params.put(\"CarParams\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsCache\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsPersistent\", cp_bytes)\n\n    self.mock_carstate = MockCarState()\n    self.v_cruise_helper = VCruiseHelper(self.CP)\n\n    self.is_metric = self.params.get_bool(\"IsMetric\")\n    self.experimental_mode = self.params.get_bool(\"ExperimentalMode\")\n\n    # card is driven by can recv, expected at 100Hz\n    self.rk = Ratekeeper(100, print_delay_threshold=None)\n\n  def state_update(self) -> tuple[car.CarState, structs.RadarDataT | None]:\n    \"\"\"carState update loop, driven by can\"\"\"\n\n    can_strs = messaging.drain_sock_raw(self.can_sock, wait_for_one=True)\n    can_list = can_capnp_to_list(can_strs)\n\n    # Update carState from CAN\n    CS = self.CI.update(can_list)\n    if self.CP.brand == 'mock':\n      CS = self.mock_carstate.update(CS)\n\n    # Update radar tracks from CAN\n    RD: structs.RadarDataT | None = self.RI.update(can_list)\n\n    self.sm.update(0)\n\n    can_rcv_valid = len(can_strs) > 0\n\n    # Check for CAN timeout\n    if not can_rcv_valid:\n      self.can_rcv_cum_timeout_counter += 1\n\n    if can_rcv_valid and REPLAY:\n      self.can_log_mono_time = messaging.log_from_bytes(can_strs[0]).logMonoTime\n\n    self.v_cruise_helper.update_v_cruise(CS, self.sm['carControl'].enabled, self.is_metric)\n    if self.sm['carControl'].enabled and not self.CC_prev.enabled:\n      # Use CarState w/ buttons from the step selfdrived enables on\n      self.v_cruise_helper.initialize_v_cruise(self.CS_prev, self.experimental_mode)\n\n    # TODO: mirror the carState.cruiseState struct?\n    CS.vCruise = float(self.v_cruise_helper.v_cruise_kph)\n    CS.vCruiseCluster = float(self.v_cruise_helper.v_cruise_cluster_kph)\n\n    return CS, RD\n\n  def state_publish(self, CS: car.CarState, RD: structs.RadarDataT | None):\n    \"\"\"carState and carParams publish loop\"\"\"\n\n    # carParams - logged every 50 seconds (> 1 per segment)\n    if self.sm.frame % int(50. / DT_CTRL) == 0:\n      cp_send = messaging.new_message('carParams')\n      cp_send.valid = True\n      cp_send.carParams = self.CP\n      self.pm.send('carParams', cp_send)\n\n    # publish new carOutput\n    co_send = messaging.new_message('carOutput')\n    co_send.valid = self.sm.all_checks(['carControl'])\n    co_send.carOutput.actuatorsOutput = self.last_actuators_output\n    self.pm.send('carOutput', co_send)\n\n    # kick off controlsd step while we actuate the latest carControl packet\n    cs_send = messaging.new_message('carState')\n    cs_send.valid = CS.canValid\n    cs_send.carState = CS\n    cs_send.carState.canErrorCounter = self.can_rcv_cum_timeout_counter\n    cs_send.carState.cumLagMs = -self.rk.remaining * 1000.\n    self.pm.send('carState', cs_send)\n\n    if RD is not None:\n      tracks_msg = messaging.new_message('liveTracks')\n      tracks_msg.valid = not any(RD.errors.to_dict().values())\n      tracks_msg.liveTracks = RD\n      self.pm.send('liveTracks', tracks_msg)\n\n  def controls_update(self, CS: car.CarState, CC: car.CarControl):\n    \"\"\"control update loop, driven by carControl\"\"\"\n\n    if not self.initialized_prev:\n      # Initialize CarInterface, once controls are ready\n      # TODO: this can make us miss at least a few cycles when doing an ECU knockout\n      self.CI.init(self.CP, *self.can_callbacks)\n      # signal pandad to switch to car safety mode\n      self.params.put_bool_nonblocking(\"ControlsReady\", True)\n\n    if self.sm.all_alive(['carControl']):\n      # send car controls over can\n      now_nanos = self.can_log_mono_time if REPLAY else int(time.monotonic() * 1e9)\n      self.last_actuators_output, can_sends = self.CI.apply(CC, now_nanos)\n      self.pm.send('sendcan', can_list_to_can_capnp(can_sends, msgtype='sendcan', valid=CS.canValid))\n\n      self.CC_prev = CC\n\n  def step(self):\n    CS, RD = self.state_update()\n\n    self.state_publish(CS, RD)\n\n    initialized = (not any(e.name == EventName.selfdriveInitializing for e in self.sm['onroadEvents']) and\n                   self.sm.seen['onroadEvents'])\n    if not self.CP.passive and initialized:\n      self.controls_update(CS, self.sm['carControl'])\n\n    self.initialized_prev = initialized\n    self.CS_prev = CS\n\n  def params_thread(self, evt):\n    while not evt.is_set():\n      self.is_metric = self.params.get_bool(\"IsMetric\")\n      self.experimental_mode = self.params.get_bool(\"ExperimentalMode\") and self.CP.openpilotLongitudinalControl\n      time.sleep(0.1)\n\n  def card_thread(self):\n    e = threading.Event()\n    t = threading.Thread(target=self.params_thread, args=(e, ))\n    try:\n      t.start()\n      while True:\n        self.step()\n        self.rk.monitor_time()\n    finally:\n      e.set()\n      t.join()", "target": "car"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_following_distance.py:TestFollowingDistance:0", "source": "class CLASSTOKEN:\n  def test_following_distance(self):\n    v_lead = float(self.speed)\n    simulation_steady_state = run_following_distance_simulation(v_lead, e2e=self.e2e, personality=self.personality)\n    correct_steady_state = desired_follow_distance(v_lead, v_lead, get_T_FOLLOW(self.personality))\n    err_ratio = 0.2 if self.e2e else 0.1\n    assert simulation_steady_state == pytest.approx(correct_steady_state, abs=err_ratio * correct_steady_state + .5)", "target": "test following distance"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:Track:1", "source": "class CLASSTOKEN:\n  def __init__(self, identifier: int, v_lead: float, kalman_params: KalmanParams):\n    self.identifier = identifier\n    self.cnt = 0\n    self.aLeadTau = FirstOrderFilter(_LEAD_ACCEL_TAU, 0.45, DT_MDL)\n    self.K_A = kalman_params.A\n    self.K_C = kalman_params.C\n    self.K_K = kalman_params.K\n    self.kf = KF1D([[v_lead], [0.0]], self.K_A, self.K_C, self.K_K)\n\n  def update(self, d_rel: float, y_rel: float, v_rel: float, v_lead: float, measured: float):\n    # relative values, copy\n    self.dRel = d_rel   # LONG_DIST\n    self.yRel = y_rel   # -LAT_DIST\n    self.vRel = v_rel   # REL_SPEED\n    self.vLead = v_lead\n    self.measured = measured   # measured or estimate\n\n    # computed velocity and accelerations\n    if self.cnt > 0:\n      self.kf.update(self.vLead)\n\n    self.vLeadK = float(self.kf.x[SPEED][0])\n    self.aLeadK = float(self.kf.x[ACCEL][0])\n\n    # Learn if constant acceleration\n    if abs(self.aLeadK) < 0.5:\n      self.aLeadTau.x = _LEAD_ACCEL_TAU\n    else:\n      self.aLeadTau.update(0.0)\n\n    self.cnt += 1\n\n  def get_RadarState(self, model_prob: float = 0.0):\n    return {\n      \"dRel\": float(self.dRel),\n      \"yRel\": float(self.yRel),\n      \"vRel\": float(self.vRel),\n      \"vLead\": float(self.vLead),\n      \"vLeadK\": float(self.vLeadK),\n      \"aLeadK\": float(self.aLeadK),\n      \"aLeadTau\": float(self.aLeadTau.x),\n      \"status\": True,\n      \"fcw\": self.is_potential_fcw(model_prob),\n      \"modelProb\": model_prob,\n      \"radar\": True,\n      \"radarTrackId\": self.identifier,\n    }\n\n  def potential_low_speed_lead(self, v_ego: float):\n    # stop for stuff in front of you and low speed, even without model confirmation\n    # Radar points closer than 0.75, are almost always glitches on toyota radars\n    return abs(self.yRel) < 1.0 and (v_ego < V_EGO_STATIONARY) and (0.75 < self.dRel < 25)\n\n  def is_potential_fcw(self, model_prob: float):\n    return model_prob > .9\n\n  def __str__(self):\n    ret = f\"x: {self.dRel:4.1f}  y: {self.yRel:4.1f}  v: {self.vRel:4.1f}  a: {self.aLeadK:4.1f}\"\n    return ret", "target": "track"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:RadarD:2", "source": "class CLASSTOKEN:\n  def __init__(self, delay: float = 0.0):\n    self.current_time = 0.0\n\n    self.tracks: dict[int, Track] = {}\n    self.kalman_params = KalmanParams(DT_MDL)\n\n    self.v_ego = 0.0\n    self.v_ego_hist = deque([0.0], maxlen=int(round(delay / DT_MDL))+1)\n    self.last_v_ego_frame = -1\n\n    self.radar_state: capnp._DynamicStructBuilder | None = None\n    self.radar_state_valid = False\n\n    self.ready = False\n\n  def update(self, sm: messaging.SubMaster, rr: car.RadarData):\n    self.ready = sm.seen['modelV2']\n    self.current_time = 1e-9*max(sm.logMonoTime.values())\n\n    if sm.recv_frame['carState'] != self.last_v_ego_frame:\n      self.v_ego = sm['carState'].vEgo\n      self.v_ego_hist.append(self.v_ego)\n      self.last_v_ego_frame = sm.recv_frame['carState']\n\n    ar_pts = {pt.trackId: [pt.dRel, pt.yRel, pt.vRel, pt.measured] for pt in rr.points}\n\n    # *** remove missing points from meta data ***\n    for ids in list(self.tracks.keys()):\n      if ids not in ar_pts:\n        self.tracks.pop(ids, None)\n\n    # *** compute the tracks ***\n    for ids in ar_pts:\n      rpt = ar_pts[ids]\n\n      # align v_ego by a fixed time to align it with the radar measurement\n      v_lead = rpt[2] + self.v_ego_hist[0]\n\n      # create the track if it doesn't exist or it's a new track\n      if ids not in self.tracks:\n        self.tracks[ids] = Track(ids, v_lead, self.kalman_params)\n      self.tracks[ids].update(rpt[0], rpt[1], rpt[2], v_lead, rpt[3])\n\n    # *** publish radarState ***\n    self.radar_state_valid = sm.all_checks()\n    self.radar_state = log.RadarState.new_message()\n    self.radar_state.mdMonoTime = sm.logMonoTime['modelV2']\n    self.radar_state.radarErrors = rr.errors\n    self.radar_state.carStateMonoTime = sm.logMonoTime['carState']\n\n    if len(sm['modelV2'].velocity.x):\n      model_v_ego = sm['modelV2'].velocity.x[0]\n    else:\n      model_v_ego = self.v_ego\n    leads_v3 = sm['modelV2'].leadsV3\n    if len(leads_v3) > 1:\n      self.radar_state.leadOne = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[0], model_v_ego, low_speed_override=True)\n      self.radar_state.leadTwo = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[1], model_v_ego, low_speed_override=False)\n\n  def publish(self, pm: messaging.PubMaster):\n    assert self.radar_state is not None\n\n    radar_msg = messaging.new_message(\"radarState\")\n    radar_msg.valid = self.radar_state_valid\n    radar_msg.radarState = self.radar_state\n    pm.send(\"radarState\", radar_msg)", "target": "radar d"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/ui/widgets/prime.py:PrimeWidget:0", "source": "class CLASSTOKEN(Widget):\n  \"\"\"Widget for displaying comma prime subscription status\"\"\"\n\n  PRIME_BG_COLOR = rl.Color(51, 51, 51, 255)\n\n  def _render(self, rect):\n    if ui_state.prime_state.is_prime():\n      self._render_for_prime_user(rect)\n    else:\n      self._render_for_non_prime_users(rect)\n\n  def _render_for_non_prime_users(self, rect: rl.Rectangle):\n    \"\"\"Renders the advertisement for non-Prime users.\"\"\"\n\n    rl.draw_rectangle_rounded(rect, 0.02, 10, self.PRIME_BG_COLOR)\n\n    # Layout\n    x, y = rect.x + 80, rect.y + 90\n    w = rect.width - 160\n\n    # Title\n    gui_label(rl.Rectangle(x, y, w, 90), \"Upgrade Now\", 75, font_weight=FontWeight.BOLD)\n\n    # Description with wrapping\n    desc_y = y + 140\n    font = gui_app.font(FontWeight.LIGHT)\n    wrapped_text = \"\\n\".join(wrap_text(font, \"Become a comma prime member at connect.comma.ai\", 56, int(w)))\n    text_size = measure_text_cached(font, wrapped_text, 56)\n    rl.draw_text_ex(font, wrapped_text, rl.Vector2(x, desc_y), 56, 0, rl.WHITE)\n\n    # Features section\n    features_y = desc_y + text_size.y + 50\n    gui_label(rl.Rectangle(x, features_y, w, 50), \"PRIME FEATURES:\", 41, font_weight=FontWeight.BOLD)\n\n    # Feature list\n    features = [\"Remote access\", \"24/7 LTE connectivity\", \"1 year of drive storage\", \"Remote snapshots\"]\n    for i, feature in enumerate(features):\n      item_y = features_y + 80 + i * 65\n      gui_label(rl.Rectangle(x, item_y, 50, 60), \"✓\", 50, color=rl.Color(70, 91, 234, 255))\n      gui_label(rl.Rectangle(x + 60, item_y, w - 60, 60), feature, 50)\n\n  def _render_for_prime_user(self, rect: rl.Rectangle):\n    \"\"\"Renders the prime user widget with subscription status.\"\"\"\n\n    rl.draw_rectangle_rounded(rl.Rectangle(rect.x, rect.y, rect.width, 230), 0.02, 10, self.PRIME_BG_COLOR)\n\n    x = rect.x + 56\n    y = rect.y + 40\n\n    font = gui_app.font(FontWeight.BOLD)\n    rl.draw_text_ex(font, \"✓ SUBSCRIBED\", rl.Vector2(x, y), 41, 0, rl.Color(134, 255, 78, 255))\n    rl.draw_text_ex(font, \"comma prime\", rl.Vector2(x, y + 61), 75, 0, rl.WHITE)", "target": "prime widget"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/selfdrived/events.py:SoftDisableAlert:5", "source": "class CLASSTOKEN(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.userPrompt, AlertSize.full,\n                     Priority.MID, VisualAlert.steerRequired,\n                     AudibleAlert.warningSoft, 2.),", "target": "soft disable alert"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/tests/test_longcontrol.py:TestLongControlStateTransition:0", "source": "class CLASSTOKEN:\n\n  def test_stay_stopped(self):\n    CP = car.CarParams.new_message()\n    active = True\n    current_state = LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=True, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=False, brake_pressed=True, cruise_standstill=False)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=0.1,\n                             should_stop=False, brake_pressed=False, cruise_standstill=True)\n    assert next_state == LongCtrlState.stopping\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=1.0,\n                             should_stop=False, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.pid\n    active = False\n    next_state = long_control_state_trans(CP, active, current_state, v_ego=1.0,\n                             should_stop=False, brake_pressed=False, cruise_standstill=False)\n    assert next_state == LongCtrlState.off", "target": "test long control state transition"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/test/process_replay/capture.py:ProcessOutputCapture:1", "source": "class CLASSTOKEN:\n  def __init__(self, proc_name: str, prefix: str):\n    prefix = f\"{proc_name}_{prefix}\"\n    self.stdout_redirect = FdRedirect(prefix, 1)\n    self.stderr_redirect = FdRedirect(prefix, 2)\n\n  def __del__(self):\n    self.stdout_redirect.purge()\n    self.stderr_redirect.purge()\n\n  @no_type_check # ipython classes have incompatible signatures\n  def link_with_current_proc(self) -> None:\n    try:\n      # prevent ipykernel from redirecting stdout/stderr of python subprocesses\n      from ipykernel.iostream import OutStream\n      if isinstance(sys.stdout, OutStream):\n        sys.stdout = sys.__stdout__\n      if isinstance(sys.stderr, OutStream):\n        sys.stderr = sys.__stderr__\n    except ImportError:\n      pass\n\n    # link stdout/stderr to the fifo\n    self.stdout_redirect.link()\n    self.stderr_redirect.link()\n\n  def read_outerr(self) -> tuple[str, str]:\n    out_str = self.stdout_redirect.read().decode()\n    err_str = self.stderr_redirect.read().decode()\n    return out_str, err_str", "target": "process output capture"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/pandad/tests/test_pandad_loopback.py:TestBoarddLoopback:0", "source": "class CLASSTOKEN:\n  @classmethod\n  def setup_class(cls):\n    os.environ['STARTED'] = '1'\n    os.environ['BOARDD_LOOPBACK'] = '1'\n\n  @with_processes(['pandad'])\n  def test_loopback(self):\n    num_pandas = 2 if TICI and \"SINGLE_PANDA\" not in os.environ else 1\n    setup_pandad(num_pandas)\n\n    sendcan = messaging.pub_sock('sendcan')\n    can = messaging.sub_sock('can', conflate=False, timeout=100)\n    sm = messaging.SubMaster(['pandaStates'])\n    time.sleep(1)\n\n    n = 200\n    for i in range(n):\n      print(f\"pandad loopback {i}/{n}\")\n\n      sent_msgs = send_random_can_messages(sendcan, random.randrange(20, 100), num_pandas)\n\n      sent_loopback = copy.deepcopy(sent_msgs)\n      sent_loopback.update({k+128: copy.deepcopy(v) for k, v in sent_msgs.items()})\n      sent_total = {k: len(v) for k, v in sent_loopback.items()}\n      for _ in range(100 * 5):\n        sm.update(0)\n        recvd = messaging.drain_sock(can, wait_for_one=True)\n        for msg in recvd:\n          for m in msg.can:\n            key = (m.address, m.dat)\n            assert key in sent_loopback[m.src], f\"got unexpected msg: {m.src=} {m.address=} {m.dat=}\"\n            sent_loopback[m.src].discard(key)\n\n        if all(len(v) == 0 for v in sent_loopback.values()):\n          break\n\n      # if a set isn't empty, messages got dropped\n      pprint(sent_msgs)\n      pprint(sent_loopback)\n      print({k: len(x) for k, x in sent_loopback.items()})\n      print(sum([len(x) for x in sent_loopback.values()]))\n      pprint(sm['pandaStates'])  # may drop messages due to RX buffer overflow\n      for bus in sent_loopback.keys():\n        assert not len(sent_loopback[bus]), f\"loop {i}: bus {bus} missing {len(sent_loopback[bus])} out of {sent_total[bus]} messages\"", "target": "test boardd loopback"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/locationd.py:LocationEstimator:1", "source": "class CLASSTOKEN:\n  def __init__(self, debug: bool):\n    self.kf = PoseKalman(GENERATED_DIR, MAX_FILTER_REWIND_TIME)\n\n    self.debug = debug\n\n    self.posenet_stds = np.array([POSENET_STD_INITIAL_VALUE] * (POSENET_STD_HIST_HALF * 2))\n    self.car_speed = 0.0\n    self.camodo_yawrate_distribution = np.array([0.0, 10.0])  # mean, std\n    self.device_from_calib = np.eye(3)\n\n    obs_kinds = [ObservationKind.PHONE_ACCEL, ObservationKind.PHONE_GYRO, ObservationKind.CAMERA_ODO_ROTATION, ObservationKind.CAMERA_ODO_TRANSLATION]\n    self.observations = {kind: np.zeros(3, dtype=np.float32) for kind in obs_kinds}\n    self.observation_errors = {kind: np.zeros(3, dtype=np.float32) for kind in obs_kinds}\n\n  def reset(self, t: float, x_initial: np.ndarray = PoseKalman.initial_x, P_initial: np.ndarray = PoseKalman.initial_P):\n    self.kf.init_state(x_initial, covs=P_initial, filter_time=t)\n\n  def _validate_sensor_source(self, source: log.SensorEventData.SensorSource):\n    # some segments have two IMUs, ignore the second one\n    return source != log.SensorEventData.SensorSource.bmx055\n\n  def _validate_sensor_time(self, sensor_time: float, t: float):\n    # ignore empty readings\n    if sensor_time == 0:\n      return False\n\n    # sensor time and log time should be close\n    sensor_time_invalid = abs(sensor_time - t) > MAX_SENSOR_TIME_DIFF\n    if sensor_time_invalid:\n      cloudlog.warning(\"Sensor reading ignored, sensor timestamp more than 100ms off from log time\")\n    return not sensor_time_invalid\n\n  def _validate_timestamp(self, t: float):\n    kf_t = self.kf.t\n    invalid = not np.isnan(kf_t) and (kf_t - t) > MAX_FILTER_REWIND_TIME\n    if invalid:\n      cloudlog.warning(\"Observation timestamp is older than the max rewind threshold of the filter\")\n    return not invalid\n\n  def _finite_check(self, t: float, new_x: np.ndarray, new_P: np.ndarray):\n    all_finite = np.isfinite(new_x).all() and np.isfinite(new_P).all()\n    if not all_finite:\n      cloudlog.error(\"Non-finite values detected, kalman reset\")\n      self.reset(t)\n\n  def handle_log(self, t: float, which: str, msg: capnp._DynamicStructReader) -> HandleLogResult:\n    new_x, new_P = None, None\n    if which == \"accelerometer\" and msg.which() == \"acceleration\":\n      sensor_time = msg.timestamp * 1e-9\n\n      if not self._validate_sensor_time(sensor_time, t) or not self._validate_timestamp(sensor_time):\n        return HandleLogResult.TIMING_INVALID\n\n      if not self._validate_sensor_source(msg.source):\n        return HandleLogResult.SENSOR_SOURCE_INVALID\n\n      v = msg.acceleration.v\n      meas = np.array([-v[2], -v[1], -v[0]])\n      if np.linalg.norm(meas) >= ACCEL_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      acc_res = self.kf.predict_and_observe(sensor_time, ObservationKind.PHONE_ACCEL, meas)\n      if acc_res is not None:\n        _, new_x, _, new_P, _, _, (acc_err,), _, _ = acc_res\n        self.observation_errors[ObservationKind.PHONE_ACCEL] = np.array(acc_err)\n        self.observations[ObservationKind.PHONE_ACCEL] = meas\n\n    elif which == \"gyroscope\" and msg.which() == \"gyroUncalibrated\":\n      sensor_time = msg.timestamp * 1e-9\n\n      if not self._validate_sensor_time(sensor_time, t) or not self._validate_timestamp(sensor_time):\n        return HandleLogResult.TIMING_INVALID\n\n      if not self._validate_sensor_source(msg.source):\n        return HandleLogResult.SENSOR_SOURCE_INVALID\n\n      v = msg.gyroUncalibrated.v\n      meas = np.array([-v[2], -v[1], -v[0]])\n\n      gyro_bias = self.kf.x[States.GYRO_BIAS]\n      gyro_camodo_yawrate_err = np.abs((meas[2] - gyro_bias[2]) - self.camodo_yawrate_distribution[0])\n      gyro_camodo_yawrate_err_threshold = YAWRATE_CROSS_ERR_CHECK_FACTOR * self.camodo_yawrate_distribution[1]\n      gyro_valid = gyro_camodo_yawrate_err < gyro_camodo_yawrate_err_threshold\n\n      if np.linalg.norm(meas) >= ROTATION_SANITY_CHECK or not gyro_valid:\n        return HandleLogResult.INPUT_INVALID\n\n      gyro_res = self.kf.predict_and_observe(sensor_time, ObservationKind.PHONE_GYRO, meas)\n      if gyro_res is not None:\n        _, new_x, _, new_P, _, _, (gyro_err,), _, _ = gyro_res\n        self.observation_errors[ObservationKind.PHONE_GYRO] = np.array(gyro_err)\n        self.observations[ObservationKind.PHONE_GYRO] = meas\n\n    elif which == \"carState\":\n      self.car_speed = abs(msg.vEgo)\n\n    elif which == \"liveCalibration\":\n      # Note that we use this message during calibration\n      if len(msg.rpyCalib) > 0:\n        calib = np.array(msg.rpyCalib)\n        if calib.min() < -CALIB_RPY_SANITY_CHECK or calib.max() > CALIB_RPY_SANITY_CHECK:\n          return HandleLogResult.INPUT_INVALID\n\n        self.device_from_calib = rot_from_euler(calib)\n\n    elif which == \"cameraOdometry\":\n      if not self._validate_timestamp(t):\n        return HandleLogResult.TIMING_INVALID\n\n      rot_device = np.matmul(self.device_from_calib, np.array(msg.rot))\n      trans_device = np.matmul(self.device_from_calib, np.array(msg.trans))\n\n      if np.linalg.norm(rot_device) > ROTATION_SANITY_CHECK or np.linalg.norm(trans_device) > TRANS_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      rot_calib_std = np.array(msg.rotStd)\n      trans_calib_std = np.array(msg.transStd)\n\n      if rot_calib_std.min() <= MIN_STD_SANITY_CHECK or trans_calib_std.min() <= MIN_STD_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      if np.linalg.norm(rot_calib_std) > 10 * ROTATION_SANITY_CHECK or np.linalg.norm(trans_calib_std) > 10 * TRANS_SANITY_CHECK:\n        return HandleLogResult.INPUT_INVALID\n\n      self.posenet_stds = np.roll(self.posenet_stds, -1)\n      self.posenet_stds[-1] = trans_calib_std[0]\n\n      # Multiply by N to avoid to high certainty in kalman filter because of temporally correlated noise\n      rot_calib_std *= 10\n      trans_calib_std *= 2\n\n      rot_device_std = rotate_std(self.device_from_calib, rot_calib_std)\n      trans_device_std = rotate_std(self.device_from_calib, trans_calib_std)\n      rot_device_noise = rot_device_std ** 2\n      trans_device_noise = trans_device_std ** 2\n\n      cam_odo_rot_res = self.kf.predict_and_observe(t, ObservationKind.CAMERA_ODO_ROTATION, rot_device, np.array([np.diag(rot_device_noise)]))\n      cam_odo_trans_res = self.kf.predict_and_observe(t, ObservationKind.CAMERA_ODO_TRANSLATION, trans_device, np.array([np.diag(trans_device_noise)]))\n      self.camodo_yawrate_distribution =  np.array([rot_device[2], rot_device_std[2]])\n      if cam_odo_rot_res is not None:\n        _, new_x, _, new_P, _, _, (cam_odo_rot_err,), _, _ = cam_odo_rot_res\n        self.observation_errors[ObservationKind.CAMERA_ODO_ROTATION] = np.array(cam_odo_rot_err)\n        self.observations[ObservationKind.CAMERA_ODO_ROTATION] = rot_device\n      if cam_odo_trans_res is not None:\n        _, new_x, _, new_P, _, _, (cam_odo_trans_err,), _, _ = cam_odo_trans_res\n        self.observation_errors[ObservationKind.CAMERA_ODO_TRANSLATION] = np.array(cam_odo_trans_err)\n        self.observations[ObservationKind.CAMERA_ODO_TRANSLATION] = trans_device\n\n    if new_x is not None and new_P is not None:\n      self._finite_check(t, new_x, new_P)\n    return HandleLogResult.SUCCESS\n\n  def get_msg(self, sensors_valid: bool, inputs_valid: bool, filter_valid: bool):\n    state, cov = self.kf.x, self.kf.P\n    std = np.sqrt(np.diag(cov))\n\n    orientation_ned, orientation_ned_std = state[States.NED_ORIENTATION], std[States.NED_ORIENTATION]\n    velocity_device, velocity_device_std = state[States.DEVICE_VELOCITY], std[States.DEVICE_VELOCITY]\n    angular_velocity_device, angular_velocity_device_std = state[States.ANGULAR_VELOCITY], std[States.ANGULAR_VELOCITY]\n    acceleration_device, acceleration_device_std = state[States.ACCELERATION], std[States.ACCELERATION]\n\n    msg = messaging.new_message(\"livePose\")\n    msg.valid = filter_valid\n\n    livePose = msg.livePose\n    init_xyz_measurement(livePose.orientationNED, orientation_ned, orientation_ned_std, filter_valid)\n    init_xyz_measurement(livePose.velocityDevice, velocity_device, velocity_device_std, filter_valid)\n    init_xyz_measurement(livePose.angularVelocityDevice, angular_velocity_device, angular_velocity_device_std, filter_valid)\n    init_xyz_measurement(livePose.accelerationDevice, acceleration_device, acceleration_device_std, filter_valid)\n    if self.debug:\n      livePose.debugFilterState.value = state.tolist()\n      livePose.debugFilterState.std = std.tolist()\n      livePose.debugFilterState.valid = filter_valid\n      livePose.debugFilterState.observations = [\n        {'kind': k, 'value': self.observations[k].tolist(), 'error': self.observation_errors[k].tolist()}\n        for k in self.observations.keys()\n      ]\n\n    old_mean = np.mean(self.posenet_stds[:POSENET_STD_HIST_HALF])\n    new_mean = np.mean(self.posenet_stds[POSENET_STD_HIST_HALF:])\n    std_spike = (new_mean / old_mean) > 4.0 and new_mean > 7.0\n\n    livePose.inputsOK = inputs_valid\n    livePose.posenetOK = not std_spike or self.car_speed <= 5.0\n    livePose.sensorsOK = sensors_valid\n\n    return msg", "target": "location estimator"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/car/tests/test_models.py:TestCarModel:1", "source": "class CLASSTOKEN(TestCarModelBase):\n  pass", "target": "test car model"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/parse_model_outputs.py:Parser:0", "source": "class CLASSTOKEN:\n  def __init__(self, ignore_missing=False):\n    self.ignore_missing = ignore_missing\n\n  def check_missing(self, outs, name):\n    missing = name not in outs\n    if missing and not self.ignore_missing:\n      raise ValueError(f\"Missing output {name}\")\n    return missing\n\n  def parse_categorical_crossentropy(self, name, outs, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    if out_shape is not None:\n      raw = raw.reshape((raw.shape[0],) + out_shape)\n    outs[name] = softmax(raw, axis=-1)\n\n  def parse_binary_crossentropy(self, name, outs):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    outs[name] = sigmoid(raw)\n\n  def parse_mdn(self, name, outs, in_N=0, out_N=1, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    raw = raw.reshape((raw.shape[0], max(in_N, 1), -1))\n\n    n_values = (raw.shape[2] - out_N)//2\n    pred_mu = raw[:,:,:n_values]\n    pred_std = safe_exp(raw[:,:,n_values: 2*n_values])\n\n    if in_N > 1:\n      weights = np.zeros((raw.shape[0], in_N, out_N), dtype=raw.dtype)\n      for i in range(out_N):\n        weights[:,:,i - out_N] = softmax(raw[:,:,i - out_N], axis=-1)\n\n      if out_N == 1:\n        for fidx in range(weights.shape[0]):\n          idxs = np.argsort(weights[fidx][:,0])[::-1]\n          weights[fidx] = weights[fidx][idxs]\n          pred_mu[fidx] = pred_mu[fidx][idxs]\n          pred_std[fidx] = pred_std[fidx][idxs]\n      full_shape = tuple([raw.shape[0], in_N] + list(out_shape))\n      outs[name + '_weights'] = weights\n      outs[name + '_hypotheses'] = pred_mu.reshape(full_shape)\n      outs[name + '_stds_hypotheses'] = pred_std.reshape(full_shape)\n\n      pred_mu_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      pred_std_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      for fidx in range(weights.shape[0]):\n        for hidx in range(out_N):\n          idxs = np.argsort(weights[fidx,:,hidx])[::-1]\n          pred_mu_final[fidx, hidx] = pred_mu[fidx, idxs[0]]\n          pred_std_final[fidx, hidx] = pred_std[fidx, idxs[0]]\n    else:\n      pred_mu_final = pred_mu\n      pred_std_final = pred_std\n\n    if out_N > 1:\n      final_shape = tuple([raw.shape[0], out_N] + list(out_shape))\n    else:\n      final_shape = tuple([raw.shape[0],] + list(out_shape))\n    outs[name] = pred_mu_final.reshape(final_shape)\n    outs[name + '_stds'] = pred_std_final.reshape(final_shape)\n\n  def is_mhp(self, outs, name, shape):\n    if self.check_missing(outs, name):\n      return False\n    if outs[name].shape[1] == 2 * shape:\n      return False\n    return True\n\n  def parse_vision_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    self.parse_mdn('pose', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('wide_from_device_euler', outs, in_N=0, out_N=0, out_shape=(ModelConstants.WIDE_FROM_DEVICE_WIDTH,))\n    self.parse_mdn('road_transform', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('lane_lines', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_LANE_LINES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_mdn('road_edges', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_ROAD_EDGES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_binary_crossentropy('lane_lines_prob', outs)\n    self.parse_categorical_crossentropy('desire_pred', outs, out_shape=(ModelConstants.DESIRE_PRED_LEN,ModelConstants.DESIRE_PRED_WIDTH))\n    self.parse_binary_crossentropy('meta', outs)\n    self.parse_binary_crossentropy('lead_prob', outs)\n    lead_mhp = self.is_mhp(outs, 'lead', ModelConstants.LEAD_MHP_SELECTION * ModelConstants.LEAD_TRAJ_LEN * ModelConstants.LEAD_WIDTH)\n    lead_in_N, lead_out_N = (ModelConstants.LEAD_MHP_N, ModelConstants.LEAD_MHP_SELECTION) if lead_mhp else (0, 0)\n    lead_out_shape = (ModelConstants.LEAD_TRAJ_LEN, ModelConstants.LEAD_WIDTH) if lead_mhp else \\\n        (ModelConstants.LEAD_MHP_SELECTION, ModelConstants.LEAD_TRAJ_LEN, ModelConstants.LEAD_WIDTH)\n    self.parse_mdn('lead', outs, in_N=lead_in_N, out_N=lead_out_N, out_shape=lead_out_shape)\n    return outs\n\n  def parse_policy_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    plan_mhp = self.is_mhp(outs, 'plan',  ModelConstants.IDX_N * ModelConstants.PLAN_WIDTH)\n    plan_in_N, plan_out_N = (ModelConstants.PLAN_MHP_N, ModelConstants.PLAN_MHP_SELECTION) if plan_mhp else (0, 0)\n    self.parse_mdn('plan', outs, in_N=plan_in_N, out_N=plan_out_N, out_shape=(ModelConstants.IDX_N, ModelConstants.PLAN_WIDTH))\n    self.parse_categorical_crossentropy('desire_state', outs, out_shape=(ModelConstants.DESIRE_PRED_WIDTH,))\n    return outs\n\n  def parse_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    outs = self.parse_vision_outputs(outs)\n    outs = self.parse_policy_outputs(outs)\n    return outs", "target": "parser"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/modeld/constants.py:ModelConstants:0", "source": "class CLASSTOKEN:\n  # time and distance indices\n  IDX_N = 33\n  T_IDXS = [index_function(idx, max_val=10.0) for idx in range(IDX_N)]\n  X_IDXS = [index_function(idx, max_val=192.0) for idx in range(IDX_N)]\n  LEAD_T_IDXS = [0., 2., 4., 6., 8., 10.]\n  LEAD_T_OFFSETS = [0., 2., 4.]\n  META_T_IDXS = [2., 4., 6., 8., 10.]\n\n  # model inputs constants\n  N_FRAMES = 2\n  MODEL_RUN_FREQ = 20\n  MODEL_CONTEXT_FREQ = 5 # \"model_trained_fps\"\n\n  FEATURE_LEN = 512\n\n  DESIRE_LEN = 8\n  TRAFFIC_CONVENTION_LEN = 2\n  LAT_PLANNER_STATE_LEN = 4\n  LATERAL_CONTROL_PARAMS_LEN = 2\n  PREV_DESIRED_CURV_LEN = 1\n\n  # model outputs constants\n  FCW_THRESHOLDS_5MS2 = np.array([.05, .05, .15, .15, .15], dtype=np.float32)\n  FCW_THRESHOLDS_3MS2 = np.array([.7, .7], dtype=np.float32)\n  FCW_5MS2_PROBS_WIDTH = 5\n  FCW_3MS2_PROBS_WIDTH = 2\n\n  DISENGAGE_WIDTH = 5\n  POSE_WIDTH = 6\n  WIDE_FROM_DEVICE_WIDTH = 3\n  LEAD_WIDTH = 4\n  LANE_LINES_WIDTH = 2\n  ROAD_EDGES_WIDTH = 2\n  PLAN_WIDTH = 15\n  DESIRE_PRED_WIDTH = 8\n  LAT_PLANNER_SOLUTION_WIDTH = 4\n  DESIRED_CURV_WIDTH = 1\n\n  NUM_LANE_LINES = 4\n  NUM_ROAD_EDGES = 2\n\n  LEAD_TRAJ_LEN = 6\n  DESIRE_PRED_LEN = 4\n\n  PLAN_MHP_N = 5\n  LEAD_MHP_N = 2\n  PLAN_MHP_SELECTION = 1\n  LEAD_MHP_SELECTION = 3\n\n  FCW_THRESHOLD_5MS2_HIGH = 0.15\n  FCW_THRESHOLD_5MS2_LOW = 0.05\n  FCW_THRESHOLD_3MS2 = 0.7\n\n  CONFIDENCE_BUFFER_LEN = 5\n  RYG_GREEN = 0.01165\n  RYG_YELLOW = 0.06157\n\n  POLY_PATH_DEGREE = 4", "target": "model constants"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/controls/radard.py:KalmanParams:0", "source": "class CLASSTOKEN:\n  def __init__(self, dt: float):\n    # Lead Kalman Filter params, calculating K from A, C, Q, R requires the control library.\n    # hardcoding a lookup table to compute K for values of radar_ts between 0.01s and 0.2s\n    assert dt > .01 and dt < .2, \"Radar time step must be between .01s and 0.2s\"\n    self.A = [[1.0, dt], [0.0, 1.0]]\n    self.C = [1.0, 0.0]\n    #Q = np.matrix([[10., 0.0], [0.0, 100.]])\n    #R = 1e3\n    #K = np.matrix([[ 0.05705578], [ 0.03073241]])\n    dts = [i * 0.01 for i in range(1, 21)]\n    K0 = [0.12287673, 0.14556536, 0.16522756, 0.18281627, 0.1988689,  0.21372394,\n          0.22761098, 0.24069424, 0.253096,   0.26491023, 0.27621103, 0.28705801,\n          0.29750003, 0.30757767, 0.31732515, 0.32677158, 0.33594201, 0.34485814,\n          0.35353899, 0.36200124]\n    K1 = [0.29666309, 0.29330885, 0.29042818, 0.28787125, 0.28555364, 0.28342219,\n          0.28144091, 0.27958406, 0.27783249, 0.27617149, 0.27458948, 0.27307714,\n          0.27162685, 0.27023228, 0.26888809, 0.26758976, 0.26633338, 0.26511557,\n          0.26393339, 0.26278425]\n    self.K = [[np.interp(dt, dts, K0)], [np.interp(dt, dts, K1)]]", "target": "kalman params"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/locationd/lagd.py:Points:0", "source": "class CLASSTOKEN:\n  def __init__(self, num_points: int):\n    self.times = deque[float]([0.0] * num_points, maxlen=num_points)\n    self.okay = deque[bool]([False] * num_points, maxlen=num_points)\n    self.desired = deque[float]([0.0] * num_points, maxlen=num_points)\n    self.actual = deque[float]([0.0] * num_points, maxlen=num_points)\n\n  @property\n  def num_points(self):\n    return len(self.desired)\n\n  @property\n  def num_okay(self):\n    return np.count_nonzero(self.okay)\n\n  def update(self, t: float, desired: float, actual: float, okay: bool):\n    self.times.append(t)\n    self.okay.append(okay)\n    self.desired.append(desired)\n    self.actual.append(actual)\n\n  def get(self) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)", "target": "points"}
{"lang": "python", "dataset": "py_ds", "id": "py_ds:dataset/openpilot/openpilot/selfdrive/monitoring/test_monitoring.py:TestMonitoring:0", "source": "class CLASSTOKEN:\n  def _run_seq(self, msgs, interaction, engaged, standstill):\n    DM = DriverMonitoring()\n    events = []\n    for idx in range(len(msgs)):\n      DM._update_states(msgs[idx], [0, 0, 0], 0, engaged[idx])\n      # cal_rpy and car_speed don't matter here\n\n      # evaluate events at 10Hz for tests\n      DM._update_events(interaction[idx], engaged[idx], standstill[idx], 0, 0)\n      events.append(DM.current_events)\n    assert len(events) == len(msgs), f\"got {len(events)} for {len(msgs)} driverState input msgs\"\n    return events, DM\n\n  def _assert_no_events(self, events):\n    assert all(not len(e) for e in events)\n\n  # engaged, driver is attentive all the time\n  def test_fully_aware_driver(self):\n    events, _ = self._run_seq(always_attentive, always_false, always_true, always_false)\n    self._assert_no_events(events)\n\n  # engaged, driver is distracted and does nothing\n  def test_fully_distracted_driver(self):\n    events, d_status = self._run_seq(always_distracted, always_false, always_true, always_false)\n    assert len(events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL)/2/DT_DMON)]) == 0\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL + \\\n                    ((d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL-d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == \\\n                    EventName.preDriverDistracted\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL + \\\n                    ((d_status.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((d_status.settings._DISTRACTED_TIME + \\\n                    ((TEST_TIMESPAN-10-d_status.settings._DISTRACTED_TIME)/2))/DT_DMON)].names[0] == EventName.driverDistracted\n    assert isinstance(d_status.awareness, float)\n\n  # engaged, no face detected the whole time, no action\n  def test_fully_invisible_driver(self):\n    events, d_status = self._run_seq(always_no_face, always_false, always_true, always_false)\n    assert len(events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL)/2/DT_DMON)]) == 0\n    assert events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL + \\\n                      ((d_status.settings._AWARENESS_PRE_TIME_TILL_TERMINAL-d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == \\\n                      EventName.preDriverUnresponsive\n    assert events[int((d_status.settings._AWARENESS_TIME-d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL + \\\n                      ((d_status.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL)/2))/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert events[int((d_status.settings._AWARENESS_TIME + \\\n                      ((TEST_TIMESPAN-10-d_status.settings._AWARENESS_TIME)/2))/DT_DMON)].names[0] == EventName.driverUnresponsive\n\n  # engaged, down to orange, driver pays attention, back to normal; then down to orange, driver touches wheel\n  #  - should have short orange recovery time and no green afterwards; wheel touch only recovers when paying attention\n  def test_normal_driver(self):\n    ds_vector = [msg_DISTRACTED] * int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON) + \\\n                [msg_ATTENTIVE] * int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON) + \\\n                [msg_DISTRACTED] * int((DISTRACTED_SECONDS_TO_ORANGE+2)/DT_DMON) + \\\n                [msg_ATTENTIVE] * (int(TEST_TIMESPAN/DT_DMON)-int((DISTRACTED_SECONDS_TO_ORANGE*3+2)/DT_DMON))\n    interaction_vector = [car_interaction_NOT_DETECTED] * int(DISTRACTED_SECONDS_TO_ORANGE*3/DT_DMON) + \\\n                         [car_interaction_DETECTED] * (int(TEST_TIMESPAN/DT_DMON)-int(DISTRACTED_SECONDS_TO_ORANGE*3/DT_DMON))\n    events, _ = self._run_seq(ds_vector, interaction_vector, always_true, always_false)\n    assert len(events[int(DISTRACTED_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert len(events[int(DISTRACTED_SECONDS_TO_ORANGE*1.5/DT_DMON)]) == 0\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE*3-0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE*3+0.1)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert len(events[int((DISTRACTED_SECONDS_TO_ORANGE*3+2.5)/DT_DMON)]) == 0\n\n  # engaged, down to orange, driver dodges camera, then comes back still distracted, down to red, \\\n  #                          driver dodges, and then touches wheel to no avail, disengages and reengages\n  #  - orange/red alert should remain after disappearance, and only disengaging clears red\n  def test_biggest_comma_fan(self):\n    _invisible_time = 2  # seconds\n    ds_vector = always_distracted[:]\n    interaction_vector = always_false[:]\n    op_vector = always_true[:]\n    ds_vector[int(DISTRACTED_SECONDS_TO_ORANGE/DT_DMON):int((DISTRACTED_SECONDS_TO_ORANGE+_invisible_time)/DT_DMON)] \\\n                                                        = [msg_NO_FACE_DETECTED] * int(_invisible_time/DT_DMON)\n    ds_vector[int((DISTRACTED_SECONDS_TO_RED+_invisible_time)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time)/DT_DMON)] \\\n                                                        = [msg_NO_FACE_DETECTED] * int(_invisible_time/DT_DMON)\n    interaction_vector[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+0.5)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+1.5)/DT_DMON)] \\\n                                                        = [True] * int(1/DT_DMON)\n    op_vector[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+2.5)/DT_DMON):int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+3)/DT_DMON)] \\\n                                                        = [False] * int(0.5/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, op_vector, always_false)\n    assert events[int((DISTRACTED_SECONDS_TO_ORANGE+0.5*_invisible_time)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_RED+1.5*_invisible_time)/DT_DMON)].names[0] == EventName.driverDistracted\n    assert events[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+1.5)/DT_DMON)].names[0] == EventName.driverDistracted\n    assert len(events[int((DISTRACTED_SECONDS_TO_RED+2*_invisible_time+3.5)/DT_DMON)]) == 0\n\n  # engaged, invisible driver, down to orange, driver touches wheel; then down to orange again, driver appears\n  #  - both actions should clear the alert, but momentary appearance should not\n  def test_sometimes_transparent_commuter(self):\n    _visible_time = np.random.choice([0.5, 10])\n    ds_vector = always_no_face[:]*2\n    interaction_vector = always_false[:]*2\n    ds_vector[int((2*INVISIBLE_SECONDS_TO_ORANGE+1)/DT_DMON):int((2*INVISIBLE_SECONDS_TO_ORANGE+1+_visible_time)/DT_DMON)] = \\\n                                                                                             [msg_ATTENTIVE] * int(_visible_time/DT_DMON)\n    interaction_vector[int((INVISIBLE_SECONDS_TO_ORANGE)/DT_DMON):int((INVISIBLE_SECONDS_TO_ORANGE+1)/DT_DMON)] = [True] * int(1/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, 2*always_true, 2*always_false)\n    assert len(events[int(INVISIBLE_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((INVISIBLE_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert len(events[int((INVISIBLE_SECONDS_TO_ORANGE+0.1)/DT_DMON)]) == 0\n    if _visible_time == 0.5:\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1+0.1+_visible_time)/DT_DMON)].names[0] == EventName.preDriverUnresponsive\n    elif _visible_time == 10:\n      assert events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n      assert len(events[int((INVISIBLE_SECONDS_TO_ORANGE*2+1+0.1+_visible_time)/DT_DMON)]) == 0\n\n  # engaged, invisible driver, down to red, driver appears and then touches wheel, then disengages/reengages\n  #  - only disengage will clear the alert\n  def test_last_second_responder(self):\n    _visible_time = 2  # seconds\n    ds_vector = always_no_face[:]\n    interaction_vector = always_false[:]\n    op_vector = always_true[:]\n    ds_vector[int(INVISIBLE_SECONDS_TO_RED/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time)/DT_DMON)] = [msg_ATTENTIVE] * int(_visible_time/DT_DMON)\n    interaction_vector[int((INVISIBLE_SECONDS_TO_RED+_visible_time)/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time+1)/DT_DMON)] = [True] * int(1/DT_DMON)\n    op_vector[int((INVISIBLE_SECONDS_TO_RED+_visible_time+1)/DT_DMON):int((INVISIBLE_SECONDS_TO_RED+_visible_time+0.5)/DT_DMON)] = [False] * int(0.5/DT_DMON)\n    events, _ = self._run_seq(ds_vector, interaction_vector, op_vector, always_false)\n    assert len(events[int(INVISIBLE_SECONDS_TO_ORANGE*0.5/DT_DMON)]) == 0\n    assert events[int((INVISIBLE_SECONDS_TO_ORANGE-0.1)/DT_DMON)].names[0] == EventName.promptDriverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED-0.1)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED+0.5*_visible_time)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert events[int((INVISIBLE_SECONDS_TO_RED+_visible_time+0.5)/DT_DMON)].names[0] == EventName.driverUnresponsive\n    assert len(events[int((INVISIBLE_SECONDS_TO_RED+_visible_time+1+0.1)/DT_DMON)]) == 0\n\n  # disengaged, always distracted driver\n  #  - dm should stay quiet when not engaged\n  def test_pure_dashcam_user(self):\n    events, _ = self._run_seq(always_distracted, always_false, always_false, always_false)\n    assert sum(len(event) for event in events) == 0\n\n  # engaged, car stops at traffic light, down to orange, no action, then car starts moving\n  #  - should only reach green when stopped, but continues counting down on launch\n  def test_long_traffic_light_victim(self):\n    _redlight_time = 60  # seconds\n    standstill_vector = always_true[:]\n    standstill_vector[int(_redlight_time/DT_DMON):] = [False] * int((TEST_TIMESPAN-_redlight_time)/DT_DMON)\n    events, d_status = self._run_seq(always_distracted, always_false, always_true, standstill_vector)\n    assert events[int((d_status.settings._DISTRACTED_TIME-d_status.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL+1)/DT_DMON)].names[0] == \\\n                                                                                                                    EventName.preDriverDistracted\n    assert events[int((_redlight_time-0.1)/DT_DMON)].names[0] == EventName.preDriverDistracted\n    assert events[int((_redlight_time+0.5)/DT_DMON)].names[0] == EventName.promptDriverDistracted\n\n  # engaged, model is somehow uncertain and driver is distracted\n  #  - should fall back to wheel touch after uncertain alert\n  def test_somehow_indecisive_model(self):\n    ds_vector = [msg_DISTRACTED_BUT_SOMEHOW_UNCERTAIN] * int(TEST_TIMESPAN/DT_DMON)\n    interaction_vector = always_false[:]\n    events, d_status = self._run_seq(ds_vector, interaction_vector, always_true, always_false)\n    assert EventName.preDriverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_ORANGE-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME-0.1)/DT_DMON)].names\n    assert EventName.promptDriverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_ORANGE-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME+0.1)/DT_DMON)].names\n    assert EventName.driverUnresponsive in \\\n                              events[int((INVISIBLE_SECONDS_TO_RED-1+DT_DMON*d_status.settings._HI_STD_FALLBACK_TIME+0.1)/DT_DMON)].names", "target": "test monitoring"}
